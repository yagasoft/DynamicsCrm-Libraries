// This file isn't generated, but this comment is necessary to exclude it from StyleCop analysis.
// Author: Ahmed Elsawalhy (Yagasoft.com)
// Version: 10.1.1
// <auto-generated />

#region Imports

using System;
using System.Activities;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Data;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Net;
using System.Reflection;
using System.Runtime.Caching;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using System.Runtime.Serialization.Json;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml;
using System.Xml.Serialization;
using Microsoft.Crm.Sdk.Messages;
using Microsoft.Xrm.Sdk;
using Microsoft.Xrm.Sdk.Client;
using Microsoft.Xrm.Sdk.Messages;
using Microsoft.Xrm.Sdk.Metadata;
using Microsoft.Xrm.Sdk.Metadata.Query;
using Microsoft.Xrm.Sdk.Query;
using Microsoft.Xrm.Sdk.Workflow;

using Match = System.Text.RegularExpressions.Match;
using RelationshipType = Microsoft.Xrm.Sdk.Metadata.RelationshipType;

#endregion

namespace Yagasoft.Libraries.Common
{

	#region Enums

	/// <summary>
	///     The log levels
	/// </summary>
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public enum LogLevel
	{
		None = 0,
		Error = 10,
		Warning = 20,
		Info = 30,
		Debug = 40
	}

	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public enum PluginUser
	{
		ContextUser,
		InitiatingUser,
		System,
		Custom
	}

	#endregion

	#region Extensions

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static partial class Extensions
	{
		private const string StringExceptionMsg = "String value cannot be empty.";
		private const string DefaultStringFormatExceptionMsg = "String format is invalid.";
		private const string DefaultNullExceptionMessage = "Value cannot be null.";
		private const string DefaultRangeMessage = "Parameter value out of range.";
		private const string DefaultArrayMemberMessage = "Array member can't be null.";
		private const string DefaultParameterName = "Unknown";
		private const string RegexEscapes = @"[\a\b\f\n\r\t\v\\""]";

		/// <summary>
		/// Return the distinct values of the source collection using the key returned by a selector function.<br />
		/// Credit: https://stackoverflow.com/a/24823445/1919456<br />
		/// </summary>
		public static IEnumerable<TSource> DistinctBy<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> selector)
		{
			var set = new HashSet<TResult>();

			foreach (var item in source)
			{
				var selectedValue = selector(item);

				if (set.Add(selectedValue))
				{
					yield return item;
				}
			}
		}

		#region Dates

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static DateTime ConvertToCrmUserTimeZone(this DateTime dateTime, IOrganizationService service, Guid userId)
		{
			var bias = CrmHelpers.GetUserTimeZoneBiasMinutes(service, userId);
			var biasedDate = dateTime.AddMinutes(bias);

			return DateTime.SpecifyKind(biasedDate, DateTimeKind.Local);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static DateTime ConvertToCrmUtcTimeZone(this DateTime dateTime, IOrganizationService service, Guid userId)
		{
			var bias = CrmHelpers.GetUserTimeZoneBiasMinutes(service, userId);
			var biasedDate = dateTime.AddMinutes(-bias);

			return DateTime.SpecifyKind(biasedDate, DateTimeKind.Utc);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static DateTime ConvertBetweenCrmUsersTimeZone(this DateTime dateTime, IOrganizationService service,
			Guid user1Id, Guid user2Id)
		{
			var biases = CrmHelpers.GetUsersTimeZoneBiasMinutes(service, user1Id, user2Id);
			var bias1 = biases[user1Id];
			var bias2 = biases[user2Id];

			var biasedDate = dateTime.AddMinutes(-bias1).AddMinutes(bias2);

			return DateTime.SpecifyKind(biasedDate, DateTimeKind.Local);
		}

		#endregion

		// Credit: http://www.codeproject.com/Articles/290695/Extension-methods-to-simplify-null-argument-check

		#region Param checks

		#region NULL CHECK FOR OBJECT OF ANY CLASS

		/// <summary>
		///     Generic extension method that throws ArgumentNullException if target object is null.
		///     The method is constrained to objects of class type. The method is intended to be used
		///     for null parameter check.
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <typeparam name="T">Type of parameter</typeparam>
		/// <param name="obj">Target object of type T</param>
		/// <param name="paramName">
		///     Name of the parameter.If paramName name is null empty or whitespace default value will be
		///     paramNmae = "Unknown".
		/// </param>
		/// <param name="message">Exception message.If not provided default value is "Value can not be null."</param>
		public static void Require<T>(this T obj, string paramName = DefaultParameterName,
			string message = DefaultNullExceptionMessage)
			where T : class
		{
			if (obj == null)
			{
				ThrowArgumentNullException(ref paramName, ref message);
			}
		}

		#endregion NULL CHECK FOR OBJECT OF ANY CLASS

		#region NULL CHECK FOR OBJECT OF NULLABLE TYPE

		/// <summary>
		///     Generic extension method that throws ArgumentNullException if target object is null.
		///     The method is constrained to objects of class type. The method is intended to be used
		///     for null parameter check.
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <typeparam name="T">Type of parameter</typeparam>
		/// <param name="obj">Target object of type T</param>
		/// <param name="paramName">
		///     Name of the parameter.If paramName name is null empty or whitespace default value will be
		///     paramNmae = "Unknown".
		/// </param>
		/// <param name="message">Exception message.If not provided default value is "Value can not be null."</param>
		public static void Require<T>(this T? obj, string paramName = DefaultParameterName,
			string message = DefaultNullExceptionMessage)
			where T : struct
		{
			if (obj == null)
			{
				ThrowArgumentNullException(ref paramName, ref message);
			}
		}

		/// <summary>
		///     Generic extension method that throws ArgumentNullException if type value is null.
		///     The method is constrained to objects of Nullable struct type. The method is intended to be used
		///     for null parameter check.
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <typeparam name="T">Type of target object</typeparam>
		/// <param name="obj">Target object of type T.</param>
		/// <param name="paramName">
		///     Name of the parameter.if pramName is null empty or whitespace default paramName = "Unknown"
		///     will be used.
		/// </param>
		/// <param name="message">Exception message.If not provoided default value is "Value can not be null."</param>
		public static void RequireValue<T>(this T obj, string paramName = DefaultParameterName,
			string message = DefaultNullExceptionMessage)
			where T : struct
		{
			if (obj.Equals(default(T)))
			{
				ThrowArgumentNullException(ref paramName, ref message);
			}
		}

		#endregion NULL CHECK FOR OBJECT OF NULLABLE TYPE

		#region NULL CHECK FOR OBJECT ARRAY

		/// <summary>
		///     Method throws ArgumentNullException if any of object reference in array is null.
		///     Note : Using value types in array may result in unnecessary boxing.
		///     Use only when you do not care about message , parameter name and empty/whitespace string.
		///     Certainly not enough for production quality code.
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="value">Object array containing target object references.</param>
		/// <param name="paramName"></param>
		/// <param name="message"></param>
		public static void RequireElements<TV>(this IEnumerable<TV> value, string paramName = DefaultParameterName,
			string message = DefaultArrayMemberMessage)
		{
			var valueArray = value as TV[] ?? value?.ToArray();

			valueArray.Require(paramName);

			if (valueArray.Any(param => param == null))
			{
				ThrowArgumentNullException(ref paramName, ref message);
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireCountBelow<T>(this T collection, int max, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : ICollection
		{
			if (collection == null)
			{
				var messageTemp = string.Intern(DefaultNullExceptionMessage);
				ThrowArgumentNullException(ref paramName, ref messageTemp);
				return;
			}

			if (collection.Count >= max)
			{
				message = $@"Collection count must be less than ""{max}"".";
				ThrowArgumentOutOfRangeException(ref paramName, collection, ref message, collection.Count);
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireCountAtMost<T>(this T collection, int max, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : ICollection
		{
			if (collection == null)
			{
				var messageTemp = string.Intern(DefaultNullExceptionMessage);
				ThrowArgumentNullException(ref paramName, ref messageTemp);
				return;
			}

			if (collection.Count > max)
			{
				message = string.Format(@"Collection count must be less than or equal to ""{0}"".", max);
				ThrowArgumentOutOfRangeException(ref paramName, collection, ref message, collection.Count);
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireCountAbove<T>(this T collection, int min, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : ICollection
		{
			if (collection == null)
			{
				var messageTemp = string.Intern(DefaultNullExceptionMessage);
				ThrowArgumentNullException(ref paramName, ref messageTemp);
				return;
			}

			if (collection.Count <= min)
			{
				message = $@"Collection count must be greater than ""{min}"".";
				ThrowArgumentOutOfRangeException(ref paramName, collection, ref message, collection.Count);
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireCountAtLeast<T>(this T collection, int min, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : ICollection
		{
			if (collection == null)
			{
				var messageTemp = string.Intern(DefaultNullExceptionMessage);
				ThrowArgumentNullException(ref paramName, ref messageTemp);
				return;
			}

			if (collection.Count < min)
			{
				message = $@"Collection count must be greater than or equal to ""{min}"".";
				ThrowArgumentOutOfRangeException(ref paramName, collection, ref message, collection.Count);
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireCountInRange<T>(this T collection, int min, int max,
			string paramName = DefaultParameterName, string message = DefaultRangeMessage)
			where T : ICollection
		{
			if (collection == null)
			{
				var messageTemp = string.Intern(DefaultNullExceptionMessage);
				ThrowArgumentNullException(ref paramName, ref messageTemp);
				return;
			}

			if (collection.Count > max && collection.Count < min)
			{
				message = $@"Collection count must be between ""{min}"" and ""{max}"" inclusive.";
				ThrowArgumentOutOfRangeException(ref paramName, collection, ref message, collection.Count);
			}
		}

		#endregion NULL CHECK FOR OBJECT ARRAY

		#region Null, format, and empty check for strings

		/// <summary>
		///     Extension method that throws ArgumentNullException if target string is null , empty or whitespace.
		///     The method is constrained to objects of string type. The method is intended to be used
		///     for null parameter check.
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="value">Target string object</param>
		/// <param name="paramName">
		///     Name of the parameter.if pramName is null empty or whitespace default paramName = "Unknown"
		///     will be used.
		/// </param>
		/// <param name="message">
		///     Exception message.If not provided default value is "String value can not be null , empty of white
		///     space."
		/// </param>
		public static void Require(this string value, string paramName = DefaultParameterName,
			string message = DefaultNullExceptionMessage)
		{
			if (value == null)
			{
				ThrowArgumentNullException(ref paramName, ref message);
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireFilled(this string value, string paramName = DefaultParameterName,
			string message = StringExceptionMsg)
		{
			value.RequireNotEmpty(paramName, message);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireNotEmpty(this string value, string paramName = DefaultParameterName,
			string message = StringExceptionMsg)
		{
			value.Require(paramName);

			if (string.IsNullOrWhiteSpace(value))
			{
				ThrowArgumentNullException(ref paramName, ref message);
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireFormat(this string value, string regex, string paramName = DefaultParameterName,
			string message = DefaultStringFormatExceptionMsg)
		{
			value.Require(paramName);

			if (!Regex.IsMatch(value, regex))
			{
				ThrowArgumentFormatException(ref message, ref paramName, ref regex);
			}
		}

		#endregion

		#region Range check for comparables

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireBelow<T>(this T number, T max, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : IComparable
		{
			if (number.CompareTo(max) >= 0)
			{
				message = $@"Parameter must be less than ""{max}"".";
				ThrowArgumentOutOfRangeException(ref paramName, number, ref message);
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireAtMost<T>(this T number, T max, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : IComparable
		{
			if (number.CompareTo(max) > 0)
			{
				message = $@"Parameter must be less than or equal to ""{max}"".";
				ThrowArgumentOutOfRangeException(ref paramName, number, ref message);
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireAbove<T>(this T number, T min, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : IComparable
		{
			if (number.CompareTo(min) <= 0)
			{
				message = $@"Parameter must be greater than ""{min}"".";
				ThrowArgumentOutOfRangeException(ref paramName, number, ref message);
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireAtLeast<T>(this T number, T min, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : IComparable
		{
			if (number.CompareTo(min) < 0)
			{
				message = $@"Parameter must be greater than or equal to ""{min}"".";
				ThrowArgumentOutOfRangeException(ref paramName, number, ref message);
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireInRange<T>(this T number, T min, T max, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : IComparable
		{
			if (number.CompareTo(min) < 0 || number.CompareTo(max) > 0)
			{
				message = $@"Parameter must be between ""{min}"" and ""{max}"" inclusive.";
				ThrowArgumentOutOfRangeException(ref paramName, number, ref message);
			}
		}

		#endregion

		#endregion

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsEmpty(this IEnumerable e)
		{
			return !e.IsFilled();
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsFilled(this IEnumerable e)
		{
			return e?.Cast<object>().Any() == true;
		}

		#region Strings

		/// <summary>
		///     Credit: http://stackoverflow.com/a/6724896/1919456 <br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string Truncate(this string value, int maxChars, string replacement)
		{
			return value.Length <= maxChars ? value : value.Substring(0, maxChars) + replacement;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsEmpty(this string str)
		{
			return string.IsNullOrWhiteSpace(str);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsAny(this string str)
		{
			return !string.IsNullOrEmpty(str);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsFilled(this string str)
		{
			return !str.IsEmpty();
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsNotEmpty(this string str)
		{
			return str.IsFilled();
		}

		/// <summary>
		///     Credit: http://stackoverflow.com/a/323670/1919456 <br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string StringLiteral(this string value)
		{
			var replaceDict =
				new Dictionary<string, string>
				{
					["\a"] = @"\a",
					["\b"] = @"\b",
					["\f"] = @"\f",
					["\n"] = @"\n",
					["\r"] = @"\r",
					["\t"] = @"\t",
					["\v"] = @"\v",
					["\0"] = @"\0",
					["\""] = @"\""",
					["\\"] = @"\\"
				};

			return replaceDict.Keys.Aggregate(value, (current, key) => current.Replace(key, replaceDict[key]));
		}

		/// <summary>
		///     Credit: http://stackoverflow.com/a/323670/1919456 <br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string StringUnliteral(this string value)
		{
			var replaceDict =
				new Dictionary<string, string>
				{
					[@"\a"] = "\a",
					[@"\b"] = "\b",
					[@"\f"] = "\f",
					[@"\n"] = "\n",
					[@"\r"] = "\r",
					[@"\t"] = "\t",
					[@"\v"] = "\v",
					[@"\0"] = "\0",
					[@"\"""] = "\"",
					[@"\\"] = "\\"
				};

			return replaceDict.Keys.Aggregate(value, (current, key) => current.Replace(key, replaceDict[key]));
		}

		/// <summary>
		///     Compresses a string and returns a deflate compressed, Base64 encoded string.<br />
		///     Credit: https://stackoverflow.com/a/43357353/1919456<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="uncompressedValue">String to compress</param>
		public static string Compress(this string uncompressedValue)
		{
			using (var compressedStream = new MemoryStream())
			{
				using (var uncompressedStream = new MemoryStream(Encoding.UTF8.GetBytes(uncompressedValue)))
				{
					using (var compressorStream = new DeflateStream(compressedStream, CompressionLevel.Optimal, false))
					{
						uncompressedStream.CopyTo(compressorStream);
					}
				}

				return Convert.ToBase64String(compressedStream.ToArray());
			}
		}

		/// <summary>
		///     Decompresses a deflate compressed, Base64 encoded string and returns an uncompressed string.<br />
		///     Credit: https://stackoverflow.com/a/43357353/1919456<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="compressedValue">String to decompress.</param>
		public static string Decompress(this string compressedValue)
		{
			using (var decompressedStream = new MemoryStream())
			{
				using (var compressedStream = new MemoryStream(Convert.FromBase64String(compressedValue)))
				{
					using (var decompressorStream = new DeflateStream(compressedStream, CompressionMode.Decompress))
					{
						decompressorStream.CopyTo(decompressedStream);
						return Encoding.UTF8.GetString(decompressedStream.ToArray());
					}
				}
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string CharLiteral(this char c)
		{
			return c == '\'' ? @"'\''" : string.Format("'{0}'", c);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string XmlEscape(this string unescaped)
		{
			var doc = new XmlDocument();
			XmlNode node = doc.CreateElement("root");
			node.InnerText = unescaped;
			return node.InnerXml;
		}

		#endregion

		#region METHOD THAT ACTUALLY THROWS EXCEPTION

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		private static void ThrowArgumentNullException(ref string paramName, ref string message)
		{
			throw new ArgumentNullException(paramName, message);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		private static void ThrowArgumentOutOfRangeException(ref string paramName, object number, ref string message,
			int currentCount = -1)
		{
			throw new ArgumentOutOfRangeException(paramName, number,
				message + ((currentCount >= 0) ? " Current size is " + currentCount : string.Empty));
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		private static void ThrowArgumentFormatException(ref string paramName, ref string message, ref string regex)
		{
			throw new ArgumentException(message + " Format: " + regex, paramName);
		}

		#endregion METHOD THAT ACTUALLY THROWS EXCEPTION

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsNumeric(this object obj)
		{
			switch (Type.GetTypeCode(obj.GetType()))
			{
				case TypeCode.Byte:
				case TypeCode.SByte:
				case TypeCode.UInt16:
				case TypeCode.UInt32:
				case TypeCode.UInt64:
				case TypeCode.Int16:
				case TypeCode.Int32:
				case TypeCode.Int64:
				case TypeCode.Decimal:
				case TypeCode.Double:
				case TypeCode.Single:
					return true;
				default:
					return false;
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsDateTime(this object obj)
		{
			return Type.GetTypeCode(obj.GetType()) == TypeCode.DateTime;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string StringAggregate<TV>(this IEnumerable<TV> collection, string separator = ",")
		{
			var collectionArray = collection?.FilterNull().ToArray();

			if (collectionArray?.Any() != true)
			{
				return string.Empty;
			}

			return collectionArray
				.Select(e => e as string ?? e.ToString()).Aggregate((e1, e2) => $"{e1}{separator}{e2}");
		}

		/// <summary>
		/// Credit: Microsoft.Xrm.Client assembly
		/// </summary>
		public static TValue FirstNotNullOrDefault<TKey, TValue>(this IDictionary<TKey, TValue> dictionary, params TKey[] keys)
			=> keys
				.Where(dictionary.ContainsKey)
				.Select(key => dictionary[key])
				.FirstOrDefault();

		/// <summary>
		/// Credit: Microsoft.Xrm.Client assembly
		/// </summary>
		public static string FirstNotNullOrEmpty<TKey>(this IDictionary<TKey, string> dictionary, params TKey[] keys)
			=> (keys)
				.Where(key => dictionary.ContainsKey(key) && !string.IsNullOrEmpty(dictionary[key]))
				.Select(key => dictionary[key])
				.FirstOrDefault();
	}

	#endregion

	// -----------------------------------------------------------------------------------------------------------------------------------------------------------------
	//
	// Copyright (c) 2016 Bas van de Sande - JourneyIntoCRM - http://journeyintocrm.com
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
	// to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
	// and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	//
	// -----------------------------------------------------------------------------------------------------------------------------------------------------------------
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class EntitySerializer
	{
		public static string SerializeObject(Entity entity)
		{
			var ds = new DataSet("XmlData");
			var dt = new DataTable(entity.LogicalName);
			ConvertEntityToDataTable(dt, entity);
			ds.Tables.Add(dt);

			return ds.GetXml();
		}

		public static Entity DeserializeObject(string xml)
		{
			var dataSet = new DataSet();

			var xmlBytes = Encoding.UTF8.GetBytes(xml);

			using (var ms = new MemoryStream(xmlBytes))
			{
				dataSet.ReadXml(ms);
			}

			if (dataSet.Tables.Count <= 0)
			{
				return null;
			}

			var dt = dataSet.Tables[0];

			if (dt.Rows.Count <= 0)
			{
				return null;
			}

			var entity = new Entity(dt.TableName);
			var row = dt.Rows[0];

			foreach (DataColumn column in dt.Columns)
			{
				if (column.ColumnName == "Id")
				{
					entity.Id = (Guid?)SetAttributeValue(row[column.ColumnName]) ?? Guid.Empty;
				}
				else
				{
					entity[column.ColumnName] = SetAttributeValue(row[column.ColumnName]);
				}
			}

			return entity;
		}

		private static void ConvertEntityToDataTable(DataTable dataTable, Entity entity)
		{
			var row = dataTable.NewRow();
			dataTable.Columns.Add("Id");
			row["Id"] = GetAttributeValue(entity.Id);

			foreach (var attribute in entity.Attributes.Where(a => a.Value != null))
			{
				if (!dataTable.Columns.Contains(attribute.Key))
				{
					dataTable.Columns.Add(attribute.Key);
				}

				row[attribute.Key] = GetAttributeValue(attribute.Value);
			}

			foreach (var fv in entity.FormattedValues)
			{
				if (!dataTable.Columns.Contains(fv.Key + "name"))
				{
					dataTable.Columns.Add(fv.Key + "name");
				}

				row[fv.Key + "name"] = fv.Value;
			}

			dataTable.Rows.Add(row);
		}

		private static string GetAttributeValue(object entityValue)
		{
			string objectValue;
			var objectReference = "";
			var objectType = entityValue.GetType().FullName;

			if (entityValue is EntityReference)
			{
				objectValue = ((EntityReference)entityValue).Id.ToString();
				objectReference = ((EntityReference)entityValue).LogicalName;
			}
			else if (entityValue is OptionSetValue)
			{
				objectValue = ((OptionSetValue)entityValue).Value.ToString();
			}
			else if (entityValue is Money)
			{
				objectValue = Convert.ToString(((Money)entityValue).Value, CultureInfo.InvariantCulture.NumberFormat);
			}
			else if (entityValue is AliasedValue)
			{
				var av = (AliasedValue)entityValue;
				objectValue = GetAttributeValue(av.Value);
				objectReference = $"{av.EntityLogicalName},{av.AttributeLogicalName}";
			}
			else if (entityValue is Guid)
			{
				objectValue = entityValue.ToString();
			}
			else
			{
				if (entityValue.IsNumeric())
				{
					objectValue = Convert.ToString(entityValue, CultureInfo.InvariantCulture.NumberFormat);
				}
				else if (entityValue.IsDateTime())
				{
					objectValue = ((DateTime)entityValue).ToUniversalTime().ToString("u");
				}
				else
				{
					objectValue = entityValue.ToString();
				}
			}

			if (!string.IsNullOrWhiteSpace(objectReference))
			{
				objectReference += ",";
			}

			return $"{objectType}|{objectReference}{objectValue}";
		}

		private static object SetAttributeValue(object val)
		{
			if (val == null)
			{
				return null;
			}

			var input = val.ToString();
			var tokens = input.Split('|');

			if (tokens.Length != 2)
			{
				return null;
			}

			if (tokens[0].Equals(typeof(EntityReference).FullName))
			{
				var er = tokens[1].Split(',');
				if (er.Length == 2)
				{
					return new EntityReference(er[0], new Guid(er[1]));
				}
			}
			else if (tokens[0].Equals(typeof(OptionSetValue).FullName))
			{
				int i;
				int.TryParse(tokens[1], out i);
				if (i != int.MinValue)
				{
					return new OptionSetValue(i);
				}
			}
			else if (tokens[0].Equals(typeof(Money).FullName))
			{
				decimal d;
				decimal.TryParse(tokens[1], NumberStyles.AllowDecimalPoint, NumberFormatInfo.InvariantInfo, out d);
				if (d != decimal.MinValue)
				{
					return new Money(d);
				}
			}
			else if (tokens[0].Equals(typeof(AliasedValue).FullName))
			{
				var av = tokens[1].Split(',');
				if (av.Length == 3)
				{
					return new AliasedValue(av[0], av[1], SetAttributeValue(av[2]));
				}
			}
			else if (tokens[0].Equals(typeof(Guid).FullName))
			{
				Guid g;
				Guid.TryParse(tokens[1], out g);
				if (g != Guid.Empty)
				{
					return g;
				}
			}
			else if (tokens[0].Equals(typeof(DateTime).FullName))
			{
				DateTime dt;
				DateTime.TryParse(tokens[1], out dt);
				if (dt != DateTime.MinValue)
				{
					return dt.ToUniversalTime();
				}
			}
			else if (tokens[0].Equals(typeof(int).FullName))
			{
				int i32;
				int.TryParse(tokens[1], out i32);
				if (i32 != int.MinValue)
				{
					return i32;
				}
			}
			else if (tokens[0].Equals(typeof(bool).FullName))
			{
				return (tokens[1].ToUpper() == "TRUE");
			}
			else if (tokens[0].Equals(typeof(decimal).FullName))
			{
				decimal sd;
				decimal.TryParse(tokens[1], NumberStyles.AllowDecimalPoint, NumberFormatInfo.InvariantInfo, out sd);
				if (sd != decimal.MinValue)
				{
					return sd;
				}
			}
			else
			{
				// all other values
				return tokens[1];
			}

			return null;
		}
	}

	/// <summary>
	///     Reference Article http://www.codeproject.com/KB/tips/SerializedObjectCloner.aspx
	///     Provides a method for performing a deep copy of an object.
	///     Binary Serialization is used to perform the copy.
	///		Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class ObjectCopier
	{
		/// <summary>
		///     Perform a deep Copy of the object.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <typeparam name="T">The type of object being copied.</typeparam>
		/// <param name="source">The object instance to copy.</param>
		/// <returns>The copied object.</returns>
		public static T Clone<T>(this T source) where T : ISerializable
		{
			if (source == null)
			{
				return default(T);
			}

			IFormatter formatter = new BinaryFormatter();
			Stream stream = new MemoryStream();

			using (stream)
			{
				formatter.Serialize(stream, source);
				stream.Seek(0, SeekOrigin.Begin);
				return (T)formatter.Deserialize(stream);
			}
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class ObjectExtensions
	{
		private static readonly MethodInfo cloneMethod = typeof(object).GetMethod("MemberwiseClone",
			BindingFlags.NonPublic | BindingFlags.Instance);

		public static bool IsPrimitive(this Type type)
		{
			if (type == typeof(string))
			{
				return true;
			}

			return type.IsValueType & type.IsPrimitive;
		}

		public static T Copy<T>(this T original)
		{
			return (T)Copy((object)original);
		}

		private static object Copy(object originalObject)
		{
			return InternalCopy(originalObject, new Dictionary<object, object>(new ReferenceEqualityComparer()));
		}

		private static object InternalCopy(object originalObject, IDictionary<object, object> visited)
		{
			if (originalObject == null)
			{
				return null;
			}

			var typeToReflect = originalObject.GetType();

			if (IsPrimitive(typeToReflect))
			{
				return originalObject;
			}

			if (visited.ContainsKey(originalObject))
			{
				return visited[originalObject];
			}

			if (typeof(Delegate).IsAssignableFrom(typeToReflect))
			{
				return null;
			}

			var cloneObject = cloneMethod.Invoke(originalObject, null);

			if (typeToReflect.IsArray)
			{
				var arrayType = typeToReflect.GetElementType();

				if (IsPrimitive(arrayType) == false)
				{
					var clonedArray = (Array)cloneObject;
					clonedArray.ForEach((array, indices) => array.SetValue(InternalCopy(clonedArray.GetValue(indices), visited), indices));
				}
			}

			visited.Add(originalObject, cloneObject);
			CopyFields(originalObject, visited, cloneObject, typeToReflect);
			RecursiveCopyBaseTypePrivateFields(originalObject, visited, cloneObject, typeToReflect);

			return cloneObject;
		}

		private static void RecursiveCopyBaseTypePrivateFields(object originalObject, IDictionary<object, object> visited,
			object cloneObject, Type typeToReflect)
		{
			if (typeToReflect.BaseType == null)
			{
				return;
			}

			RecursiveCopyBaseTypePrivateFields(originalObject, visited, cloneObject, typeToReflect.BaseType);
			CopyFields(originalObject, visited, cloneObject, typeToReflect.BaseType,
				BindingFlags.Instance | BindingFlags.NonPublic, info => info.IsPrivate);
		}

		private static void CopyFields(object originalObject, IDictionary<object, object> visited, object cloneObject,
			IReflect typeToReflect,
			BindingFlags bindingFlags =
				BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.FlattenHierarchy,
			Func<FieldInfo, bool> filter = null)
		{
			foreach (var fieldInfo in typeToReflect.GetFields(bindingFlags))
			{
				if (filter != null && filter(fieldInfo) == false)
				{
					continue;
				}

				if (IsPrimitive(fieldInfo.FieldType))
				{
					continue;
				}

				var originalFieldValue = fieldInfo.GetValue(originalObject);
				var clonedFieldValue = InternalCopy(originalFieldValue, visited);
				fieldInfo.SetValue(cloneObject, clonedFieldValue);
			}
		}

		public static void CopyValuesFrom(this object self, object parent, bool isDeepCopy = false)
		{
			var bindingFlags = BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.FlattenHierarchy;
			var fromFields = parent.GetType().GetFields(bindingFlags);
			var toFields = self.GetType().GetFields(bindingFlags);

			foreach (var fromField in fromFields)
			{
				var toField = toFields.FirstOrDefault(f => fromField.Name == f.Name && fromField.FieldType == f.FieldType);
				var value = fromField.GetValue(parent);
				toField?.SetValue(self, isDeepCopy ? value.Copy() : value);
			}
		}
	}

	#region Helpers

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public class GenericEqualityComparer<T> : EqualityComparer<T>
	{
		private readonly Func<T, T, bool> equator;
		private readonly Func<T, int> hasher;

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public GenericEqualityComparer(Func<T, T,bool> equator, Func<T, int> hasher = null)
		{
			equator.Require(nameof(equator));
			this.equator = equator;
			this.hasher = hasher;
		}

		public override bool Equals(T x, T y)
		{
			return equator(x, y);
		}

		public override int GetHashCode(T obj)
		{
			return hasher == null ? obj.GetHashCode() : hasher(obj);
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public class ReferenceEqualityComparer : EqualityComparer<object>
	{
		public override bool Equals(object x, object y)
		{
			return ReferenceEquals(x, y);
		}

		public override int GetHashCode(object obj)
		{
			return obj.GetHashCode();
		}
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class ArrayExtensions
	{
		public static void ForEach(this Array array, Action<Array, int[]> action)
		{
			if (array.LongLength == 0)
			{
				return;
			}

			var walker = new ArrayTraverse(array);

			do
			{
				action(array, walker.Position);
			}
			while (walker.Step());
		}

		private class ArrayTraverse
		{
			public int[] Position;
			private readonly int[] maxLengths;

			public ArrayTraverse(Array array)
			{
				maxLengths = new int[array.Rank];

				for (var i = 0; i < array.Rank; ++i)
				{
					maxLengths[i] = array.GetLength(i) - 1;
				}

				Position = new int[array.Rank];
			}

			public bool Step()
			{
				for (var i = 0; i < Position.Length; ++i)
				{
					if (Position[i] >= maxLengths[i])
					{
						continue;
					}

					Position[i]++;

					for (var j = 0; j < i; j++)
					{
						Position[j] = 0;
					}

					return true;
				}
				return false;
			}
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class StringHelpers
	{
		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string ToSentenceCase(this string input)
		{
			return Regex.Replace(
				input,
				@"(?<=(^|\.\s+))[a-z](?=[^A-Z]*(\.$|$|\.\s+|\s))",
				m => m.Value.ToUpper());
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string ToTitleCase(this string input)
		{
			return Regex.Replace(
				input,
				@"(?:^[a-z]|\.\s*[a-z]|\b(?!a|aboard|about|above|across|after|against|along|although|amid|among|an|and|anti|around|as|at|because|before|behind|below|beneath|beside|besides|between|beyond|both|but|by|concerning|consequently|considering|despite|down|during|either|even|except|excepting|excluding|finally|following|for|from|furthermore|hardly|hence|however|if|in|incidentally|indeed|inside|instead|into|lest|like|likewise|meanwhile|minus|near|neither|nor|now|of|off|on|once|onto|opposite|or|outside|over|past|per|plus|provided|rather|regarding|round|save|since|so|such|supposing|than|that|the|though|through|till|to|toward|towards|under|underneath|unless|unlike|until|up|upon|versus|via|when|whenever|where|whereas|wherever|whether|which|while|who|whoever|why|with|within|without|yet)[a-z])",
				m => m.Value.ToUpper());
		}

		/// <summary>
		/// Credit: https://stackoverflow.com/a/25513964/1919456
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string ReplaceGroup(this string input, string pattern, string replacement, RegexOptions? options = null)
		{
			return input.ReplaceGroups(pattern, _ => replacement, options);
		}

		/// <summary>
		/// Credit: https://stackoverflow.com/a/25513964/1919456
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string ReplaceGroup(this string input, string pattern, string groupName, string replacement, RegexOptions? options = null)
		{
			return input.ReplaceGroups(pattern, new Dictionary<string, string> { { groupName, replacement } }, options);
		}

		/// <summary>
		/// Credit: https://stackoverflow.com/a/25513964/1919456
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="replacementMap">Key-value pairs of group name and replacement</param>
		public static string ReplaceGroups(this string input, string pattern, IDictionary<string, string> replacementMap,
			RegexOptions? options = null)
		{
			return input.ReplaceGroups(pattern, replacementMap.ToDictionary(p => p.Key, p => new Func<string, string>(s => p.Value)));
		}

		/// <summary>
		/// Credit: https://stackoverflow.com/a/25513964/1919456
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string ReplaceGroups(this string input, string pattern, Func<string, string> replacementAction, RegexOptions? options = null)
		{
			var match = Regex.Match(input, pattern, options ?? RegexOptions.None);

			if (!match.Success)
			{
				return input;
			}

			var replacementMap = Enumerable.Range(match.Groups.Count > 1 ? 1 : 0, match.Groups.Count)
				.ToDictionary(i => i.ToString(), _ => replacementAction);

			return input.ReplaceGroups(pattern, replacementMap, options);
		}

		/// <summary>
		/// Credit: https://stackoverflow.com/a/25513964/1919456
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="replacementMap">Key-value pairs of group name and replacement</param>
		public static string ReplaceGroups(this string input, string pattern, IDictionary<string, Func<string, string>> replacementMap,
			RegexOptions? options = null)
		{
			return Regex
				.Replace(
					input,
					pattern,
					m =>
					{
						var sb = new StringBuilder();

						var groupMap = replacementMap
							.Select(g =>
								new
								{
									group = g.Key == "-1" ? m.Groups[0] : (int.TryParse(g.Key, out var index) ? m.Groups[index] : m.Groups[g.Key]),
									replacement = g.Value
								})
							.Where(g => g.group != null)
							.OrderBy(g => g.group.Index);

						var previousCaptureEnd = 0;

						foreach (var groupMapping in groupMap)
						{
							var group = groupMapping.group;
							var replacement = groupMapping.replacement;

							foreach (var capture in group.Captures.Cast<Capture>())
							{
								var currentCaptureEnd = capture.Index + capture.Length - m.Index;
								var currentCaptureLength = capture.Index - m.Index - previousCaptureEnd;
								sb.Append(m.Value.Substring(previousCaptureEnd, currentCaptureLength));
								sb.Append(replacement(capture.Value));
								previousCaptureEnd = currentCaptureEnd;
							}
						}

						sb.Append(m.Value.Substring(previousCaptureEnd));

						return sb.ToString();
					}, options ?? RegexOptions.None);
		}

		public static string EscapeCsv(this string input)
		{
			if (string.IsNullOrWhiteSpace(input))
			{
				return input;
			}
			
			return "\"" + input.Replace("\"", "\"\"") + "\"";
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class RegexHelpers
	{
		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IEnumerable<string> ExtractCaptures(this Group group)
		{
			return group.Captures.OfType<Capture>().Select(c => c.Value);
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class CollectionHelpers
	{
		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IEnumerable<TV> FilterNull<TV>(this IEnumerable<TV> collection)
		{
			return collection?.Where(e => e != null);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IEnumerable<TV> FilterEmpty<TV>(this IEnumerable<TV> collection)
		{
			return collection?
				.FilterNull()
				.Where(e => (!(e is string stringValue) || stringValue.IsFilled())
					&& (!(e is IEnumerable ee) || ee.IsFilled()));
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IDictionary<TU, TV> FilterNull<TU, TV>(this IDictionary<TU, TV> dictionary)
		{
			return dictionary?.Where(e => e.Value != null).ToDictionary(p => p.Key, p => p.Value);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IDictionary<TU, TV> FilterEmpty<TU, TV>(this IDictionary<TU, TV> dictionary)
		{
			return dictionary?
				.Where(e => (!(e.Value is string stringValue) || stringValue.IsFilled())
					&& (!(e.Value is IEnumerable ee) || ee.IsFilled()))
				.ToDictionary(p => p.Key, p => p.Value);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool In<TObject>(this TObject obj, IEnumerable<TObject> collection)
			where TObject : class
		{
			return collection != null && collection.Contains(obj);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool ValueIn<TObject>(this TObject obj, IEnumerable<TObject> collection)
			where TObject : struct
		{
			return collection != null && collection.Contains(obj);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool In<TObject, TKey>(this TObject obj, IDictionary<TKey, TObject> dictionary)
			where TObject : class
		{
			return obj.In(dictionary.Values);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool ValueIn<TObject, TKey>(this TObject obj, IDictionary<TKey, TObject> dictionary)
			where TObject : struct
		{
			return obj.ValueIn(dictionary.Values);
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class TypeHelpers
	{
		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static Type[] GetHierarchyTree(this Type type)
		{
			return
				CacheHelpers
					.GetFromMemCacheAdd(
						$"Yagasoft.Common.TypeHelpers.GetHierarchyTree|{type?.FullName}",
						() => AppDomain.CurrentDomain.GetAssemblies().SelectMany(e => e.GetTypes())
							.Where(t => type.IsAssignableFrom(t) && !t.IsGenericTypeDefinition).Distinct().ToArray());
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static Type GetType(string name, Type assemblyScope = null)
		{
			return
				CacheHelpers
					.GetFromMemCacheAdd(
						$"Yagasoft.Common.TypeHelpers.GetType|{name}|{assemblyScope?.FullName}",
						() => assemblyScope == null
							? AppDomain.CurrentDomain.GetAssemblies().SelectMany(a => a.GetTypes())
								.FirstOrDefault(e => e.AssemblyQualifiedName == name || e.FullName == name || e.Name == name)
							: assemblyScope.Assembly.GetTypes()
								.FirstOrDefault(e => e.AssemblyQualifiedName == name || e.FullName == name || e.Name == name));
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static Type GetType(string name, params Assembly[] assembliesScope)
		{
			return
				CacheHelpers
					.GetFromMemCacheAdd(
						$"Yagasoft.Common.TypeHelpers.GetType|{name}|{assembliesScope?.Select(e => e?.FullName).StringAggregate()}",
						() => assembliesScope == null
							? AppDomain.CurrentDomain.GetAssemblies().SelectMany(a => a.GetTypes())
								.FirstOrDefault(e => e.AssemblyQualifiedName == name || e.FullName == name || e.Name == name)
							: assembliesScope.SelectMany(a => a.GetTypes())
								.FirstOrDefault(e => e.AssemblyQualifiedName == name || e.FullName == name || e.Name == name));
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static Type[] GetTypes<TAttribute>(params Type[] assemblyScope) where TAttribute : Attribute
		{
			return 
				CacheHelpers
				.GetFromMemCacheAdd(
					$"Yagasoft.Common.TypeHelpers.GetTypes<{typeof(TAttribute).FullName}>|{assemblyScope?.Select(a => a.FullName).StringAggregate()}",
					() => CacheHelpers
						.GetFromMemCacheAdd(
							$"Yagasoft.Common.TypeHelpers.GetTypes<TAttribute>|{assemblyScope?.Select(a => a.FullName).StringAggregate()}",
							() => (assemblyScope?.SelectMany(a => a.Assembly.GetTypes())
								?? AppDomain.CurrentDomain.GetAssemblies().SelectMany(a => a.GetTypes()).ToArray()).Distinct())
						.Where(e => e.GetCustomAttribute<TAttribute>() != null).ToArray());
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static Type GetType<TAttribute>(Func<TAttribute, bool> predicate, Type assemblyScope = null) where TAttribute : Attribute
		{
			return CacheHelpers
				.GetFromMemCacheAdd(
					$"Yagasoft.Common.TypeHelpers.GetType<{typeof(TAttribute).FullName}>|{assemblyScope?.FullName}",
					() => assemblyScope?.Assembly.GetTypes()
						?? AppDomain.CurrentDomain.GetAssemblies().SelectMany(a => a.GetTypes()).ToArray())
				.FirstOrDefault(e => predicate(e.GetCustomAttribute<TAttribute>()));
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static TAttribute GetAttribute<TAttribute>(this Type type) where TAttribute : Attribute
		{
			return CacheHelpers
				.GetFromMemCacheAdd(
					$"Yagasoft.Common.TypeHelpers.GetAttribute<{typeof(TAttribute).FullName}>|{type.FullName}",
					type.GetCustomAttribute<TAttribute>);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static TAttribute GetAttribute<TAttribute>(this object obj) where TAttribute : Attribute
		{
			return obj.GetType().GetAttribute<TAttribute>();
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsTypeMarked<TAttribute>(this Type type, Func<TAttribute, bool> predicate = null)
			where TAttribute : Attribute
		{
			var attribute = type.GetAttribute<TAttribute>();
			return attribute != null && (predicate == null || predicate(type.GetCustomAttribute<TAttribute>()));
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsTypeMarked<TAttribute>(this object obj, Func<TAttribute, bool> predicate = null)
			where TAttribute : Attribute
		{
			return obj.GetType().IsTypeMarked(predicate);
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static partial class Helpers
	{
		private static readonly IDictionary<Type, Func<object, string>> StringRepresentationsMap =
			new ConcurrentDictionary<Type, Func<object, string>>();

		/// <summary>
		///     Gets the name of the assembly by going back frames in the stack trace.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="skipFrames">
		///     [Optional] The number of frames to go back.<br />
		///     If not specified, it will get the first assembly in the stack that does not equal this one.
		/// </param>
		/// <param name="skipAssemblyName">[Optional] The name of the assembly to skip if frames are set to '-1'.</param>
		/// <returns>The name of the assembly</returns>
		public static string GetAssemblyName(int skipFrames = -1, string skipAssemblyName = null)
		{
			var currentAssembly = new StackFrame().GetMethod().ReflectedType?.AssemblyQualifiedName;
			skipAssemblyName = string.IsNullOrWhiteSpace(skipAssemblyName) ? currentAssembly : skipAssemblyName;

			if (skipFrames < 0 && !string.IsNullOrWhiteSpace(skipAssemblyName))
			{
				for (var i = 1; i < 100; i++)
				{
					var method = new StackFrame(i).GetMethod();

					if (method == null)
					{
						break;
					}

					currentAssembly = method.ReflectedType?.AssemblyQualifiedName;

					if (currentAssembly?.Contains(skipAssemblyName) == true)
					{
						continue;
					}

					break;
				}
			}
			else if (skipFrames >= 0)
			{
				currentAssembly = new StackFrame(skipFrames + 1).GetMethod().ReflectedType?.AssemblyQualifiedName;
			}

			return currentAssembly;
		}

		/// <summary>
		///     Gets the name of the class by going back frames in the stack trace.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="skipFrames">
		///     [Optional] The number of frames to go back.<br />
		///     If not specified, it will get the first class in the stack that does not equal this one.
		/// </param>
		/// <param name="skipClassNamesParams">
		///     [Optional] The name of the classes to skip if frames are set to '-1'. Must be full
		///     name.
		/// </param>
		/// <returns>The name of the class</returns>
		public static string GetClassName(int skipFrames = -1, params string[] skipClassNamesParams)
		{
			Type declaringType = null;
			var currentClass = new StackFrame().GetMethod().ReflectedType;

			var skipClasses = skipClassNamesParams.ToList();
			skipClasses.Add(currentClass?.FullName);

			if (skipFrames < 0)
			{
				for (var i = 1; i < 100; i++)
				{
					var method = new StackFrame(i).GetMethod();

					if (method == null)
					{
						break;
					}

					declaringType = method.ReflectedType;
					var className = declaringType?.FullName ?? string.Empty;

					if (skipClasses.Contains(className))
					{
						continue;
					}

					break;
				}
			}
			else
			{
				declaringType = new StackFrame(skipFrames + 1).GetMethod().ReflectedType;
			}

			return declaringType?.FullName ?? string.Empty;
		}

		/// <summary>
		///     Gets the stack trace of the current execution path.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="skipFrames">
		///     [Optional] The number of frames to go back.<br />
		///     If not specified, it will get the first class in the stack that does not equal this one.
		/// </param>
		/// <param name="skipClassName">
		///     [Optional] The name of the class to skip if frame are set to '-1'. Must be full
		///     name.
		/// </param>
		/// <returns>The stack trace</returns>
		public static string GetStackTrace(int skipFrames = -1, string skipClassName = null)
		{
			var currentClass = new StackFrame().GetMethod().DeclaringType;
			skipClassName = string.IsNullOrWhiteSpace(skipClassName) ? currentClass?.FullName : skipClassName;

			if (skipFrames < 0 && !string.IsNullOrWhiteSpace(skipClassName))
			{
				for (var i = 1; i < 100; i++)
				{
					var method = new StackFrame(i).GetMethod();

					if (method == null)
					{
						break;
					}

					var declaringType = method.DeclaringType;
					var className = declaringType == null ? string.Empty : declaringType.FullName;

					if (className?.Contains(skipClassName) == true)
					{
						continue;
					}

					skipFrames = i - 1;
					break;
				}
			}
			else if (skipFrames < 0)
			{
				skipFrames = 0;
			}

			return new StackTrace(skipFrames + 1).ToString();
		}

		/// <summary>
		///     Add a function that returns a string representing the given type's values to the pool in memory.<br />
		///     This function will be searched for when 'GetStringRepresentation' is called.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="evaluator">
		///     A function that takes an object of the given type
		///     and returns a string representation of the values of that type.
		/// </param>
		public static void AddStringRepresentationFunction<T>(Func<T, string> evaluator)
		{
			evaluator.Require();
			StringRepresentationsMap[typeof(T)] = obj => obj is T ? evaluator((T)obj) : null;
		}

		/// <summary>
		///     Gets the function that returns a string representing the given type's values from the pool in memory.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static Func<object, string> GetStringRepresentationFunction(Type objectType)
		{
			if (objectType == null)
			{
				return null;
			}

			Func<object, string> evaluator;
			StringRepresentationsMap.TryGetValue(objectType, out evaluator);
			return evaluator ?? GetStringRepresentationFunction(objectType.BaseType);
		}

		public static bool IsAlwaysUseDefaultEvaluator;
		public static Func<object, string> DefaultEvaluator;

		/// <summary>
		///     Returns a string representing the given object's value.<br />
		///     This can be used in place of 'ToString'.<br />
		///     Custom functions can be defined and added to the pool using 'AddTypeStringRepresentation'.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetStringRepresentation(object value)
		{
			if (value == null)
			{
				return "null";
			}

			if (IsAlwaysUseDefaultEvaluator && DefaultEvaluator != null)
			{
				return DefaultEvaluator(value);
			}

			StringBuilder builder;

			if (value.GetType().Name == "KeyValuePair`2")
			{
				var valTyped = (dynamic)value;
				return $"({valTyped.Key},{GetStringRepresentation(valTyped.Value)})";
			}

			switch (value)
			{
				case string str:
					return str;
					
				case IEnumerable collection:
				{
					var enumerator = collection.GetEnumerator();
					builder = new StringBuilder();

					var jumpSize = (int)Math.Ceiling(collection.Cast<object>().Count() / 5.0);
					var index = 0;
					var skipped = false;

					builder.Append("[");

					while (enumerator.MoveNext())
					{
						if (index % jumpSize == 0 || index == 0)
						{
							if (index > 0)
							{
								builder.Append(",");

								if (skipped)
								{
									builder.Append("..,");
								}
							}

							builder.Append(GetStringRepresentation(enumerator.Current));
						}
						else
						{
							skipped = true;
						}

						index++;
					}

					builder.Append("]");

					return builder.ToString();
				}
				
				case EntityReference reference:
					return $"{{Logical name = {reference.LogicalName}, ID = {reference.Id}{(reference.Name.IsFilled() ? $", Name = {reference.Name}" : null)}}}";
				
				case Entity entity:
					return $"{{Logical name = {entity.LogicalName}, ID = {entity.Id}, Attributes = {GetStringRepresentation(entity.Attributes)}}}";
			}

			var label = CrmHelpers.GetAttributeName(value);

			if (label != value.GetType().ToString())
			{
				return label;
			}

			var function = GetStringRepresentationFunction(value.GetType());
			return function == null ? (DefaultEvaluator == null ? value.ToString() : DefaultEvaluator(value)) : function(value);
		}

		/// <summary>
		/// Credit: https://stackoverflow.com/a/1641173/1919456
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static Guid? Merge(this Guid? guid1, Guid? guid2)
		{
			if (guid1 == null)
			{
				return guid2;
			}

			if (guid2 == null)
			{
				return guid1;
			}

			const int bytecount = 16;
			var destByte = new byte[bytecount];
			var guid1Byte = guid1.Value.ToByteArray();
			var guid2Byte = guid2.Value.ToByteArray();
     
			for (var i = 0; i < bytecount; i++)
			{
				destByte[i] = (byte) (guid1Byte[i] ^ guid2Byte[i]);
			}

			return new Guid(destByte);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static Guid? Merge(this Guid guid1, Guid? guid2)
		{
			return ((Guid?)guid1).Merge(guid2);
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static partial class CacheHelpers
	{
		/// <summary>
		/// Build an object containing parameters used by the caching methods. The org ID can be provided in order to 
		/// differentiate the cache of different organisations on the same machine.<br />
		/// If no config is found and fallback is not given, no caching is used.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="service">CRM service.</param>
		/// <param name="isAddAssemblyTosuffix">Append assembly name to the suffix.</param>
		/// <param name="suffix">Extra text to append on key.</param>
		/// <param name="fallbackCacheDuration">Duration to use for caching if no config was found in CRM.</param>
		public static CacheParams BuildCacheParams(IOrganizationService service,
			bool isAddAssemblyTosuffix = false, string suffix = null, TimeSpan? fallbackCacheDuration = null, Guid? orgId = null)
		{
			var cacheDuration = CrmHelpers.GetGenericConfig(service, orgId)?.GetAttributeValue<int?>("ys_configurationcacheduration");

			return
				new CacheParams
				{
					CacheSuffix = isAddAssemblyTosuffix
						? $"{Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common")}|{suffix}"
						: suffix,
					CacheExpiryTarget = cacheDuration == null && fallbackCacheDuration.HasValue
						? DateTime.Now + fallbackCacheDuration
						: DateTime.Now.AddMinutes(cacheDuration ?? 0),
					OrgId = orgId
				};
		}

		private const string NullPlaceholder = "YsMemCache|null";

		/// <summary>
		///     Adds the given object to the MemCache.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="key">The string key to add this object under.</param>
		/// <param name="item">The object to add.</param>
		/// <param name="offset">
		///     [OPTIONAL] The time after which to remove the object from the cache.
		/// </param>
		/// <param name="cacheKeysuffix">A string to append to all keys. Usually the assembly name.</param>
		public static T AddToMemCache<T>(string key, T item, DateTimeOffset? offset, string cacheKeysuffix = null,
			Guid? orgId = null)
		{
			key.RequireFilled(nameof(key));

			ObjectCache cache = MemoryCache.Default;

			if (!string.IsNullOrWhiteSpace(cacheKeysuffix))
			{
				key += $"|{cacheKeysuffix}";
			}

			if (orgId.HasValue)
			{
				key += $"|{orgId}";
			}

			RemoveFromMemCache(key);

			if (item == null)
			{
				cache.Add(key, NullPlaceholder, offset ?? ObjectCache.InfiniteAbsoluteExpiration);
			}
			else
			{
				cache.Add(key, item, offset ?? ObjectCache.InfiniteAbsoluteExpiration);
			}

			return item;
		}

		/// <summary>
		///     Adds the given object to the MemCache.<br />
		///     Uses provided cache expiry params.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static T AddToMemCache<T>(string key, T item, string cacheKeysuffix = null, TimeSpan? fallbackCacheDuration = null,
			Guid? orgId = null)
		{
			return AddToMemCache(key, item, null, cacheKeysuffix, fallbackCacheDuration, orgId);
		}

		/// <summary>
		///     Adds the given object to the MemCache.<br />
		///     Uses provided cache expiry params.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static T AddToMemCache<T>(string key, T item, CacheParams cacheParams)
		{
			return AddToMemCache(key, item, cacheParams.CacheExpiryTarget, cacheParams.CacheSuffix, cacheParams.OrgId);
		}

		/// <summary>
		///     Adds the given object to the MemCache.<br />
		///     Automatically retrieves the cache expiry params.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static T AddToMemCache<T>(string key, T item, IOrganizationService service,
			string cacheKeysuffix = null, TimeSpan? fallbackCacheDuration = null, Guid? orgId = null)
		{
			return AddToMemCache(key, item, BuildCacheParams(service, false, cacheKeysuffix, fallbackCacheDuration, orgId));
		}

		/// <summary>
		///     Adds the given object to the MemCache.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="key">The string key to add this object under.</param>
		/// <param name="item">The object to add.</param>
		/// <param name="slidingExpiration">
		///     The duration after which to remove the object from cache, if it was not accessed for that duration.
		/// </param>
		/// <param name="cacheKeysuffix">A string to append to all keys. Usually the assembly name.</param>
		public static T AddToMemCache<T>(string key, T item, TimeSpan slidingExpiration, string cacheKeysuffix = null,
			Guid? orgId = null)
		{
			key.RequireFilled(nameof(key));

			ObjectCache cache = MemoryCache.Default;

			if (!string.IsNullOrWhiteSpace(cacheKeysuffix))
			{
				key += $"|{cacheKeysuffix}";
			}

			if (orgId.HasValue)
			{
				key += $"|{orgId}";
			}

			RemoveFromMemCache(key);

			slidingExpiration = slidingExpiration > TimeSpan.FromDays(365) ? TimeSpan.FromDays(365) : slidingExpiration;

			if (item == null)
			{
				cache.Add(key, NullPlaceholder, new CacheItemPolicy { SlidingExpiration = slidingExpiration });
			}
			else
			{
				cache.Add(key, item, new CacheItemPolicy { SlidingExpiration = slidingExpiration });
			}

			return item;
		}

		/// <summary>
		///     Gets the object from the MemCache.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="key">The string key for the object to get.</param>
		/// <param name="cacheKeySuffix">A string to append to all keys. Usually the assembly name.</param>
		/// <param name="defaultValue">The value to return if the key can't be found in the cache.</param>
		public static TItemType GetFromMemCache<TItemType>(string key, string cacheKeySuffix = null,
			TItemType defaultValue = default(TItemType), Guid? orgId = null)
		{
			key.RequireFilled(nameof(key));

			ObjectCache cache = MemoryCache.Default;

			if (!string.IsNullOrWhiteSpace(cacheKeySuffix))
			{
				key += $"|{cacheKeySuffix}";
			}

			if (orgId.HasValue)
			{
				key += $"|{orgId}";
			}

			if (IsInMemCache(key))
			{
				var value = cache.Get(key);
				return (TItemType)((value as string) == NullPlaceholder ? default(TItemType) : value);
			}

			return defaultValue;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsInMemCache(string key, string cacheKeySuffix = null, Guid? orgId = null)
		{
			key.RequireFilled(nameof(key));

			ObjectCache cache = MemoryCache.Default;

			if (!string.IsNullOrWhiteSpace(cacheKeySuffix))
			{
				key += $"|{cacheKeySuffix}";
			}

			if (orgId.HasValue)
			{
				key += $"|{orgId}";
			}

			return cache.Contains(key);
		}

		/// <summary>
		///     Removes the object from the MemCache.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="key">The string key for the object to remove.</param>
		/// <param name="cacheKeysuffix">A string to append to all keys. Usually the assembly name.</param>
		public static void RemoveFromMemCache(string key, string cacheKeysuffix = null, Guid? orgId = null)
		{
			key.RequireFilled(nameof(key));

			ObjectCache cache = MemoryCache.Default;

			if (!string.IsNullOrWhiteSpace(cacheKeysuffix))
			{
				key += $"|{cacheKeysuffix}";
			}

			if (orgId.HasValue)
			{
				key += $"|{orgId}";
			}

			if (cache.Contains(key))
			{
				cache.Remove(key);
			}
		}

		/// <summary>
		///     Gets the object from the MemCache and add if it doesn't exist.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="key">The string key for the object to get.</param>
		/// <param name="cacheFiller">The function to execute to fill the cache if the key can't be found in the cache.</param>
		/// <param name="cacheParams">Expiry and other params to use.</param>
		/// <param name="defaultValue">The value that if returned by the cache would cause the 'filler' to run anyway.</param>
		public static T GetFromMemCacheAdd<T>(string key, Func<T> cacheFiller, CacheParams cacheParams,
			T defaultValue = default(T))
		{
			cacheParams = cacheParams ?? new CacheParams();

			return IsInMemCache(key, cacheParams.CacheSuffix, cacheParams.OrgId)
				? GetFromMemCache(key, cacheParams.CacheSuffix, defaultValue, cacheParams.OrgId)
				: AddToMemCache(key, cacheFiller(),
					cacheParams.CacheExpiryTarget, cacheParams.CacheSuffix, cacheParams.OrgId);
		}

		/// <summary>
		///     Gets the object from the MemCache and add if it doesn't exist.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static T GetFromMemCacheAdd<T>(string key, Func<T> cacheFiller, DateTimeOffset? offset,
			string cacheKeysuffix = null, T defaultValue = default(T), Guid? orgId = null)
		{
			return IsInMemCache(key, cacheKeysuffix, orgId)
				? GetFromMemCache(key, cacheKeysuffix, defaultValue, orgId)
				: AddToMemCache(key, cacheFiller(), offset, cacheKeysuffix, orgId);
		}

		/// <summary>
		///     Gets the object from the MemCache and add if it doesn't exist.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static T GetFromMemCacheAdd<T>(string key, Func<T> cacheFiller,
			string cacheKeysuffix = null, T defaultValue = default(T), TimeSpan? fallbackCacheDuration = null, Guid? orgId = null)
		{
			return GetFromMemCacheAdd(key, cacheFiller, null, cacheKeysuffix, defaultValue, fallbackCacheDuration, orgId);
		}

		/// <summary>
		///     Gets the object from the MemCache and add if it doesn't exist.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static T GetFromMemCacheAdd<T>(string key, Func<T> cacheFiller, TimeSpan slidingExpiration,
			string cacheKeysuffix = null, T defaultValue = default(T), Guid? orgId = null)
		{
			return IsInMemCache(key, cacheKeysuffix, orgId)
				? GetFromMemCache(key, cacheKeysuffix, defaultValue, orgId)
				: AddToMemCache(key, cacheFiller(), slidingExpiration, cacheKeysuffix, orgId);
		}

		/// <summary>
		///     Gets the object from the MemCache and add if it doesn't exist.<br />
		///     Automatically retrieves the cache expiry params.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="key">The string key for the object to get.</param>
		/// <param name="cacheFiller">The function to execute to fill the cache if the key can't be found in the cache.</param>
		/// <param name="defaultValue">The value that if returned by the cache would cause the 'filler' to run anyway.</param>
		public static T GetFromMemCacheAdd<T>(string key, Func<T> cacheFiller, IOrganizationService service,
			string cacheKeysuffix = null, T defaultValue = default(T), TimeSpan? fallbackCacheDuration = null, Guid? orgId = null)
		{
			return GetFromMemCacheAdd(key, cacheFiller,
				BuildCacheParams(service, false, cacheKeysuffix, fallbackCacheDuration, orgId), defaultValue);
		}
	}

	/// <summary>
	///     credit: http://blog.codeeffects.com/Article/Generate-Random-Numbers-And-Strings-C-Sharp <br />
	///		Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class RandomGenerator
	{
		public enum SymbolFlag
		{
			Custom = 0,
			Uppers = 1,
			Lowers = 2,
			Numbers = 3
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetRandomString(int length, bool isLetterStart, int numberLetterRatio,
			params string[] symbols)
		{
			var sb = new StringBuilder();

			var digits = symbols.Where(symbol => char.IsDigit(symbol[0])).ToArray();
			var letters = symbols.Where(symbol => !char.IsDigit(symbol[0])).ToArray();

			var digitsCount = 0;
			var lettersCount = 0;
			var floatRatio = numberLetterRatio / 100.0;

			for (var i = 0; i < length; i++)
			{
				var filteredSymbols = symbols;

				if (isLetterStart && i == 0)
				{
					lettersCount++;
					filteredSymbols = letters;
				}
				else if (numberLetterRatio > -1)
				{
					if ((lettersCount / (float)length) >= (1 - floatRatio)
						|| (GetRandomNumber(0, 100) <= numberLetterRatio
							&& (digitsCount / (float)length) < floatRatio))
					{
						digitsCount++;
						filteredSymbols = digits;
					}
					else
					{
						lettersCount++;
						filteredSymbols = letters;
					}
				}

				sb.Append(filteredSymbols[GetRandomNumber(0, filteredSymbols.Length)]);
			}

			return sb.ToString();
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetRandomString(int length, bool isLetterStart, params string[] symbols)
		{
			return GetRandomString(length, isLetterStart, -1, symbols);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetRandomString(int length, params string[] symbols)
		{
			return GetRandomString(length, false, -1, symbols);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetRandomString(int length, bool isLetterStart, int numberLetterRatio,
			params SymbolFlag[] symbolFlags)
		{
			symbolFlags.Require(nameof(symbolFlags));

			var array = new List<string>();

			var arraySymbolUppers = new[]
									{
										"A", "B", "C", "D", "E", "F", "G", "H", "J", "K", "L", "M", "N", "P", "R", "S", "T", "U",
										"V", "W", "X", "Y",
										"Z"
									};

			var arraySymbolLowers = new[]
									{
										"a", "b", "c", "d", "e", "f", "g", "h", "j", "k", "m", "n", "p", "q", "r", "s", "t", "u",
										"v", "w", "x", "y",
										"z"
									};

			var arrayNumbers = new[]
							   {
								   "0", "2", "3", "4", "5", "6", "8", "9"
							   };

			if (symbolFlags.Length <= 0)
			{
				symbolFlags = new[] { SymbolFlag.Uppers, SymbolFlag.Lowers, SymbolFlag.Numbers };
			}

			if (symbolFlags.Contains(SymbolFlag.Uppers))
			{
				array.AddRange(arraySymbolUppers);
			}

			if (symbolFlags.Contains(SymbolFlag.Lowers))
			{
				array.AddRange(arraySymbolLowers);
			}

			if (symbolFlags.Contains(SymbolFlag.Numbers))
			{
				array.AddRange(arrayNumbers);
			}

			return GetRandomString(length, isLetterStart, numberLetterRatio, array.ToArray());
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetRandomString(int length, bool isLetterStart, params SymbolFlag[] symbolFlags)
		{
			return GetRandomString(length, isLetterStart, -1, symbolFlags);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetRandomString(int length, params SymbolFlag[] symbolFlags)
		{
			return GetRandomString(length, false, -1, symbolFlags);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static int GetRandomNumber(int maxNumber = 100)
		{
			return GetRandomNumber(0, maxNumber);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static int GetRandomNumber(int minNumber, int maxNumber)
		{
			using (var rngGenerator = new RNGCryptoServiceProvider())
			{
				var b = new byte[4];
				rngGenerator.GetBytes(b);
				var seed = (b[0] & 0x7f) << 24 | b[1] << 16 | b[2] << 8 | b[3];
				var r = new Random(seed);

				return r.Next(minNumber, maxNumber);
			}
		}
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static partial class DateTimeHelpers
	{
		/// <summary>
		///     Gets the number of seconds that has passed since 1/1/1970 12AM.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="endDate">[OPTIONAL=UtcNow] The date to count to.</param>
		/// <returns>Number of seconds.</returns>
		public static long GetSecondsSinceEpoch(DateTime? endDate = null)
		{
			return (long)(endDate ?? DateTime.UtcNow).Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;
		}

		/// <summary>
		///     Gets the day occurence of month.<br />
		///     Credit: http://stackoverflow.com/a/18621645/1919456
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static DateTime? GetDayOccurrenceOfMonth(DateTime dateOfMonth, DayOfWeek dayOfWeek, bool isLastOccurrence)
		{
			return GetDayOccurrenceOfMonth(dateOfMonth, dayOfWeek, 5, isLastOccurrence);
		}

		/// <summary>
		///     Gets the day occurence of month.<br />
		///     Credit: http://stackoverflow.com/a/18621645/1919456
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static DateTime? GetDayOccurrenceOfMonth(DateTime dateOfMonth, DayOfWeek dayOfWeek, int occurrence,
			bool isLastOccurrence)
		{
			occurrence.RequireInRange(1, 5, "occurrence", "Occurrence must be greater than zero and less than 6.");

			if (isLastOccurrence)
			{
				occurrence = 5;
			}

			// Change to first day of the month
			var dayOfMonth = dateOfMonth.AddDays(1 - dateOfMonth.Day);

			// Find first dayOfWeek of this month;
			if (dayOfMonth.DayOfWeek > dayOfWeek)
			{
				dayOfMonth = dayOfMonth.AddDays(7 - (int)dayOfMonth.DayOfWeek + (int)dayOfWeek);
			}
			else
			{
				dayOfMonth = dayOfMonth.AddDays((int)dayOfWeek - (int)dayOfMonth.DayOfWeek);
			}

			// add 7 days per occurrence
			dayOfMonth = dayOfMonth.AddDays(7 * (occurrence - 1));

			// make sure this occurrence is within the original month
			if (dayOfMonth.Month == dateOfMonth.Month)
			{
				return dayOfMonth;
			}
			else
			{
				if (isLastOccurrence)
				{
					return dayOfMonth.AddDays(-7);
				}

				return null;
			}
		}
	}

	/// <summary>
	///     credit: http://pietschsoft.com/post/2008/02/net-35-json-serialization-using-the-datacontractjsonserializer <br />
	///		Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static partial class SerialiserHelpers
	{
		// credit: http://stackoverflow.com/a/12845153/1919456
		public static string SerialiseBase64<T>(this T value) where T : class
		{
			using (var stream = new MemoryStream())
			{
				using (var writer = XmlDictionaryWriter.CreateBinaryWriter(stream))
				{
					var serialiser = new DataContractSerializer(value.GetType());
					serialiser.WriteObject(writer, value);
					return Convert.ToBase64String(stream.ToArray());
				}
			}
		}

		public static T DeserialiseBase64<T>(this string base64) where T : class
		{
			using (var stream = new MemoryStream(Convert.FromBase64String(base64)))
			{
				using (var reader = XmlDictionaryReader
					.CreateBinaryReader(stream, XmlDictionaryReaderQuotas.Max))
				{
					var serialiser = new DataContractSerializer(typeof(T));
					return (T)serialiser.ReadObject(reader);
				}
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string SerialiseStrictXml<T>(T obj) where T : class
		{
			using (var stream = new MemoryStream())
			{
				var serialiser = new DataContractSerializer(obj.GetType());
				serialiser.WriteObject(stream, obj);
				return Encoding.UTF8.GetString(stream.ToArray());
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static T DeserialiseStrictXml<T>(string xml) where T : class
		{
			using (var stream = new MemoryStream(Encoding.UTF8.GetBytes(xml)))
			{
				var serialiser = new DataContractSerializer(typeof(T));
				return (T)serialiser.ReadObject(stream);
			}
		}

		/// <summary>
		///     Author: Ramy Victor
		/// </summary>
		public static string SerialiseContractXml<T>(this T obj) where T : class
		{
			using (var stream = new MemoryStream())
			{
				var serialiser = new XmlSerializer(typeof(T));
				serialiser.Serialize(stream, obj);
				stream.Position = 0;
				return Encoding.UTF8.GetString(stream.ToArray());
			}
		}

		/// <summary>
		///     Author: Ramy Victor
		/// </summary>
		public static T DeserialiseContractXml<T>(this string xml) where T : class
		{
			using (var read = new StringReader(xml))
			{
				using (XmlReader reader = new XmlTextReader(read))
				{
					var serialiser = new XmlSerializer(typeof(T));
					return (T)serialiser.Deserialize(reader);
				}
			}
		}

		public static string SerialiseSimpleDictionary<T>(T obj)
		{
			using (var stream = new MemoryStream())
			{
				GetDictSerializer<T>().WriteObject(stream, obj);
				return Encoding.UTF8.GetString(stream.ToArray());
			}
		}

		public static T DeserialiseSimpleDictionary<T>(string json)
		{
			using (var stream = new MemoryStream())
			{
				using (var writer = new StreamWriter(stream))
				{
					writer.Write(json);
					writer.Flush();
					stream.Position = 0;
					return (T)GetDictSerializer<T>().ReadObject(stream);
				}
			}
		}

		private static DataContractJsonSerializer GetDictSerializer<T>()
		{
			var settings =
				new DataContractJsonSerializerSettings
				{
					UseSimpleDictionaryFormat = true
				};

			return new DataContractJsonSerializer(typeof(T), settings);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string SerialiseSimpleJson(IDictionary<string, string> dictionary, bool isUnformatted = false)
		{
			var pairs = dictionary.Select(pair =>
				string.Format((isUnformatted ? string.Empty : "\t") + "\"{0}\":\"{1}\"", pair.Key, pair.Value?.StringLiteral()))
				.ToArray();
			return "{" + (isUnformatted ? string.Empty : "\r\n") + (pairs.Any() ?
				pairs.Aggregate((e1, e2) => e1 + "," + (isUnformatted ? string.Empty : "\r\n") + e2) : string.Empty)
				+ (isUnformatted ? string.Empty : "\r\n") + "}";
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IDictionary<string, string> DeserialiseSimpleJson(string json)
		{
			if (json.IsEmpty())
			{
				return new Dictionary<string, string>();
			}

			var matches = Regex.Matches(json,
				@"\s*,?\s*['""]?([^{}""'\s]*?)['""]?(?:\s*:\s*)(true|false|\d+|[^\\]?['""](?:\\""|\\'|[^{}'""])*?[^\\]?['""])");

			if (matches.Count <= 0)
			{
				throw new FormatException("JSON is empty or poorly formatted.");
			}

			var dictionary = new Dictionary<string, string>();

			foreach (Match match in matches)
			{
				var groups = match.Groups;

				// the whole string is a match and the rest are pairs
				if ((groups.Count - 1) % 2 != 0)
				{
					throw new FormatException("JSON is poorly formatted.");
				}

				if (string.IsNullOrEmpty(groups[2].Value))
				{
					continue;
				}

				dictionary.Add(groups[1].Value, groups[2].Value.Trim('\'', '\"').StringUnliteral());
			}

			return dictionary;
		}

		/// <summary>
		/// Serialises the object into JSON using the .NET <see cref="DataContractJsonSerializer" />.<br />
		/// Classes must be decorated with <see cref="DataContract" /> and member with <see cref="DataMember" />.<br />
		/// To aid in serialisation, known types can be passed, or pass null and the method will automatically
		/// attempt to find the types. You can optionally limit the scope of the search to the provided type's assembly.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <typeparam name="T">Return type.</typeparam>
		/// <param name="obj">The object to serialise.</param>
		/// <param name="isSerializeReadOnlyTypes">If set to <c>true</c> will serialise <c>readonly</c>
		/// and properties with a <c>get</c> only.</param>
		/// <param name="knownTypes">The known types to consider when serialising.</param>
		/// <param name="assembliesScope">The assemblies scope.</param>
		/// <param name="surrogate">The surrogate.</param>
		/// <param name="latestError">The latest error.</param>
		public static string SerialiseContractJson<T>(this T obj, bool isSerializeReadOnlyTypes = false, IEnumerable<Type> knownTypes = null,
			Assembly[] assembliesScope = null, IDataContractSurrogate surrogate = null, string latestError = null)
			where T : class
		{
			IReadOnlyList<Type> knownTypesArray = knownTypes?.ToArray() ?? Type.EmptyTypes;

			try
			{
				using (var memoryStream = new MemoryStream())
				{
					var serialiser = new DataContractJsonSerializer(typeof(T),
						BuildSerialisationSettings(isSerializeReadOnlyTypes, knownTypesArray, surrogate));
					serialiser.WriteObject(memoryStream, obj);
					return Encoding.Default.GetString(memoryStream.ToArray());
				}
			}
			catch (SerializationException ex)
			{
				var serialised = HandleSerialisationException(ref knownTypesArray, assembliesScope, ref latestError, ex);

				if (serialised)
				{
					return obj.SerialiseContractJson(isSerializeReadOnlyTypes, knownTypesArray, assembliesScope, surrogate, latestError);
				}

				return null;
			}
		}

		/// <summary>
		/// Deserialises the object into JSON using the .NET <see cref="DataContractJsonSerializer" />.<br />
		/// Classes must be decorated with <see cref="DataContract" /> and member with <see cref="DataMember" />.<br />
		/// To aid in deserialisation, known types can be passed, or pass null and the method will automatically
		/// attempt to find the types. You can optionally limit the scope of the search to the provided type's assembly.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <typeparam name="T">Return type.</typeparam>
		/// <param name="json">The json.</param>
		/// <param name="isSerializeReadOnlyTypes">If set to <c>true</c> will deserialise <c>readonly</c>
		/// and properties with a <c>get</c> only.</param>
		/// <param name="knownTypes">The known types to consider when deserialising.</param>
		/// <param name="assembliesScope">The assemblies scope.</param>
		/// <param name="surrogate">The surrogate.</param>
		/// <param name="latestError">The latest error.</param>
		public static T DeserialiseContractJson<T>(this string json, bool isSerializeReadOnlyTypes = false, IEnumerable<Type> knownTypes = null,
			Assembly[] assembliesScope = null, IDataContractSurrogate surrogate = null, string latestError = null)
			where T : class
		{
			IReadOnlyList<Type> knownTypesArray = knownTypes?.ToArray() ?? Type.EmptyTypes;

			try
			{
				using (var memoryStream = new MemoryStream(Encoding.UTF8.GetBytes(json)))
				{
					var serialiser = new DataContractJsonSerializer(typeof(T),
						BuildSerialisationSettings(isSerializeReadOnlyTypes, knownTypesArray, surrogate));
					return (T)serialiser.ReadObject(memoryStream);
				}
			}
			catch (SerializationException ex)
			{
				var serialised = HandleSerialisationException(ref knownTypesArray, assembliesScope, ref latestError, ex);

				if (serialised)
				{
					return json.DeserialiseContractJson<T>(isSerializeReadOnlyTypes, knownTypesArray, assembliesScope,
						surrogate, latestError);
				}

				return null;
			}
		}

		private static bool HandleSerialisationException(ref IReadOnlyList<Type> knownTypes, Assembly[] assembliesScope,
			ref string latestError, SerializationException ex)
		{
			if (latestError == ex.Message)
			{
				throw new SerializationException($"Type is unsupported by [de]serialisation => '{latestError}'.");
			}

			latestError = ex.Message;

			var match = Regex.Match(ex.Message, @"Type '(.+?)'");

			if (match.Groups.Count <= 1)
			{
				match = Regex.Match(ex.Message, @"'https?://.*?/([\w\.]+:(\w+))'");
			}

			if (match.Groups.Count > 1)
			{
				knownTypes = knownTypes.Union(
					new[]
					{
						TypeHelpers.GetType(match.Groups[1].ToString().Replace(':', '.'), assembliesScope)
							?? TypeHelpers.GetType(match.Groups[2].ToString(), assembliesScope)
					}).Where(e => e != null).ToArray();
				return true;
			}

			throw new SerializationException($"Type is unsupported by [de]serialisation => '{latestError}'.");
		}

		private static DataContractJsonSerializerSettings BuildSerialisationSettings(bool isSerializeReadOnlyTypes,
			IEnumerable<Type> knownTypes, IDataContractSurrogate surrogate)
		{
			return new DataContractJsonSerializerSettings
				   {
					   UseSimpleDictionaryFormat = true,
					   SerializeReadOnlyTypes = isSerializeReadOnlyTypes,
					   KnownTypes = knownTypes,
					   DataContractSurrogate = surrogate
				   };
		}

		/// <summary>
		/// Credit: https://stackoverflow.com/a/9347678/1919456
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <seealso cref="System.Runtime.Serialization.IDataContractSurrogate" />
		public class DateTimeCrmContractSurrogate : IDataContractSurrogate
		{
	        private static readonly Regex dateRegex = new Regex(@"/Date\((\d+)([-+])?(\d+)?\)/");
	        private static readonly DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);

	        public object GetCustomDataToExport(Type clrType, Type dataContractType)
	        {
	            // not used
	            return null;
	        }

	        public object GetCustomDataToExport(System.Reflection.MemberInfo memberInfo, Type dataContractType)
	        {
	            // not used
	            return null;
	        }

	        public Type GetDataContractType(Type type)
	        {
	            // not used
	            return type;
	        }

	        public object GetDeserializedObject(object obj, Type targetType)
	        {
	            // for debugging
	            //Console.WriteLine("GetDeserializedObject: obj = {0} ({1}), targetType = {2}", obj, obj.GetType(), targetType);

	            if (obj is DataCollection<string, object> dataCollection)
	            {
		            foreach (var item in dataCollection.ToArray())
		            {
			            dataCollection[item.Key] = ConvertDate(item.Value as string) ?? item.Value;
		            }
	            }

	            if (obj is IDictionary<string, object> dictionary)
	            {
		            foreach (var item in dictionary.ToArray())
		            {
			            dictionary[item.Key] = ConvertDate(item.Value as string) ?? item.Value;
		            }
	            }

		        return CustomIterator(obj);
	        }

			protected virtual object CustomIterator(object obj)
			{
				return obj;
			}

			protected static DateTime? ConvertDate(string unparsedDate)
			{
				if (unparsedDate != null)
				{
					// check if we match the DateTime format
					Match match = dateRegex.Match(unparsedDate);

					if (match.Success)
					{
						// try to parse the string into a long. then create a datetime and convert to local time.
						long msFromEpoch;

						if (long.TryParse(match.Groups[1].Value, out msFromEpoch))
						{
							TimeSpan fromEpoch = TimeSpan.FromMilliseconds(msFromEpoch);
							return TimeZoneInfo.ConvertTimeFromUtc(epoch.Add(fromEpoch), TimeZoneInfo.Local);
						}
					}
				}

				return null;
			}

			public void GetKnownCustomDataTypes(System.Collections.ObjectModel.Collection<Type> customDataTypes)
	        {
	            // not used   
	        }

	        public object GetObjectToSerialize(object obj, Type targetType)
	        {
	            // for debugging
	            //Console.WriteLine("GetObjectToSerialize: obj = {0} ({1}), targetType = {2}", obj, obj.GetType(), targetType);
	            return obj;
	        }

	        public Type GetReferencedTypeOnImport(string typeName, string typeNamespace, object customData)
	        {
	            // not used
	            return null;
	        }

	        public System.CodeDom.CodeTypeDeclaration ProcessImportedType(System.CodeDom.CodeTypeDeclaration typeDeclaration, System.CodeDom.CodeCompileUnit compileUnit)
	        {
	            // not used
	            return typeDeclaration;
	        }
	    }
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class CrmParser
	{
		#region Interpreter
		
		public class Interpreter
		{
			private readonly Type[] expressionTypesLookup;

			private readonly List<Expression> tokenParsers = [];
			private Expression chosenParser;
			private readonly StringBuilder parsedText = new();
			private readonly List<Expression> expressions = [];

			public static RootExpression Parse(string input, IReadOnlyList<Type> expressionTypesLookup = null)
			{
				return new Interpreter(expressionTypesLookup).Interpret(input);
			}

			protected Interpreter(IReadOnlyList<Type> expressionTypesLookup = null)
			{
				this.expressionTypesLookup = (expressionTypesLookup ?? []).Union([GetType()]).ToArray();
			}

			protected RootExpression Interpret(string input)
			{
				var inputStack = new Stack<char>(input.Reverse());
				var context = new ParserContext(expressions);

				FindExpressionClasses(context);

				var isScopeCode = false;

				while (inputStack.Any())
				{
					if ((!context.IsSingleEscape && !context.IsMultiEscape)
						&& !isScopeCode && (inputStack.Peek() is '{' or '}') && inputStack.Count < input.Length)
					{
						isScopeCode = true;
					}
					else
					{
						isScopeCode = false;
					}

					var character = isScopeCode ? '\0' : inputStack.Pop();

					parsedText.Append(character);

					if (context.CodeScopeCount > 0 && !context.IsSingleEscape && !context.IsMultiEscape && Regex.IsMatch(character.ToString(), @"[\s]"))
					{
						if (!inputStack.Any())
						{
							inputStack.Push('\0');
						}
						
						continue;
					}

					var consumers = tokenParsers.Count(parser => parser.Consume(character));
					var chosenParsers = tokenParsers.Where(p => p.IsComplete).ToArray();
					chosenParser = chosenParsers.FirstOrDefault(p => p.GetAttribute<DefaultExpressionAttribute>() is null)
						?? chosenParsers.FirstOrDefault();

					if (chosenParser != null)
					{
						if (chosenParser.GetAttribute<AbstractExpressionAttribute>() != null)
						{
							throw new FormatException($"{chosenParser.GetType().Name.Replace("Expression", "")} '{chosenParser.Value}' is not recognised at: {GetLocationContext()}");
						}

						expressions.Add(chosenParser);
						var position = tokenParsers.IndexOf(chosenParser);
						tokenParsers.Remove(chosenParser);
						tokenParsers.Insert(position, (Expression)Activator.CreateInstance(chosenParser.GetType(), context));

						ResetParsers();

						if (character != '\0')
						{
							inputStack.Push(character);
							parsedText.Remove(parsedText.Length - 1, 1);
						}
					}
					else if (consumers <= 0)
					{
						throw new FormatException($"Expression is not recognised at: {GetLocationContext()}");
					}

					if (!inputStack.Any() && character != '\0')
					{
						inputStack.Push('\0');
					}
				}

				foreach (var expression in expressions)
				{
					expression.SealToken();
				}

				var root = new RootExpression(context);
				root.SealToken();
				root.Build(root, null, new Stack<Expression>(), new Stack<Expression>(expressions.AsQueryable().Reverse()));

				return root;
			}

			private void ResetParsers()
			{
				foreach (var parser in tokenParsers)
				{
					parser.Reset();
				}

				chosenParser = null;
			}

			private void FindExpressionClasses(ParserContext context)
			{
				tokenParsers
					.AddRange(TypeHelpers
						.GetTypes<ExpressionAttribute>(expressionTypesLookup)
						.Select(t => Activator.CreateInstance(t, context)).Cast<Expression>());
			}

			private string GetLocationContext()
			{
				var text = parsedText.ToString();
				var skip = Math.Max(text.Length - 100, 0);
				var take = Math.Max(text.Length - skip, 1);

				return $"{(skip > 0 ? "[...]" : "")}{text.Skip(skip).Take(take - 1).StringAggregate("")}";
			}
		}

		public class ParserContext(List<Expression> expressions)
		{
			public List<Expression> Expressions { get; } = expressions;

			public bool IsSingleEscape;
			public bool IsMultiEscape;
			public int CodeScopeCount;
		}

		public abstract class Token(ParserContext context)
		{
			public string Value { get; protected set; }

			public bool IsComplete
			{
				get => isComplete;
				protected set
				{
					Value = Stringer.ToString().Trim(DelimiterChars);
					isComplete = value;
				}
			}

			public bool IsGibberish { get; protected set; }

			protected bool IsExpressionValued => Value.IsFilled();

			protected virtual char[] DelimiterChars => Array.Empty<char>();
			protected virtual string FinalForm => ".*";
			protected virtual string RecognisePattern => "^rErS2ZofSgWSR2NipB2s$";
			protected StringBuilder Stringer = new();
			protected string Buffer => Stringer?.ToString();
			protected bool IsTokenValued => (Stringer?.Length ?? Value?.Length) > 0;

			protected ParserContext Context { get; private set; } = context;

			private bool isComplete;

			protected virtual bool Preprocess(char character)
			{
				return Context.CodeScopeCount > 0 && !Context.IsSingleEscape && !Context.IsMultiEscape;
			}

			public bool Consume(char character)
			{
				if (!Preprocess(character))
				{
					return false;
				}

				if (IsGibberish || IsComplete)
				{
					return false;
				}

				if (character != '\0' && IsRecognisable(character))
				{
					if (!Context.IsSingleEscape)
					{
						Stringer.Append(character);
					}

					return true;
				}

				if (IsTokenValued && Regex.IsMatch(Buffer, FinalForm) && PreComplete(character))
				{
					IsComplete = true;
					PostComplete(character);
					return false;
				}

				IsGibberish = true;
				return false;
			}

			protected virtual bool IsRecognisable(char character) =>
				Regex.IsMatch(Buffer + character, RecognisePattern);

			protected virtual bool PreComplete(char character) => true;

			protected virtual void PostComplete(char character)
			{ }

			public void Reset()
			{
				Stringer.Clear();
				Value = null;
				IsGibberish = false;
				isComplete = false;
			}

			public void SealToken()
			{
				if (!IsComplete)
				{
					IsComplete = true;
				}

				Stringer = null;
				Context = null;
			}
		}

		#endregion

		#region Evaluation
		
		public class GlobalState(IOrganizationService service, object contextObject = null, Guid? orgId = null)
		{
			private static readonly TimeSpan fallbackCacheDuration = TimeSpan.FromMinutes(1);

			public readonly IOrganizationService Service = service;
			public readonly Guid? OrgId = orgId;

			public readonly bool IsContextProvided;
			public Entity Context;
			public object ContextObject = contextObject;
			public Entity User;

			public Expression FaultyNode;

			public int Lcid = 1033;

			internal bool IsDebug;
			internal readonly StringBuilder DebugStringBuilder = new();

			private readonly IDictionary<string, object> cache = new Dictionary<string, object>();
			private readonly IDictionary<string, object> memory = new Dictionary<string, object>();

			public GlobalState(EntityReference contextRef, IOrganizationService service, object contextObject = null, Guid? orgId = null)
				: this(new Entity(contextRef.LogicalName, contextRef.Id), service, contextObject, orgId)
			{
				IsContextProvided = false;
			}

			public GlobalState(Entity context, IOrganizationService service, object contextObject = null, Guid? orgId = null)
				: this(service, contextObject, orgId)
			{
				Context = context;
				IsContextProvided = true;
			}

			public T AddCached<T>(string key, T obj, bool isGlobal = false)
			{
				if (isGlobal)
				{
					CacheHelpers.AddToMemCache(key, obj, Service, fallbackCacheDuration: fallbackCacheDuration, orgId: OrgId);
				}
				else
				{
					cache[key] = obj;
				}

				return obj;
			}

			public T GetCachedAdd<T>(string key, Func<T> objFunc, bool isGlobal = false)
			{
				var cached = GetCached<T>(key);

				if (cached != null)
				{
					return cached;
				}

				var obj = objFunc();

				if (isGlobal)
				{
					CacheHelpers.AddToMemCache(key, obj, Service, fallbackCacheDuration: fallbackCacheDuration, orgId: OrgId);
				}
				else
				{
					cache[key] = obj;
				}

				return obj;
			}

			public T GetCached<T>(string key)
			{
				return cache.TryGetValue(key, out var obj) && obj is T cast
					? cast
					: (CacheHelpers.GetFromMemCache<object>(key, orgId: OrgId) is T castGlobal ? castGlobal : default);
			}

			public string GetCached(string key)
			{
				return GetCached<string>(key);
			}

			public T Store<T>(string key, T obj)
			{
				memory[key] = obj;
				return obj;
			}

			public T Read<T>(string key)
			{
				return memory.TryGetValue(key, out var obj) && obj is T cast ? cast : default;
			}

			public string Read(string key)
			{
				return Read<string>(key);
			}
		}

		public record ExpressionValue(Expression Expression, object Value)
		{
			public Expression Expression { get; private set; } = Expression;
			public object Value { get; } = Value;
		}

		public class TraversalContext(Func<IEnumerable<ExpressionValue>, TraversalContext, object> childrenAggregateOperation = null,
			Func<Expression, bool> stopAt = null, bool isInclude = true)
		{
			internal bool IsStop { get; set; }
			internal Func<IEnumerable<ExpressionValue>, TraversalContext, object> ChildrenAggregateOperation { get; } = childrenAggregateOperation;
			internal Func<Expression, bool> StopAt { get; } = stopAt;
			internal bool IsInclude { get; } = isInclude;
		}

		#endregion

		#region Expression definitions
		
		[AttributeUsage(AttributeTargets.Class, Inherited = false)]
		public class AbstractExpressionAttribute : Attribute;

		[AttributeUsage(AttributeTargets.Class, Inherited = false)]
		public class ExpressionAttribute : Attribute;

		[AttributeUsage(AttributeTargets.Class, Inherited = false)]
		public class DefaultExpressionAttribute : Attribute;

		[AttributeUsage(AttributeTargets.Method, Inherited = false)]
		public class FunctionLogicAttribute(string name, bool isEvalParams = true) : Attribute
		{
			public string Name { get; } = name;
			public bool IsEvalParams { get; } = isEvalParams;
		}

		public record FunctionLogic(string Name, bool IsEvalParams, MethodInfo Method)
		{
			public string Name { get; } = Name;
			public bool IsEvalParams { get; } = IsEvalParams;
			public MethodInfo Method { get; } = Method;
		}

		public record RegexDefinition(string Regex, bool IsFlat = false, int Levels = 2)
		{
			public string Regex { get; } = Regex;
			public bool IsFlat { get; } = IsFlat;
			
			public int Levels { get; } = Levels is > 2 or < 0
				? throw new ArgumentOutOfRangeException(nameof(Levels), Levels, $"Regex flattening level is out of range (0-2): {Levels}.")
				: Levels;
		}

		private class CollectionOpResult(object key, object element)
		{
			public object Key { get; } = key;
			public object Element { get; } = element;
				
			public override bool Equals(object obj)
			{
				if (obj is not CollectionOpResult p)
				{
					return false;
				}

				return p.Key.Equals(Key);
			}
				
			public override int GetHashCode()
			{
				return Key == null ? 0 : Key.GetHashCode();
			}
		}

		private class ChoiceParams(Entity row, OptionSetValue choice, string property)
		{
			public Entity Row { get; } = row;
			public OptionSetValue Choice { get; } = choice;
			public string Property { get; } = property;
		}

		public abstract class Expression(ParserContext context) : Token(context)
		{
			public Expression Root { get; protected set; }
			public Expression Parent { get; set; }
			public List<Expression> ChildExpressions { get; protected set; } = [];

			/// <summary>
			///     Go through the tree, in in-order traversal, and apply the operations given.
			/// </summary>
			/// <param name="nodeOperation">
			///     The type parameters:
			///     the current expression, children aggregrate result (if given), traversal context.
			///     Returns operation result.
			/// </param>
			/// <param name="childrenAggregateOperation">
			///     [Optional] The type parameters: a list of (child expression, child operation
			///     value) pair and traversal context.
			///     Returns the aggregate result.
			/// </param>
			/// <param name="stopAt">[Optional] Stops traversing when this node is reached.</param>
			/// <param name="isInclude">[Optional] If 'true' apply the operation to the <paramref name="stopAt" /> as well.</param>
			/// <returns>The nodeOperation result.</returns>
			public object Traverse(Func<Expression, object, TraversalContext, object> nodeOperation,
				Func<IEnumerable<ExpressionValue>, TraversalContext, object> childrenAggregateOperation = null,
				Func<Expression, bool> stopAt = null, bool isInclude = true)
			{
				var traversalContext = new TraversalContext(childrenAggregateOperation, stopAt, isInclude);
				return InnerTraverse(nodeOperation, traversalContext).Value;
			}

			protected ExpressionValue InnerTraverse(Func<Expression, object, TraversalContext, object> nodeOperation, TraversalContext traversalContext)
			{
				var childResults = ChildExpressions
					.Select(
						e => // ReSharper disable once AssignmentInConditionalExpression
							(traversalContext.IsStop = traversalContext.IsStop || traversalContext.StopAt?.Invoke(e) == true)
								? null
								: e.InnerTraverse(nodeOperation, traversalContext))
					.FilterNull().ToList();

				// isInclude == true
				if (childResults.Count < ChildExpressions.Count && traversalContext.IsInclude)
				{
					var result = ChildExpressions.Skip(childResults.Count).Take(1)
						.Select(e => e.InnerTraverse(nodeOperation, traversalContext)).ToArray();

					if (result.Any())
					{
						childResults.AddRange(result);
					}
				}

				return new ExpressionValue(
					this,
					nodeOperation(this, traversalContext.ChildrenAggregateOperation?.Invoke(childResults, traversalContext), traversalContext));
			}

			public string Evaluate(IOrganizationService service = null, Entity record = null, object contextObject = null)
			{
				var state = new GlobalState(record, service, contextObject);

				object result = null;

				try
				{
					result = HandledEvaluate(state);
					result = result as string
						?? (result is ICollection collection ? collection.Cast<object>().StringAggregate(string.Empty) : result.ToString());
				}
				catch (Exception ex)
				{
					if (state.DebugStringBuilder.Length <= 0)
					{
						var text = Print(stopAt: e => e == state.FaultyNode);

						var skip = Math.Max(text.Length - 100, 0);
						var take = Math.Max(text.Length - skip, 1);

						throw new InvalidOperationException($"Evaluation failed at:\r\n" +
							$"{(skip > 0 ? "[...]" : string.Empty)}{text.Skip(skip).Take(take - 1).StringAggregate(string.Empty)}\r\n"
							+ $"See inner exception for details.",
							ex);
					}
				}
				
					return state.DebugStringBuilder.Length > 0 ? state.DebugStringBuilder.ToString() : result as string;
			}

			public string Debug(IOrganizationService service = null, Entity record = null, object contextObject = null)
			{
				var state = 
					new GlobalState(record, service, contextObject)
					{
						IsDebug = true
					};

				try
				{
					HandledEvaluate(state);
				}
				catch
				{
					// ignored
				}

				return state.DebugStringBuilder.ToString();
			}

			protected internal object HandledEvaluate(GlobalState state, object baseValue = null)
			{
				if (state.IsDebug)
				{
					state.DebugStringBuilder.AppendLine("");
				}
				
				try
				{
					if (state.IsDebug)
					{
						state.DebugStringBuilder.Append(Value);
					}
					
					var result = InnerEvaluate(state, baseValue);
					
					if (state.IsDebug)
					{
						state.DebugStringBuilder.Append("   >>>   ");
						state.DebugStringBuilder.Append(result?.GetType().Name);
						state.DebugStringBuilder.Append("::");
						state.DebugStringBuilder.AppendLine(Helpers.GetStringRepresentation(result));
					}
					
					return result;
				}
				catch (Exception ex)
				{
					state.FaultyNode ??= this;
					
					if (state.IsDebug)
					{
						state.DebugStringBuilder.AppendLine();
						state.DebugStringBuilder.AppendLine(ex.BuildShortExceptionMessage());
					}
					
					throw;
				}
			}

			protected abstract object InnerEvaluate(GlobalState state, object baseValue = null);

			public string Print(Func<Expression, string, string> nodeModifier = null, Func<Expression, bool> stopAt = null, bool isInclude = true, string expressionWrapper = null)
			{
				expressionWrapper ??= "```exp";
				return
					Traverse(
						(expression, childResult, traversalContext) =>
						{
							var children = childResult as IReadOnlyList<object>;
							var result =
								expression switch
								{
									RootExpression => children?.StringAggregate(string.Empty),
									UnaryOperatorExpression unary => $"{unary.Value}{children?.LastOrDefault()}",
									BinaryOperatorExpression binary => $"{children?.FirstOrDefault()}{binary.Value}{children?.LastOrDefault()}",
									ScopeExpression scope =>
										$"{scope.OpeningBrace}{(scope is InternalScopeExpression
											? new Regex(",").Replace(children?.FirstOrDefault()?.ToString() ?? string.Empty, string.Empty, 1)
											: children?.FirstOrDefault())}"
											+ $"{children?.Skip(1).StringAggregate(string.Empty)}{(traversalContext.IsStop ? string.Empty : scope.ClosingBrace)}",
									FunctionExpression function => $"${function.Value}{children?.StringAggregate(string.Empty)}",
									MemoryExpression memory => $"~{memory.Value}",
									TextExpression text => $"`{text.Value}`",
									_ => expression.Value
								};

							if (nodeModifier != null)
							{
								result = nodeModifier(expression, result);
							}

							return expressionWrapper
								.Replace("```exp", result)
								.Replace("```type",
									(expression switch {
										OperatorExpression => nameof(OperatorExpression),
										ScopeExpression => nameof(ScopeExpression),
										FunctionExpression => nameof(FunctionExpression),
										ObjectExpression => nameof(ObjectExpression),
										MemoryExpression => nameof(MemoryExpression),
										TextExpression => nameof(TextExpression),
										LiteralExpression => nameof(LiteralExpression),
										_ => "other"
										}).Replace("Expression", string.Empty).ToLower());
						},
						(children, _) =>
							children.Select(e => e.Value ?? string.Empty).ToArray(),
						stopAt,
						isInclude).ToString();
			}

			protected virtual Stack<Expression> PreBuild(Stack<Expression> parentDoneExpressions, Stack<Expression> pendingExpressions)
			{
				return new Stack<Expression>();
			}

			public void Build(Expression root, Expression parent,
				Stack<Expression> parentDoneExpressions, Stack<Expression> pendingExpressions)
			{
				Root = root;
				Parent = parent;

				InnerBuild(parentDoneExpressions, pendingExpressions);
			}

			protected abstract void InnerBuild(Stack<Expression> parentDoneExpressions, Stack<Expression> pendingExpressions);
		}
		
		#endregion
		
		#region Scopes

		public abstract class ScopeExpression(ParserContext context) : Expression(context)
		{
			public virtual string OpeningBrace => "(";
			public virtual string ClosingBrace => ")";

			protected override string RecognisePattern => 
				$"^[{(OpeningBrace.IsFilled() ? @$"\{OpeningBrace}" : "")}{(ClosingBrace.IsFilled() ? @$"\{ClosingBrace}" : "")}]$";

			protected override object InnerEvaluate(GlobalState state, object baseValue = null) =>
				ChildExpressions.Aggregate(baseValue, (current, childExpression) => childExpression.HandledEvaluate(state, current));

			protected override Stack<Expression> PreBuild(Stack<Expression> parentDoneExpressions, Stack<Expression> pendingExpressions)
			{
				return new Stack<Expression>();
			}

			protected override void InnerBuild(Stack<Expression> parentDoneExpressions, Stack<Expression> pendingExpressions)
			{
				var doneExpressions = PreBuild(parentDoneExpressions, pendingExpressions);

				var isClosed = false;

				while (pendingExpressions.Any())
				{
					var currentExpression = pendingExpressions.Pop();

					// defer operators till the end to handle precendence
					if (currentExpression is OperatorExpression)
					{
						doneExpressions.Push(currentExpression);
						continue;
					}
					
					var expressionValue = currentExpression.Value;

					if (expressionValue == ClosingBrace && Value == OpeningBrace)
					{
						isClosed = true;
						break;
					}

					// upcoming is closure for an unrelated scope
					if (currentExpression is ScopeExpression scope
						&& scope.OpeningBrace != Value && scope.ClosingBrace == scope.Value)
					{
						pendingExpressions.Push(currentExpression);
						break;
					}

					currentExpression.Build(Root, this, doneExpressions, pendingExpressions);
					doneExpressions.Push(currentExpression);
				}

				if (!isClosed && (Value == OpeningBrace || Value == ClosingBrace))
				{
					throw new FormatException("Closing brace mismatch.");
				}

				ProcessOperators(doneExpressions);

				ChildExpressions.AddRange(doneExpressions.Reverse());
			}

			protected void ProcessOperators(Stack<Expression> doneExpressions)
			{
				var operators = doneExpressions.OfType<OperatorExpression>().Where(e => e.Precedence > 0);
				var processed = new List<OperatorExpression>();
				
				// ReSharper disable once PossibleMultipleEnumeration
				while (processed.Count < operators.Count())
				{
				// ReSharper disable once PossibleMultipleEnumeration
					var op = operators.Reverse().Where(e => !processed.Contains(e)).OrderByDescending(e => e.Precedence).FirstOrDefault();

					if (op == null)
					{
						break;
					}
					
					var pending = new Stack<Expression>();
					
					while(doneExpressions.Any() && doneExpressions.Peek() != op)
					{
						pending.Push(doneExpressions.Pop());
					}

					doneExpressions.Pop();
					op.Build(Root, this, doneExpressions, pending);
					doneExpressions.Push(op);
					
					while(pending.Any())
					{
						doneExpressions.Push(pending.Pop());
					}
					
					processed.Add(op);
				}
			}
		}

		public sealed class RootExpression(ParserContext context) : ScopeExpression(context)
		{
			protected override object InnerEvaluate(GlobalState state, object baseValue = null) =>
				ChildExpressions.Select(c => c.HandledEvaluate(state, baseValue)).ToArray();

			protected override void InnerBuild(Stack<Expression> parentDoneExpressions, Stack<Expression> pendingExpressions)
			{
				var doneExpressions = PreBuild(parentDoneExpressions, pendingExpressions);

				while (pendingExpressions.Any())
				{
					var currentExpression = pendingExpressions.Pop();
					currentExpression.Build(this, this, doneExpressions, pendingExpressions);
					doneExpressions.Push(currentExpression);
				}

				ProcessOperators(doneExpressions);
					
				ChildExpressions.AddRange(doneExpressions.Reverse());
			}
		}

		[Expression]
		public class InternalScopeExpression(ParserContext context) : ScopeExpression(context)
		{
			public override string OpeningBrace => "(";
			public override string ClosingBrace => ")";

			protected override Stack<Expression> PreBuild(Stack<Expression> parentDoneExpressions, Stack<Expression> pendingExpressions)
			{
				var doneExpressions = new Stack<Expression>();

				if (Value == OpeningBrace)
				{
					var childScope = new SeparatorExpression(Context);
					childScope.Build(Root, this, doneExpressions, pendingExpressions);
					doneExpressions.Push(childScope);
				}

				return doneExpressions;
			}
		}

		[Expression]
		public sealed class SeparatorExpression(ParserContext context) : ScopeExpression(context)
		{
			public override string OpeningBrace => ",";
			public override string ClosingBrace => "";

			protected override void InnerBuild(Stack<Expression> parentDoneExpressions, Stack<Expression> pendingExpressions)
			{
				var doneExpressions = PreBuild(parentDoneExpressions, pendingExpressions);

				while (pendingExpressions.Any())
				{
					var currentExpression = pendingExpressions.Pop();

					// defer operators till the end to handle precendence
					if (currentExpression is OperatorExpression)
					{
						doneExpressions.Push(currentExpression);
						continue;
					}
					
					if (currentExpression is SeparatorExpression
						|| currentExpression is ScopeExpression scope && scope.ClosingBrace == scope.Value)
					{
						pendingExpressions.Push(currentExpression);
						break;
					}

					currentExpression.Build(Root, this, doneExpressions, pendingExpressions);
					doneExpressions.Push(currentExpression);
				}

				ProcessOperators(doneExpressions);
				
				ChildExpressions.AddRange(doneExpressions.Reverse());
			}
		}

		[Expression]
		public sealed class CodeExpression(ParserContext context) : ScopeExpression(context)
		{
			public override string OpeningBrace => "{";
			public override string ClosingBrace => "}";

			private bool isCounted;

			protected override bool Preprocess(char character)
			{
				if (Context.IsSingleEscape || Context.IsMultiEscape)
				{
					return false;
				}

				if (!isCounted)
				{
					switch (character)
					{
						case '{':
							Context.CodeScopeCount++;
							isCounted = true;
							return true;

						case '}':
							Context.CodeScopeCount--;
							isCounted = true;
							return true;
					}
				}

				return true;
			}
		}

		[Expression]
		public sealed class CollectionExpression(ParserContext context) : InternalScopeExpression(context)
		{
			public override string OpeningBrace => "[";
			public override string ClosingBrace => "]";
			
			protected override object InnerEvaluate(GlobalState state, object baseValue = null) =>
				ChildExpressions.Select(e => e.HandledEvaluate(state, baseValue)).ToArray();
		}
		
		#endregion

		#region Objects

		[Expression]
		[DefaultExpression]
		public class ObjectExpression(ParserContext context) : Expression(context)
		{
			protected override char[] DelimiterChars => new[] { '\0' };
			protected override string FinalForm => "^[@.#%][a-zA-Z][a-zA-Z0-9_]*$";
			protected override string RecognisePattern => "^[@.#%](?:[a-zA-Z][a-zA-Z0-9_]*)?$";

			protected override object InnerEvaluate(GlobalState state, object baseValue = null)
			{
				switch (Value)
				{
					case "@this":
						return state.Context;
						
					case "@value":
						return baseValue;
						
					case "@user":
					{
						if (state.User != null)
						{
							return state.User;
						}
						
						var userId = ((WhoAmIResponse)state.Service.Execute(new WhoAmIRequest())).UserId;
						state.User = state.Service.Retrieve("systemuser", userId,
							new ColumnSet("systemuserid", "timezonebias", "fullname", "internalemailaddress", "title", "parentsystemuserid"));
						state.User["lcid"] = (int?)CrmHelpers.GetPreferredLangCode(state.Service, state.User.ToEntityReference());

						return state.User;
					}
						
					default:
					{
						if (baseValue is null)
						{
							return null;
						}

						if (Value.StartsWith("@"))
						{
							return state.Read<object>(Value.Trim('@'));
						}

						if (Value.StartsWith("."))
						{
							var property = Value.Trim('.');

							switch (baseValue)
							{
								case Entity entity:
								{
									var value = entity.GetAttributeValue<object>(property);
									return value switch {
										Guid id => id.ToString().ToLower(),
										Money money => (double)money.Value,
										decimal dec => (double)dec,
										float flo => (double)flo,
										OptionSetValue choice => new ChoiceParams(entity, choice, property),
										null => entity.Contains(property)
											? null
											: entity.IntegrateAttributes(state.Service.Retrieve(entity.LogicalName, entity.Id, new ColumnSet(property)))
												.GetAttributeValue<object>(property),
										"name" =>entity["name"] = CrmHelpers
											.GetRecordName(state.Service, entity, true, null, state.OrgId),
										"logical" => entity.LogicalName,
										"id" => entity.Id.ToString().ToLower(),
										"url" => entity["url"] = CrmHelpers
											.GetRecordUrl(state.Service, entity.ToEntityReference(), state.OrgId),
										_ => value
										};
								}

								case EntityReference reference:
									return property switch {
										"id" => reference.Id.ToString().ToLower(),
										"logical" => reference.LogicalName,
										"name" => reference.Name,
										_ => state.Service.Retrieve(reference.LogicalName, reference.Id, new ColumnSet(property))
											.GetAttributeValue<object>(property)
										};

								case ChoiceParams choice:
									return property switch {
"name" => state.Lcid == 1033 && choice.Row.FormattedValues.TryGetValue(property, out var label)
	? label : 
	MetadataHelpers.GetOptionSetLabel(state.Service, choice.Row.LogicalName, choice.Property,
		choice.Choice.Value, state.Lcid, state.OrgId),
										"value" => choice.Choice.Value,
										_ => throw new NotSupportedException($"Choice property '{property}' is not supported.")
										};

								default:
									throw new NotSupportedException($"Value type '{baseValue.GetType().Name}' is not supported.");
							}
						}

						if (Value.StartsWith("#"))
						{
							var property = Value.Trim('#');

							var reference = baseValue as EntityReference;
							var entity = baseValue as Entity ?? (reference is null ? null : new Entity(reference.LogicalName, reference.Id));

							if (entity is null)
							{
								throw new NotSupportedException($"Value type '{baseValue.GetType().Name}' is not supported.");
							}
							
							var related = entity
										.RelatedEntities
										.Where(r => r.Key.SchemaName == property && r.Value != null)
										.SelectMany(r => r.Value?.Entities).ToArray();

									related =
										related.Any()
											? related
											: [..CrmHelpers.GetRelatedRecords(state.Service, entity.ToEntityReference(), property, null, state.OrgId)];

									if (related.Any())
									{
										entity.RelatedEntities[new Relationship(property)] = new EntityCollection(related);
									}

									return related;
							}

								throw new NotSupportedException($"Value type '{baseValue.GetType().Name}' is not supported.");
					}
					}
				}

			protected override void InnerBuild(Stack<Expression> parentDoneExpressions, Stack<Expression> pendingExpressions)
			{ }
		}

		#endregion

		#region Functions
		
		[Expression]
		[DefaultExpression]
		public class FunctionExpression : Expression
		{
			protected override char[] DelimiterChars => new[] { '$' };
			protected override string FinalForm => "^[$][a-zA-Z0-9_]+$";
			protected override string RecognisePattern => "^[$][a-zA-Z0-9_]*$";

			protected CollectionExpression ParametersExpression;
			protected IReadOnlyList<object> Parameters;

			protected RegexDefinition RegexParam;

			protected GlobalState globalState;

			private readonly FunctionLogic[] methods;

			public FunctionExpression(ParserContext context) : base(context)
			{
				methods = GetType()
					.GetMethods(BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.InvokeMethod)
					.Select(
						m =>
						{
							var attribute = m.GetCustomAttribute<FunctionLogicAttribute>();
							return attribute == null
								? null
								: new FunctionLogic(attribute.Name, attribute.IsEvalParams, m);
						}).FilterNull()
					.ToArray();
			}
			
			protected override object InnerEvaluate(GlobalState state, object baseValue = null)
			{
				globalState = state;
				
				var paramScope = ChildExpressions.FirstOrDefault();

				ParametersExpression = new CollectionExpression(Context);

				if (paramScope != null)
				{
					ParametersExpression.ChildExpressions.AddRange(ExtractRegex(state, baseValue, paramScope));
				}

				return FunctionEvaluate(baseValue);
			}

			private IReadOnlyList<Expression> ExtractRegex(GlobalState state, object baseValue, Expression paramScope)
			{
				var paramExpressions = paramScope.ChildExpressions;
				var regexParent = paramScope.ChildExpressions.FirstOrDefault(c => c.ChildExpressions.OfType<RegexExpression>().FirstOrDefault() != null);
				var regexExpression = regexParent?.ChildExpressions.FirstOrDefault();
				RegexParam = regexExpression?.HandledEvaluate(state, baseValue) as RegexDefinition;
				
				return paramExpressions.Except([regexParent]).ToArray();
			}

			protected IReadOnlyList<object> EvaluateParameters(object baseValue)
			{
				return ParametersExpression.HandledEvaluate(globalState, baseValue) as object[];
			}

			protected virtual object FunctionEvaluate(object baseValue = null)
			{
				var method = methods.FirstOrDefault(m => m.Name == Value);

				if (method == null)
				{
					throw new InvalidOperationException($"Unknown function: {Value}.");
				}
				
				if (method.IsEvalParams)
				{
					Parameters = ParametersExpression.HandledEvaluate(globalState, baseValue) as object[];
				}
					
				return method.Method.Invoke(this, [baseValue]);
			}

			protected T GetParam<T>(string paramName, int index, bool isRequired = false)
			{
				Parameters.Require(nameof(Parameters), "Parameters must be evaluated first.");
				
				if (index > Parameters.Count - 1)
				{
					if (isRequired)
					{
					throw new ArgumentNullException(paramName, $"Parameter '{paramName}' is missing or misformatted.");
					}
					
					return default;
				}

				var param = GetTypeAs<T>(Parameters[index]);
				
				if (param == null && isRequired)
				{
					throw new ArgumentNullException(paramName, $"Parameter '{paramName}' is missing or misformatted.");
				}

				return param;
			}
			
			protected static object ValidateValueType<T>(object value)
			{
				return value is T ? value : ThrowValueTypeError<T>();
			}

			protected static T ThrowValueTypeError<T>()
			{
throw new FormatException($"Provided value is not a {typeof(T).Name}.");
			}

			protected static T GetTypeAs<T>(object value)
			{
				if (value is null)
				{
					return default;
				}

				if (value is T paramT)
				{
					return paramT;
				}
				
				if (typeof(T) == typeof(string))
				{
					if (value is double or int or bool)
					{
						return CastTypeAs<T>(value.ToString());
					}
					
					if (value is DateTime dateTime)
					{
						return CastTypeAs<T>(dateTime.ToString("O"));
					}
				}

				if (typeof(T) == typeof(DateTime))
				{
					if (value is string stringfied && DateTime.TryParse(stringfied, out var parsed))
					{
						return CastTypeAs<T>(parsed);
					}

					return CastTypeAs<T>(value);
				}

				Type underlyingType = null;

				if (typeof(T).IsGenericType && typeof(T).GetGenericTypeDefinition() == typeof(Nullable<>))
				{
					underlyingType = Nullable.GetUnderlyingType(typeof(T));
				}

				if (typeof(double).In(new[] { typeof(T), underlyingType }))
				{
					if ((value is string stringfied || (stringfied = value.ToString()).Length >= 0) && double.TryParse(stringfied, out var parsed))
					{
						return CastTypeAs<T>(parsed);
					}

					if (value is double doubleValue)
					{
						return ((double?)doubleValue) is T tDouble ? tDouble : default;
					}
				}

				if (typeof(int).In(new[] { typeof(T), underlyingType }))
				{
					if ((value is string stringfied || (stringfied = value.ToString()).Length >= 0) && int.TryParse(stringfied, out var parsed))
					{
						return CastTypeAs<T>(parsed);
					}

					if (value is int intValue)
					{
						return ((int?)intValue) is T tInt ? tInt : default;
					}
				}

				if (typeof(bool).In(new[] { typeof(T), underlyingType }))
				{
					if ((value is string stringfied || (stringfied = value.ToString()).Length >= 0) && bool.TryParse(stringfied, out var parsed))
					{
						return CastTypeAs<T>(parsed);
					}

					if (value is bool boolValue)
					{
						return ((bool?)boolValue) is T tBool ? tBool : default;
					}
				}

				return ThrowValueTypeError<T>();
			}

			protected static T CastTypeAs<T>(object value)
			{
				return value is T valT ? valT : default;
			}

			protected static object ApplyOperation<T>(object baseValue, Func<T, object> op)
			{
				return baseValue == null ? null : op(GetTypeAs<T>(baseValue));
			}

			protected static object ApplyToCaptures(RegexDefinition regex, string str, Func<Capture, object> op)
			{
				if (regex == null)
				{
					throw new FormatException("Regex is empty.");
				}

				var matches = Regex.Matches(str, regex.Regex).Cast<Match>()
					.Select(match => match.Groups.Count > 1
						? match.Groups.Cast<Group>().Skip(1).Select(e => e.Captures.Cast<Capture>().Select(op).ToArray()).ToArray()
						: op(match.Groups[0])).ToArray();
				
				if (regex.IsFlat)
				{
					matches = Flatten(matches, regex.Levels);
				}
				
				return matches;
			}

			protected static object[] Flatten(IReadOnlyList<object> array, int levels)
			{
				while (levels-- > 0 && array.All(e => e is Array))
				{
						array =
							array.Cast<IEnumerable<object>>().SelectMany(e => e).ToArray();
				}
				
				return [.. array];
			}

			protected static object ReplaceCaptures(string regex, string str, Func<string, string> op)
			{
				if (regex.IsEmpty())
				{
					throw new FormatException("Regex is empty.");
				}

				return str.ReplaceGroups(regex, op);
			}

			[FunctionLogic("rand")]
			private object RandEvaluate(object baseValue)
			{
				var length = GetParam<int>("Length", 0, true);

				const string error = "'pool' parameter in $rand is missing or misformatted.";
				
				if (Parameters.Count < 2)
				{
					throw new FormatException(error);
				}

				string[] customPool = null;
				RandomGenerator.SymbolFlag[] flags;

				switch (Parameters[1])
				{
					case string pool when pool.IsFilled():
					{
						const string flagIndexer = "culn";
						flags = pool.Select(flag => (RandomGenerator.SymbolFlag)flagIndexer.IndexOf(flag))
							.ToArray();
						break;
					}
					
					case object[] poolArray:
					{
						customPool = poolArray.Select(e => e.ToString()).ToArray();

						if (!customPool.Any())
						{
							throw new FormatException(error);
						}

						flags = [RandomGenerator.SymbolFlag.Custom];
						
						break;
					}
					
					default:
						throw new FormatException(error);
				}
				

				if (customPool.IsEmpty() && flags.IsEmpty())
				{
					throw new FormatException("'pool' parameter in $rand is missing or misformatted.");
				}

				var isLetterStart = GetParam<bool?>("Letter Start", 2).GetValueOrDefault();
				var numberLetterRatio = GetParam<int?>("Number-Letter Ratio", 3).GetValueOrDefault(-1);

				return flags.Contains(RandomGenerator.SymbolFlag.Custom)
					? RandomGenerator.GetRandomString(length, isLetterStart, numberLetterRatio, customPool)
					: RandomGenerator.GetRandomString(length, isLetterStart, numberLetterRatio, flags.ToArray());
			}

			[FunctionLogic("debug")]
			private object DebugEvaluate(object baseValue)
			{
				globalState.IsDebug = !globalState.IsDebug;
				return baseValue;
			}

			[FunctionLogic("mem")]
			private object MemoryOnlyEvaluate(object baseValue)
			{
				return baseValue;
			}

			#region CRM
			
			[FunctionLogic("retrieve")]
			private object RetrieveEvaluate(object baseValue)
			{
				var service = globalState.Service;
				service.Require(nameof(service), "Unable to call CRM: service is missing.");

				var attributes = GetParam<object[]>("Attributes", 2)?.OfType<string>().ToArray();
				
				return
				service.Retrieve(GetParam<string>("Logical Name", 0, true),
					Guid.TryParse(GetParam<string>("ID", 1, true), out var id)
						? id
						: throw new FormatException("ID is missing or misformatted."),
					attributes == null ? new ColumnSet(true) : new ColumnSet(attributes));
			}

			[FunctionLogic("retrbyattr")]
			private object RetrieveByAttributeEvaluate(object baseValue)
			{
				var service = globalState.Service;
				service.Require(nameof(service), "Unable to call CRM: service is missing.");

				var attributes = GetParam<object[]>("Attributes", 2)?.OfType<string>().ToArray();
				
				var query = 
					new QueryByAttribute(GetParam<string>("Logical Name", 0, true))
					{
						ColumnSet = attributes == null ? new ColumnSet(true) : new ColumnSet(attributes)
					};

				foreach (var pair in SerialiserHelpers.DeserialiseSimpleJson(GetParam<string>("Attribute Values", 1, true)))
				{
					query.AddAttributeValue(pair.Key, pair.Value);
				}
				
				return service.RetrieveMultiple(query).Entities.ToArray();
			}

			[FunctionLogic("fetch")]
			private object FetchEvaluate(object baseValue)
			{
				var service = globalState.Service;
				service.Require(nameof(service), "Unable to call CRM: service is missing.");

				return CrmHelpers.RetrieveRecords(service, GetParam<string>("FetchXML", 0, true)).ToArray();
			}

			[FunctionLogic("action")]
			private object ActionEvaluate(object baseValue)
			{
				var service = globalState.Service;
				service.Require(nameof(service), "Unable to call CRM: service is missing.");

				var action = new OrganizationRequest(GetParam<string>("Action Name", 0, true));

				var paramsString = GetParam<string>("Parameters", 1);

				if (paramsString.IsFilled())
				{
					foreach (var pair in SerialiserHelpers.DeserialiseSimpleJson(paramsString))
					{
						action[pair.Key] = pair.Value;
					}
				}

				var targetName = GetParam<string>("Target Name", 2);
				var isTargetId = Guid.TryParse(GetParam<string>("Target ID", 3), out var targetId);
				
				if (targetName.IsFilled() && isTargetId)
				{
					action["Target"] = new EntityReference(targetName, targetId);
				}
				
				return service.Execute(action).Results.ToArray();
			}
			
			#endregion

			[FunctionLogic("loc")]
			private object LocaliseEvaluate(object baseValue)
			{
				globalState.Lcid = GetParam<int>("LCID", 0, true);
				return baseValue;
			}

			#region Date
			
			[FunctionLogic("now")]
			private object NowEvaluate(object baseValue)
			{
				return DateTime.Now;
			}

			[FunctionLogic("utcnow")]
			private object UtcNowEvaluate(object baseValue)
			{
				return DateTime.UtcNow;
			}

			[FunctionLogic("utc")]
			private object ToUtcEvaluate(object baseValue)
			{
				return ApplyOperation<DateTime>(baseValue,
					date => date.ToUniversalTime());
			}

			[FunctionLogic("local")]
			private object ToLocalEvaluate(object baseValue)
			{
				return ApplyOperation<DateTime>(baseValue,
					date => date.ToLocalTime());
			}

			[FunctionLogic("offset")]
			private object OffsetEvaluate(object baseValue)
			{
				return ApplyOperation<DateTime>(baseValue,
					date =>
					{
						var timeZone = GetParam<string>("Time Zone", 0, true);

						if (timeZone.IsFilled())
						{
							return TimeZoneInfo.ConvertTimeFromUtc(date,
								TimeZoneInfo.FindSystemTimeZoneById(timeZone));
						}
					
						throw new ArgumentException("Time Zone", $"Time zone is missing or misformatted.");
					});
			}

			[FunctionLogic("exact")]
			private object ExactEvaluate(object baseValue)
			{
				return ApplyOperation<string>(baseValue,
					str => DateTime
						.TryParseExact(str, GetParam<string>("Format", 0, true),
							CultureInfo.InvariantCulture, DateTimeStyles.None, out var date)
						? date
						: throw new FormatException($"Date value is not of the given format."));
			}

			[FunctionLogic("date")]
			private object DateEvaluate(object baseValue)
			{
				return ApplyOperation<DateTime>(baseValue,
					date => date.ToString(GetParam<string>("Format", 0, true)));
			}
			
			#endregion
			
			#region String

			[FunctionLogic("length")]
			private object LengthEvaluate(object baseValue)
			{
				return ApplyOperation<string>(baseValue,
					str =>
					{
						if (str.IsEmpty())
						{
							return 0;
						}

													 return RegexParam == null ? str.Length : ApplyToCaptures(RegexParam, str, c => c.Length);
												 });
			}

			[FunctionLogic("index")]
			private object IndexEvaluate(object baseValue)
			{
				return ApplyOperation<string>(baseValue,
					str =>
					{
						if (str.IsEmpty())
						{
							return 0;
						}

						return RegexParam == null
							? str.IndexOf(GetParam<string>("String", 0, true), StringComparison.InvariantCultureIgnoreCase)
							: ApplyToCaptures(RegexParam, str, c => c.Index + 1);
					});
			}

			[FunctionLogic("sub")]
			private object SubStringEvaluate(object baseValue)
			{
				return ApplyOperation<string>(baseValue,
					str =>
					{
						if (str.IsEmpty())
						{
							return null;
						}

						var start = GetParam<int?>("Start Index", 0, true).GetValueOrDefault();
						start = start < 0 ? 0 : start;

						if (start > str.Length - 1)
						{
							return null;
						}

						var length = GetParam<int?>("Length", 1) ?? str.Length;
						length = length > str.Length - start ? str.Length - start : length;

						return str.Substring(start, length);
					});
			}

			[FunctionLogic("trim")]
			private object TrimEvaluate(object baseValue)
			{
				return ApplyOperation<string>(baseValue,
					str =>
					{
						if (str.IsEmpty())
						{
							return null;
						}

						var trimStr = GetParam<string>("Trim String", 0, true);
						var isStartOnly = GetParam<bool?>("Trim Start Only", 1).GetValueOrDefault();
						var isEndOnly = GetParam<bool?>("Trim End Only", 2).GetValueOrDefault();

						return RegexParam == null ? Trim(str) : str.ReplaceGroups(RegexParam.Regex, Trim);

						string Trim(string strLocal)
						{
							if (!isEndOnly && strLocal.StartsWith(trimStr))
							{
								strLocal = strLocal.Remove(0, trimStr.Length);
							}

							if (!isStartOnly && strLocal.EndsWith(trimStr))
							{
								strLocal = strLocal.Remove(strLocal.Length - trimStr.Length, trimStr.Length);
							}
							
							return strLocal;
						}
					});
			}

			[FunctionLogic("pad")]
			private object PadEvaluate(object baseValue)
			{
				return ApplyOperation<string>(baseValue,
					str =>
					{
						if (str.IsEmpty())
						{
							return null;
						}

						var paddingString = GetParam<string>("Padding Character", 0, true);
						var length = GetParam<int?>("Total Length", 1).GetValueOrDefault(1);
						var isRightSide = GetParam<bool?>("Right Side Only", 2).GetValueOrDefault();

						paddingString.RequireFormat(@"^.$", "Character", "Padding character is missing or misformatted.");

						var paddingChar = paddingString?.FirstOrDefault() ?? ' ';
						
						return RegexParam == null ? Pad(str) : str.ReplaceGroups(RegexParam.Regex, Pad);

						string Pad(string strLocal)
						{
							return isRightSide ? strLocal.PadRight(length, paddingChar) : strLocal.PadLeft(length, paddingChar);
						}
					});
			}

			[FunctionLogic("trunc")]
			private object TruncateEvaluate(object baseValue)
			{
				return ApplyOperation<string>(baseValue,
					str =>
					{
						if (str.IsEmpty())
						{
							return null;
						}

						var maxLength = GetParam<int?>("Max Length", 0, true).GetValueOrDefault(int.MaxValue);
						var replacement = GetParam<string>("Truncate Fill String", 1);

						return RegexParam == null ? Trunc(str) : str.ReplaceGroups(RegexParam.Regex, Trunc);

						string Trunc(string strLocal)
						{
							var skip = Math.Max(strLocal.Length - maxLength, 0);
							var take = Math.Max(strLocal.Length - skip, 1);

							return $"{(skip > 0 ? replacement : "")}{strLocal.Skip(skip).Take(take - 1).StringAggregate("")}";
						}
					});
			}

			[FunctionLogic("upper")]
			private object UpperEvaluate(object baseValue)
			{
				return ApplyOperation<string>(baseValue,
					str =>
					{
						if (str.IsEmpty())
						{
							return null;
						}

						return RegexParam == null ? Upper(str) : str.ReplaceGroups(RegexParam.Regex, Upper);

						string Upper(string strLocal)
						{
							return strLocal.ToUpper();
						}
					});
			}

			[FunctionLogic("lower")]
			private object LowerEvaluate(object baseValue)
			{
				return ApplyOperation<string>(baseValue,
					str =>
					{
						if (str.IsEmpty())
						{
							return null;
						}

						return RegexParam == null ? Lower(str) : str.ReplaceGroups(RegexParam.Regex, Lower);

						string Lower(string strLocal)
						{
							return strLocal.ToLower();
						}
					});
			}

			[FunctionLogic("sentence")]
			private object SentenceEvaluate(object baseValue)
			{
				return ApplyOperation<string>(baseValue,
					str =>
					{
						if (str.IsEmpty())
						{
							return null;
						}

						return RegexParam == null ? Sentence(str) : str.ReplaceGroups(RegexParam.Regex, Sentence);

						string Sentence(string strLocal)
						{
							return strLocal.ToSentenceCase();
						}
					});
			}

			[FunctionLogic("title")]
			private object TitleEvaluate(object baseValue)
			{
				return ApplyOperation<string>(baseValue,
					str =>
					{
						if (str.IsEmpty())
						{
							return null;
						}

						return RegexParam == null ? Title(str) : str.ReplaceGroups(RegexParam.Regex, Title);

						string Title(string strLocal)
						{
							return strLocal.ToTitleCase();
						}
					});
			}

			[FunctionLogic("extract")]
			private object ExtractEvaluate(object baseValue)
			{
				return ApplyOperation<string>(baseValue,
					str =>
					{
						if (str.IsEmpty())
						{
							return null;
						}

						if (RegexParam == null)
						{
							return str;
						}
						
						var result = Regex.Matches(str, RegexParam.Regex).Cast<Match>()
							.Select(m => m.Groups.Count > 1
								? m.Groups.Cast<Group>().Skip(1).Select(g => g.ExtractCaptures().ToArray()).ToArray()
								: (object)m.Groups[0].Value).ToArray();
						
						if (RegexParam.IsFlat)
						{
							result = Flatten(result, RegexParam.Levels);
						}

						return result;
					});
			}

			[FunctionLogic("split")]
			private object SplitEvaluate(object baseValue)
			{
				return ApplyOperation<string>(baseValue,
					str =>
					{
						if (str.IsEmpty())
						{
							return null;
						}

						var captures = 
							RegexParam == null
							? null
							: Regex.Matches(str, RegexParam.Regex).Cast<Match>()
								.SelectMany(m => m.Groups.Count > 1
									? m.Groups.Cast<Group>().Skip(1).Select(c => (c.Index, c.Length))
									: new[] { (m.Groups[0].Index, m.Groups[0].Length) }).ToArray();
						
						var splitStrings = new List<string>();

						if (captures?.Any() == true)
						{
							var builder = new StringBuilder();

							var captureQueue = new Queue<(int, int)>(captures);
							var (currentIndex, currentLength) = captureQueue.Dequeue();
							
							for (var i = 0; i < str.Length; i++)
							{
								if (i > currentIndex && i < currentIndex + currentLength - 1)
								{
									continue;
								}

								if (i == currentIndex + currentLength - 1)
								{
									if (captureQueue.Any())
									{
										(currentIndex, currentLength) = captureQueue.Dequeue();
									}
									
									continue;
								}
								
								if (currentIndex == i)
								{
									splitStrings.Add(builder.ToString());
									builder.Clear();
									continue;
								}

								builder.Append(str[i]);
							}

							if (builder.Length > 0)
							{
								splitStrings.Add(builder.ToString());
								builder.Clear();
							}
							
							return splitStrings.ToArray();
						}

						return captures == null
							? str.Split(new[] { GetParam<string>("Separator", 0, true) }, StringSplitOptions.None)
							: [str];
					});
			}

			[FunctionLogic("replace")]
			private object ReplaceEvaluate(object baseValue)
			{
				return ApplyOperation<string>(baseValue,
					str =>
					{
						if (str.IsEmpty())
						{
							return null;
						}

						var replacement = GetParam<string>("Replacement", 0, true);
						
						return RegexParam == null ? Replace(str) : str.ReplaceGroups(RegexParam.Regex, Replace);

						string Replace(string strLocal)
						{
							return replacement;
						}
					});
			}

			[FunctionLogic("enchtml")]
			private object EncodeHtmlEvaluate(object baseValue)
			{
				return ApplyOperation<string>(baseValue,
					str =>
					{
						if (str.IsEmpty())
						{
							return null;
						}

						return RegexParam == null ? Encode(str) : str.ReplaceGroups(RegexParam.Regex, Encode);

						string Encode(string strLocal)
						{
							return WebUtility.HtmlEncode(strLocal);
						}
					});
			}

			[FunctionLogic("dechtml")]
			private object DecodeHtmlEvaluate(object baseValue)
			{
				return ApplyOperation<string>(baseValue,
					str =>
					{
						if (str.IsEmpty())
						{
							return null;
						}

						return RegexParam == null ? Decode(str) : str.ReplaceGroups(RegexParam.Regex, Decode);

						string Decode(string strLocal)
						{
							return WebUtility.HtmlDecode(strLocal);
						}
					});
			}

			[FunctionLogic("num")]
			private object FormatNumberEvaluate(object baseValue)
			{
				return ApplyOperation<string>(baseValue,
					str =>
					{
						if (str.IsEmpty())
						{
							return null;
						}

						var format = GetParam<string>("Format", 0, true);
						
						return RegexParam == null ? Format(str) : str.ReplaceGroups(RegexParam.Regex, Format);

						string Format(string strLocal)
						{
							return double.TryParse(strLocal, out var doubleVal) ? doubleVal.ToString(format) : strLocal;
						}
					});
			}
			
			#endregion
			
			#region Collection

			[FunctionLogic("map", isEvalParams: false)]
			private object MapEvaluate(object baseValue)
			{
				if (baseValue is null)
				{
					return null;
				}

				return GetTypeAs<IEnumerable>(baseValue)
					.OfType<object>()
					.Select(e => (ParametersExpression.HandledEvaluate(globalState, e) as object[])?.FirstOrDefault())
					.ToArray();
			}

			[FunctionLogic("for", isEvalParams: false)]
			private object ForEvaluate(object baseValue)
			{
				throw new NotImplementedException();
			}

			[FunctionLogic("get")]
			private object GetEvaluate(object baseValue)
			{
				if (baseValue is not IEnumerable collection)
				{
					return null;
				}
				
				var array = collection.Cast<object>().ToArray();

				var start = Math.Max(1,
					(GetParam<object>("Start", 0) is double intParam ? (int?)intParam : null)
						?? (GetParam<object>("Start", 0) as string == "n" ? array.Length : 1));
				var isEnd = GetParam<object>("End", 1) as string == "n";
				var endInt = isEnd ? array.Length : Math.Min(GetParam<int?>("End", 1) ?? start, array.Length);

				var result = array.Skip(start - 1).Take((isEnd ? array.Length : endInt) - start + 1).ToArray();
				return result.Length <= 1 ? result.FirstOrDefault() : result;
			}

			#endregion

			#region Aggregate
			
			[FunctionLogic("count")]
			private object CountEvaluate(object baseValue)
			{
				if (baseValue is null)
				{
					return null;
				}
				
				return baseValue is IEnumerable collection ? collection.OfType<object>().Count() : 1;
			}

			[FunctionLogic("distinct", isEvalParams: false)]
			private object DistinctEvaluate(object baseValue)
			{
				if (baseValue is null)
				{
					return null;
				}

				return 
				GetTypeAs<IEnumerable>(baseValue)
					.OfType<object>()
					.Select(
						e => new CollectionOpResult(
							Flatten([(ParametersExpression.HandledEvaluate(globalState, e) as object[])?.FirstOrDefault()], int.MaxValue)
								.StringAggregate("")
								?? e, e))
					.Distinct()
					.Select(e => e.Element)
					.ToArray();
			}

			[FunctionLogic("order", isEvalParams: false)]
			private object OrderEvaluate(object baseValue)
			{
				if (baseValue is null)
				{
					return null;
				}
// TODO handle descending
				return GetTypeAs<IEnumerable>(baseValue)
					.OfType<object>()
					.Select(
						e => new CollectionOpResult(
							Flatten([(ParametersExpression.HandledEvaluate(globalState, e) as object[])?.FirstOrDefault()], int.MaxValue)
								.StringAggregate("")
								?? e, e))
					.OrderBy(e => e)
					.Select(e => e.Element)
					.ToArray();
			}

			[FunctionLogic("clear")]
			private object ClearEvaluate(object baseValue)
			{
				return null;
			}

			[FunctionLogic("where", isEvalParams: false)]
			private object WhereEvaluate(object baseValue)
			{
				if (baseValue is null)
				{
					return null;
				}

				return GetTypeAs<IEnumerable>(baseValue)
					.OfType<object>()
					.Select(
						e => new CollectionOpResult(
							Flatten([(ParametersExpression.HandledEvaluate(globalState, e) as object[])?.FirstOrDefault()], int.MaxValue)
								.FirstOrDefault()
								?? e, e))
					.Where(e => e.Key as bool? == true)
					.Select(e => e.Element)
					.ToArray();
			}

			[FunctionLogic("filter", isEvalParams: false)]
			private object FilterEvaluate(object baseValue)
			{
				if (baseValue is null)
				{
					return null;
				}

				return GetTypeAs<IEnumerable>(baseValue)
					.OfType<object>()
					.Select(
						e => new CollectionOpResult(
							Flatten([(ParametersExpression.HandledEvaluate(globalState, e) as object[])?.FirstOrDefault()], int.MaxValue)
								.FirstOrDefault()
								?? e, e))
					.Where(e => e.Key as bool? != true)
					.Select(e => e.Element)
					.ToArray();
			}

			[FunctionLogic("join")]
			private object JoinEvaluate(object baseValue)
			{
				if (baseValue is null)
				{
					return null;
				}

				return GetTypeAs<IEnumerable>(baseValue)
					.OfType<object>()
					.StringAggregate(GetParam<string>("Separator", 0, true));
			}

			[FunctionLogic("min")]
			private object MinEvaluate(object baseValue)
			{
				if (baseValue is null)
				{
					return null;
				}

				return GetTypeAs<IEnumerable>(baseValue)
					.OfType<double>()
					.Min();
			}

			[FunctionLogic("max")]
			private object MaxEvaluate(object baseValue)
			{
				if (baseValue is null)
				{
					return null;
				}

				return GetTypeAs<IEnumerable>(baseValue)
					.OfType<double>()
					.Max();
			}

			[FunctionLogic("avg")]
			private object AverageEvaluate(object baseValue)
			{
				if (baseValue is null)
				{
					return null;
				}

				return GetTypeAs<IEnumerable>(baseValue)
					.OfType<double>()
					.Average();
			}

			[FunctionLogic("sum", isEvalParams: false)]
			private object SumEvaluate(object baseValue)
			{
				if (baseValue is null)
				{
					return null;
				}

				return GetTypeAs<IEnumerable>(baseValue)
					.OfType<double>()
					.Sum();
			}

			[FunctionLogic("flat")]
			private object FlattenEvaluate(object baseValue)
			{
				return baseValue is null
					? null
					: Flatten(GetTypeAs<IEnumerable>(baseValue).OfType<object>().ToArray(), GetParam<int>("Levels", 0, true));
			}

			#endregion

			protected override void InnerBuild(Stack<Expression> parentDoneExpressions, Stack<Expression> pendingExpressions)
			{
				if (pendingExpressions.Any() && pendingExpressions.Peek() is InternalScopeExpression)
				{
					var next = pendingExpressions.Pop();
					next.Build(Root, this, parentDoneExpressions, pendingExpressions);
					ChildExpressions.Add(next);
				}
			}
		}

		#endregion

		#region Operators

		[Expression]
		public sealed class NegativeExpression(ParserContext context) : UnaryOperatorExpression(context)
		{
			public override int Precedence => 200;

			protected override string FinalForm => @"^\-$";
			protected override string RecognisePattern => @"^\-$";

			protected override bool PreComplete(char character)
			{
				var latestExpression = Context.Expressions.LastOrDefault();
				// previous exp is not an operand
				return latestExpression is OperatorExpression
					|| (latestExpression is ScopeExpression scope && scope.OpeningBrace == scope.Value);
			}
		}

		[Expression]
		public sealed class SubtractExpression(ParserContext context) : BinaryOperatorExpression(context)
		{
			public override int Precedence => 99;

			protected override string FinalForm => @"^\-$";
			protected override string RecognisePattern => @"^\-$";

			protected override bool PreComplete(char character)
			{
				var latestExpression = Context.Expressions.LastOrDefault();
				// previous exp is an operand
				return latestExpression is not OperatorExpression && (latestExpression is not ScopeExpression scope || scope.OpeningBrace != scope.Value);
			}
		}

		[Expression]
		public class BinaryOperatorExpression(ParserContext context) : OperatorExpression(context)
		{
			protected override string FinalForm => @"^(?:\*|\/|\+|-|>|<|>=|<=|!=|==|&&|\|\||\?\?|\?|:)$";
			protected override string RecognisePattern => @"^(?:\*|\/|\+|-|>|<|>=?|<=?|!=?|==?|&&?|\|\|?|\?\??|\?|:)$";

			protected override object InnerEvaluate(GlobalState state, object baseValue = null)
			{
				var op1Exp = ChildExpressions.FirstOrDefault();
				var op1 = op1Exp?.HandledEvaluate(state, baseValue);
				var op2Exp = ChildExpressions.LastOrDefault();
				var op2 = op2Exp?.HandledEvaluate(state, baseValue);
				
				if (Regex.IsMatch(Value, @"^(?:[+\-*/])$"))
				{
					if (op1 is double op1Double)
					{
						switch (op2)
						{
							case double op2Double:
								return Value switch{
									"+" => (op1Double + op2Double),
									"-" => (op1Double - op2Double),
									"*" => (op1Double * op2Double),
									"/" => (op1Double / op2Double)
									};
							case null:
								return op1;
						}
					}
					else if (op2 is double && op1 is null)
					{
						return op2;
					}
				}
				
				switch (Value)
				{
					case "+":
					case "-":
					{
						var isDate = op1 is DateTime || op2 is DateTime;

						if (isDate)
						{
							var isTimeSpan = op1Exp is TimeSpanExpression || op2Exp is TimeSpanExpression;

							if (isTimeSpan)
							{
								var date = (op1 is DateTime ? op1 as DateTime? : op2 as DateTime?).GetValueOrDefault();
								var timeSpan = op1Exp is TimeSpanExpression ? op1 as string : op2 as string;
								
								if (timeSpan.IsEmpty())
								{
									return date;
								}

								var match = Regex.Match(timeSpan, @"^(?:(\d+?)([yMdhmsf]))+?$");

								var values = match.Groups[1].ExtractCaptures().ToArray();
								var units = match.Groups[2].ExtractCaptures().ToArray();

								for (var i = 0; i < values.Length; i++)
								{
									var amount = (int)double.Parse(values[i]) * (Value == "+" ? 1 : -1);
									var unit = units[i];

									date = unit switch {
										"y" => date.AddYears(amount),
										"M" => date.AddMonths(amount),
										"d" => date.AddDays(amount),
										"h" => date.AddHours(amount),
										"m" => date.AddMinutes(amount),
										"s" => date.AddSeconds(amount),
										"f" => date.AddMilliseconds(amount)
										};
								}

								return date;
							}
						}

						break;
					}
					
							case "||":
								{
									if (op1 is bool t1 && op2 is bool t2)
									{
										return (t1 || t2).ToString();
							}

									break;
								}

							case "&&":
								{
									if (op1 is bool t1 && op2 is bool t2)
									{
										return (t1 && t2).ToString();
							}

									break;
								}

							case "??":
								{
									return op1 ?? op2;
								}

							case "<":
								{
									return ((op1 as IComparable)?.CompareTo(op2 as IComparable) < 0).ToString();
								}

							case ">":
								{
									return ((op1 as IComparable)?.CompareTo(op2 as IComparable) > 0).ToString();
								}

							case ">=":
								{
									return ((op1 as IComparable)?.CompareTo(op2 as IComparable) >= 0).ToString();
								}

							case "<=":
								{
									return ((op1 as IComparable)?.CompareTo(op2 as IComparable) <= 0).ToString();
								}

							case "==":
								{
									return (op1 == null && op2 == null) || op1?.Equals(op2) == true || op2?.Equals(op1) == true;
								}

							case "!=":
								{
									return !((op1 == null && op2 == null) || op1?.Equals(op2) == true || op2?.Equals(op1) == true);
								}
				}

				if (Value == "+")
				{
					return Helpers.GetStringRepresentation(op1) + Helpers.GetStringRepresentation(op2);
				}

				throw new InvalidOperationException("Operands unsupported for given operator.");
			}

			protected override void InnerBuild(Stack<Expression> parentDoneExpressions, Stack<Expression> pendingExpressions)
			{
				if (parentDoneExpressions.Any() && pendingExpressions.Any())
				{
					var left = parentDoneExpressions.Pop();
					left.Parent = this;
					
					var right = pendingExpressions.Pop();
					right.Parent = this;

					ChildExpressions.Add(left);
					ChildExpressions.Add(right);
				}
			}
		}
		
		[Expression]
		public class UnaryOperatorExpression(ParserContext context) : OperatorExpression(context)
		{
			protected override string FinalForm => "^!$";
			protected override string RecognisePattern => "^!$";

			protected override object InnerEvaluate(GlobalState state, object baseValue = null)
			{
				var op1Exp = ChildExpressions.FirstOrDefault();
				var op = op1Exp?.HandledEvaluate(state, baseValue);
				
				switch (Value)
				{
					case "!":
						if (op is bool boolVal)
						{
							return !boolVal;
						}
						
						break;

					case "-":
						if (op is double doubleVal)
						{
							return -doubleVal;
						}

						break;
				}

				throw new InvalidOperationException("Operands unsupported for given operator.");
			}

			protected override void InnerBuild(Stack<Expression> parentDoneExpressions, Stack<Expression> pendingExpressions)
			{
				if (pendingExpressions.Any() && pendingExpressions.Peek() is not OperatorExpression)
				{
					var op = pendingExpressions.Pop();
					op.Parent = this;
					
					ChildExpressions.Add(op);
				}
			}
		}

		[Expression]
		[AbstractExpression]
		public class OperatorExpression(ParserContext context) : Expression(context)
		{
			public virtual int Precedence => operatorPrecedence.TryGetValue(Value, out var precendence) ? precendence : 0;
			
			protected string OperatorList => @"!*/+\-><=&|?:";
			protected override string FinalForm => $"^[{OperatorList}]+$";
			protected override string RecognisePattern => $"^[{OperatorList}]+$";

			private static readonly Dictionary<string, int> operatorPrecedence =
				new()
				{
					{ "!", 200 },
					{ "*", 100 },
					{ "/", 100 },
					{ "+", 99 },
					{ "-", 99 },
					{ ">", 75 },
					{ "<", 75 },
					{ ">=", 75 },
					{ "<=", 75 },
					{ "!=", 74 },
					{ "==", 74 },
					{ "&&", 65 },
					{ "||", 64 },
					{ "??", 57 },
					{ "?", 50 },
					{ ":", 50 }
				};

			protected override object InnerEvaluate(GlobalState state, object baseValue = null)
			{
				throw new InvalidOperationException($"Operation unsupported.");
			}

			protected override void InnerBuild(Stack<Expression> parentDoneExpressions, Stack<Expression> pendingExpressions)
			{ }
		}

		#endregion

		#region Memory
		
		[Expression]
		public sealed class MemoryExpression(ParserContext context) : Expression(context)
		{
			protected override char[] DelimiterChars => new[] { '~' };
			protected override string FinalForm => "^~[a-zA-Z0-9_]+$";
			protected override string RecognisePattern => "^~[a-zA-Z0-9_]*$";

			protected override object InnerEvaluate(GlobalState state, object baseValue = null)
			{
				return state.Store(Value, baseValue);
			}

			protected override void InnerBuild(Stack<Expression> parentDoneExpressions, Stack<Expression> pendingExpressions)
			{ }
		}

		#endregion
		
		#region Literals

		[Expression]
		public sealed class BooleanExpression(ParserContext context) : LiteralExpression(context)
		{
			protected override string FinalForm => "(?i)^(?:true|false)$";
			protected override string RecognisePattern => "^(?:t(?:r(?:u(?:e)?)?)?|f(?:a(?:l(?:s(?:e)?)?)?)?)$";

			protected override object InnerEvaluate(GlobalState state, object baseValue = null)
			{
				return
					Value == null
						? null
						: (bool.TryParse(Value, out var boolParse)
							? boolParse
							: throw new FormatException("Value is not boolean."));
			}

		}

		[Expression]
		public sealed class NullExpression(ParserContext context) : LiteralExpression(context)
		{
			protected override string FinalForm => "(?i)^null$";
			protected override string RecognisePattern => "^n(?:u(?:l(?:l)?)?)?$";

			protected override object InnerEvaluate(GlobalState state, object baseValue = null)
			{
				return null;
			}

		}

		[Expression]
		public sealed class NumberExpression(ParserContext context) : LiteralExpression(context)
		{
			protected override object InnerEvaluate(GlobalState state, object baseValue = null)
			{
				return
					Value == null
						? null
						: (double.TryParse(Value, out var doubleParse)
							// ReSharper disable once CompareOfFloatsByEqualityOperator
							? ((int)doubleParse == doubleParse
								? (int)doubleParse
								: doubleParse)
							: throw new FormatException("Value is not a number."));
			}

			protected override bool IsRecognisable(char character) =>
				character != ',' && double.TryParse(Buffer + character, out _);
		}

		[Expression]
		public sealed class TimeSpanExpression(ParserContext context) : TextExpression(context)
		{
			protected override string FinalForm => @"^`(?:\d+?[yMdhmsf])+?`$";
			protected override string RecognisePattern => @"^`(?:\d+?[yMdhmsf]?)*`?$";

			protected override bool Preprocess(char character)
			{
				if (Context.CodeScopeCount <= 0)
				{
					return false;
				}
					
				if (character == '`')
				{
					Context.IsMultiEscape = !IsTokenValued;
				}

				return true;
			}
		}

		[Expression]
		public sealed class RegexExpression(ParserContext context) : TextExpression(context)
		{
			protected override string FinalForm => @"^`/[^/`]+/(?:f\d)?`$";
			protected override string RecognisePattern => @"^`(?:/(?:[^/`]+(?:/(?:f?(?:\d)?(?:`)?)?)?)?)?$";
			
			protected override object InnerEvaluate(GlobalState state, object baseValue = null)
			{
				return new RegexDefinition(Regex.Match(Value, @"^/(.*)/.*?$").Groups[1].Value,
					Regex.IsMatch(Value, @"^/.*/.*?f\d?.*?$"),
					int.TryParse(Regex.Match(Value, @"^/.*/.*?f(\d).*?$").Groups[1].Value, out var levels) ? levels : 2);
			}

			protected override bool Preprocess(char character)
			{
				if (Context.CodeScopeCount <= 0)
				{
					return false;
				}
					
				if (character == '`')
				{
					Context.IsMultiEscape = !IsTokenValued;
				}

				return true;
			}
		}

		[Expression]
		public class TextExpression(ParserContext context) : LiteralExpression(context)
		{
			protected override char[] DelimiterChars => new[] { '`' };

			private bool isForceConsume;
			
			protected override bool Preprocess(char character)
			{
					isForceConsume = false;
					
				switch (character)
				{
					case '`':
						Context.IsMultiEscape = !IsTokenValued;
						break;
					
					case '\\' when !Context.IsMultiEscape:
					{
						if (!Context.IsSingleEscape)
						{
							Context.IsSingleEscape = true;
							isForceConsume = true;
							return true;
						}
						
						break;
					}
				}

				if (Context.IsSingleEscape)
				{
					Context.IsSingleEscape = false;
					isForceConsume = true;
				}
else if (Context.CodeScopeCount <= 0)
				{
					isForceConsume = true;
				}

				return true;
			}

			protected override bool IsRecognisable(char character) =>
				Regex.IsMatch(Buffer + character, "^`[^`]*`?$") || isForceConsume;
		}

		public abstract class LiteralExpression(ParserContext context) : Expression(context)
		{
			protected override object InnerEvaluate(GlobalState state, object baseValue = null)
			{
				return Value;
			}

			protected override void InnerBuild(Stack<Expression> parentDoneExpressions, Stack<Expression> pendingExpressions)
			{ }

			public override string ToString()
			{
				return Value;
			}
		}

		#endregion
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static partial class CrmHelpers
	{
		public static string[] NonUpdatableFields =
			{
				"createdby",
				"createdon",
				"createdonbehalfby",
				"importsequencenumber",
				"modifiedby",
				"modifiedon",
				"modifiedonbehalfby",
				"owningbusinessunit",
				"owningteam",
				"owninguser",
				"timezoneruleversionnumber",
				"utcconversiontimezonecode",
				"versionumber",
			};

		/// <summary>
		///     Retrieves the generic configuration record from CRM. All fields are returned.<br />
		///     If none is found, an empty entity record is returned.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="service">CRM Organisation Service</param>
		/// <param name="orgId">CRM Organisation ID to make caching unique</param>
		public static Entity GetGenericConfig(IOrganizationService service, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.CrmHelpers.GetGenericConfig";
			var configLocal = CacheHelpers.GetFromMemCache<Entity>(cacheKey, orgId: orgId);

			if (service != null && configLocal == null)
			{
				var isExist = CacheHelpers.GetFromMemCacheAdd("Yagasoft.Common.GetGenericConfig|IsExist",
					() => MetadataHelpers.IsEntityExist(service, "ys_genericconfiguration", orgId, true), DateTime.Now.AddYears(1), orgId: orgId);

				if (isExist)
				{
					configLocal =
						(from configQ in new OrganizationServiceContext(service).CreateQuery("ys_genericconfiguration")
						 where (int)configQ["statecode"] == 0
						 select configQ).FirstOrDefault();
					CacheHelpers.AddToMemCache(cacheKey, configLocal,
						DateTime.Now.AddMinutes(configLocal?.GetAttributeValue<int>("ys_configurationcacheduration") ?? 0), orgId: orgId);
				}
			}

			return configLocal
				?? new Entity("ys_genericconfiguration")
				{
					["ys_name"] = "Generic Config"
				};
		}

		internal static DateTime GetMetadataCacheExpiryDate(IOrganizationService service, Guid? orgId = null)
		{
			return DateTime.Now.AddMinutes(GetGenericConfig(service, orgId)?
				.GetAttributeValue<int>("ys_metadatacacheduration") ?? 0);
		}

		/// <summary>
		///     Get the value of the primary name field of the record.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetRecordName(IOrganizationService service, Entity record, bool isRetrieveEmpty = true, string primaryNameField = null,
			Guid? orgId = null)
		{
			if (primaryNameField.IsEmpty())
			{
				primaryNameField = MetadataHelpers
					.GetEntityAttribute<string>(service, record.LogicalName, MetadataHelpers.EntityAttribute.PrimaryNameAttribute, orgId);
			}

			var name = record.GetAttributeValue<string>(primaryNameField);

			return (name.IsEmpty() && isRetrieveEmpty)
				? GetRecordName(service, record.LogicalName, record.Id, primaryNameField, orgId)
				: name;
		}

		/// <summary>
		///     Get the value of the primary name field of the record.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetRecordName(IOrganizationService service, string logicalName, Guid id, string primaryNameField = null,
			Guid? orgId = null)
		{
			if (primaryNameField.IsEmpty())
			{
				primaryNameField = MetadataHelpers
					.GetEntityAttribute<string>(service, logicalName, MetadataHelpers.EntityAttribute.PrimaryNameAttribute, orgId);
			}

			return service.Retrieve(logicalName, id, new ColumnSet(primaryNameField)).GetAttributeValue<string>(primaryNameField);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsRecordExists(IOrganizationService service, string logicalName, Guid id, bool isActivity = false)
		{
			var query = new QueryByAttribute(logicalName);
			query.AddAttributeValue(isActivity ? "activityid" : logicalName + "id", id);
			query.ColumnSet = new ColumnSet(false);
			return service.RetrieveMultiple(query).Entities.Any();
		}

		/// <summary>
		///     Get the total number of records returned by the given query using a modded binary search algorithm.<br />
		///     It is recommended that the query's column-set is set to 'false' for speed.<br />
		///     Please note that the 'PageInfo' object in the query will be overwritten.<br />
		///     This does NOT work with CRM Online.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static int GetRecordsCount(IOrganizationService service, QueryExpression query, int countPerPage = 5000,
			string cookie = null, int lowerPageLimit = 1, int upperPageLimit = int.MaxValue)
		{
			var minPage = lowerPageLimit;
			var minPageCount = GetCountInPage(service, query, cookie, minPage, countPerPage);

			// first page is already partially filled or empty, so there are no records after for sure
			if (minPageCount >= 0 && minPageCount < countPerPage)
			{
				return minPageCount;
			}

			var maxPage = minPage;
			int maxPageCount;

			// get max page with partial fill or no records, after which there are surely no records
			// jump pages using an exponent of 2 because it's more likely that there are low number of pages than high
			while (true)
			{
				maxPage = maxPage * 2;
				maxPage = Math.Min(maxPage, upperPageLimit);
				maxPageCount = GetCountInPage(service, query, cookie, maxPage, countPerPage);

				// a filled page is considered a minimum, so set it to reduce search range
				if (maxPageCount == countPerPage)
				{
					minPage = maxPage;
					minPageCount = maxPageCount;
				}
				else
				{
					break;
				}
			}

			var isMaxNextToMin = (minPage + 1) == maxPage;
			var isMaxPageEmpty = maxPageCount == 0;
			var isMaxPagePartial = maxPageCount > 0 && maxPageCount < countPerPage;

			// max page is next to min full page, and is empty or partially filled, so we have reached the end
			if (isMaxPagePartial || (isMaxPageEmpty && isMaxNextToMin))
			{
				return ((maxPage - 1) * countPerPage) + maxPageCount;
			}

			int currentPage;
			int currentPageCount;

			while (true)
			{
				// get the current page in the middle point between min and max
				currentPage = (int)Math.Ceiling((maxPage + minPage) / 2d);

				// if current is not min or max, get its count
				if (currentPage != minPage && currentPage != maxPage)
				{
					currentPageCount = GetCountInPage(service, query, cookie, currentPage, countPerPage);
				}
				else
				{
					currentPageCount = currentPage == minPage ? minPageCount : maxPageCount;
				}

				var isCurrentNextToMin = (minPage + 1) == currentPage;
				var isCurrentNextToMax = (maxPage - 1) == currentPage;
				var isCurrentPageEmpty = currentPageCount == 0;
				var isCurrentPagePartial = currentPageCount > 0 && currentPageCount < countPerPage;
				var isCurrentPageFull = currentPageCount == countPerPage;

				// current page is next to min full page or max empty page
				// and is empty or partially filled, so we have reached the end
				if (isCurrentPagePartial
					|| (isCurrentPageEmpty && isCurrentNextToMin) || (isCurrentPageFull && isCurrentNextToMax))
				{
					break;
				}

				if (isCurrentPageEmpty)
				{
					maxPage = currentPage;
				}

				if (isCurrentPageFull)
				{
					minPage = currentPage;
				}
			}

			return ((currentPage - 1) * countPerPage) + currentPageCount;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static int GetCountInPage(IOrganizationService service, QueryExpression query, string cookie = null,
			int page = 1, int countPerPage = 5000)
		{
			query.PageInfo = query.PageInfo ?? new PagingInfo();
			query.PageInfo.Count = countPerPage;
			query.PageInfo.PageNumber = page;
			query.PageInfo.PagingCookie = query.PageInfo.PagingCookie ?? cookie;
			query.ColumnSet = query.ColumnSet ?? new ColumnSet(false);
			var result = service.RetrieveMultiple(query);
			query.PageInfo.PagingCookie = result.PagingCookie ?? cookie;
			return result.Entities.Count;
		}

		/// <summary>
		///     Gets records from CRM using the query given.<br />
		///     Pass '-1' for limit to get all records, and pass '-1' to page to ignore pages.
		///     The cookie is saved in the query itself during retrieval, so either save the cookie somewhere
		///     and reset it before passing it here, or simply reuse the query for next pages.<br />
		///     You should not skip pages with CRM Online.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IReadOnlyList<Entity> RetrieveRecords(IOrganizationService service, QueryExpression query,
			int limit = -1, int page = -1)
		{
			query.PageInfo =
				new PagingInfo
				{
					PageNumber = page <= 0
						? (query.PageInfo == null || query.PageInfo.PageNumber <= 0
							? 1
							: query.PageInfo.PageNumber)
						: page,
					Count = limit <= 0
						? (query.PageInfo == null || query.PageInfo.Count <= 0
							? 5000
							: query.PageInfo.Count)
						: (limit > 5000 ? 5000 : limit)
				};

			limit = limit <= 0 ? int.MaxValue : limit;

			EntityCollection records;
			var entities = new List<Entity>();

			// get all records
			do
			{
				// fetch the records
				records = service.RetrieveMultiple(query);

				// next time get the next bundle of records
				query.PageInfo.PagingCookie = records.PagingCookie;
				query.PageInfo.PageNumber++;

				// add to existing list
				entities.AddRange(records.Entities);
			}
			while (records.MoreRecords && entities.Count < limit && page <= 0);

			return entities;
		}

		/// <summary>
		///     Gets records from CRM using the FetchXML given.<br />
		///     Pass '-1' for limit to get all records, and pass '-1' to page to ignore pages.
		///     You should not skip pages with CRM Online.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IReadOnlyList<Entity> RetrieveRecords(IOrganizationService service, string fetchXml,
			int limit = -1, int page = -1)
		{
			var isAllPages = page <= 0;
			page = page <= 0 ? 1 : page;
			var loopLimit = limit <= 0 ? int.MaxValue : limit;
			var count = limit > 5000 ? 5000 : limit;
			string cookie = null;

			EntityCollection records;
			var entities = new List<Entity>();

			// get all records
			do
			{
				fetchXml = SetFetchPaging(fetchXml, page, count, cookie);

				// fetch the records
				records = service.RetrieveMultiple(new FetchExpression(fetchXml));

				// next time get the next bundle of records
				cookie = records.PagingCookie;
				page++;

				// add to existing list
				entities.AddRange(records.Entities);
			}
			while (records.MoreRecords && entities.Count < loopLimit && isAllPages);

			return entities;
		}

		private static string SetFetchPaging(string fetchXml, int page, int count = -1, string cookie = null)
		{
			var doc = new XmlDocument();
			doc.LoadXml(fetchXml);

			var fetchNode = doc.SelectNodes("//fetch")?.Cast<XmlNode>().FirstOrDefault();

			if (fetchNode == null)
			{
				throw new FormatException("FetchXML is not properly formatted.");
			}

			var tempDoc = fetchNode.OwnerDocument;

			if (tempDoc == null)
			{
				throw new FormatException("Couldn't find owner document in FetchXML node.");
			}

			if (fetchNode.Attributes == null)
			{
				throw new FormatException("Couldn't find attributes collection in FetchXML node.");
			}

			var attribute = tempDoc.CreateAttribute("page");
			attribute.Value = page.ToString();
			fetchNode.Attributes.SetNamedItem(attribute);

			if (count > 0)
			{
				attribute = tempDoc.CreateAttribute("count");
				attribute.Value = count.ToString();
				fetchNode.Attributes.SetNamedItem(attribute);
			}

			if (!string.IsNullOrWhiteSpace(cookie))
			{
				attribute = tempDoc.CreateAttribute("paging-cookie");
				attribute.Value = cookie;
				fetchNode.Attributes.SetNamedItem(attribute);
			}

			return doc.OuterXml;
		}

		/// <summary>
		///     Extracts the entity references from a record URL. Usually the URL is provided as input to a custom activity.<br />
		///     Execution Context can be null, it is used to cache inside a plugin only.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)<br />
		///     Credit: Yousra Mohamed
		/// </summary>
		public static IEnumerable<EntityReference> GetEntityReferencesFromUrls(IOrganizationService service, Guid? orgId = null,
			params string[] dynamicUrlParams)
		{
			// loop over dynamic urls to retrieve entity reference
			return
				from url in dynamicUrlParams
				where (url.Contains("etc=") || url.Contains("etn=")) && url.Contains("id=")
				select url.Trim().Split('?')
				into urlParts
				select urlParts[1].Split('&')
				into urlParams
				let objectTypeCode = urlParams.FirstOrDefault(p => p.Contains("etc="))?.Replace("etc=", "")
				let objectId = urlParams.First(p => p.Contains("id=")).Replace("id=", "")
				let entityName = objectTypeCode == null
					? urlParams.FirstOrDefault(p => p.Contains("etn="))?.Replace("etn=", "")
					: MetadataHelpers.GetEntityNameUsingTypeCode(service, int.Parse(objectTypeCode), orgId)
				select new EntityReference(entityName, Guid.Parse(objectId));
		}

		/// <summary>
		/// Returns a new Entity with the source and destination attributes merged.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
        public static T MergeAttributes<T>(this T destinationEntity, Entity sourceEntity)
            where T : Entity
        {
            sourceEntity.Require(nameof(sourceEntity));
	        destinationEntity.Require(nameof(destinationEntity));

	        return
				new Entity(destinationEntity.LogicalName)
					.IntegrateAttributes(destinationEntity)
					.IntegrateAttributes(sourceEntity)
					.ToEntity<T>();
        }

		/// <summary>
		/// Returns the destination Entity (left-side of . operator) with the destination attributes merged.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
        public static T IntegrateAttributes<T>(this T destinationEntity, Entity sourceEntity)
            where T : Entity
        {
            sourceEntity.Require(nameof(sourceEntity));
	        destinationEntity.Require(nameof(destinationEntity));

	        foreach (var kv in sourceEntity.Attributes)
	        {
		        destinationEntity[kv.Key] = kv.Value;
	        }

	        foreach (var kv in sourceEntity.FormattedValues)
	        {
		        destinationEntity.FormattedValues[kv.Key] = kv.Value;
	        }

	        return destinationEntity;
        }

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
        public static T ExtractEntityByAlias<T>(this Entity sourceEntity, string alias)
            where T : Entity
        {
            sourceEntity.Require(nameof(sourceEntity));
            alias.RequireNotEmpty(nameof(alias));

            var values = sourceEntity.Attributes
                .Where(kv => kv.Key.StartsWith($"{alias}."))
                .Select(kv => kv.Value as AliasedValue)
                .Where(v => v != null).ToArray();

	        var logicalName = values.FirstOrDefault()?.EntityLogicalName;

	        if (logicalName == null)
	        {
		        return null;
	        }

            var newEntity = new Entity(logicalName);

            foreach (var aliasedValue in values)
            {
                newEntity[aliasedValue.AttributeLogicalName] = aliasedValue.Value;
            }

            var formattedValues = sourceEntity.FormattedValues
                .Where(kv => kv.Key.StartsWith($"{alias}."));

            foreach (var kv in formattedValues)
            {
                newEntity.FormattedValues[kv.Key.Replace($"{alias}.", "")] = kv.Value;
            }

            return newEntity.ToEntity<T>();
        }

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
        public static T ExcludeExistingValues<T>(this T newRecord, Entity existingRecord)
            where T : Entity
        {
            newRecord.Require(nameof(newRecord));
            existingRecord.Require(nameof(existingRecord));

            // IDs' will probably match and be removed below; so restore it after
            var id = newRecord.Id;

            // 'ToArray' is used to create a new collection; modifying collections mid iteration causes exception
            foreach (var attribute in newRecord.Attributes.ToArray())
            {
                var key = attribute.Key;
                var value = attribute.Value;

                bool isEqual;

                switch (value)
                {
                    case OptionSetValue optionSetValue:
                        var existingOsValue = existingRecord.GetAttributeValue<OptionSetValue>(key);
                        isEqual = optionSetValue.Value == existingOsValue?.Value;
                        break;

                    case EntityReference entityReference:
                        var existingRefValue = existingRecord.GetAttributeValue<EntityReference>(key);
                        isEqual = entityReference.Id == existingRefValue?.Id;
                        break;

                    case Money money:
                        var existingMoneyValue = existingRecord.GetAttributeValue<Money>(key);
                        isEqual = money.Value == existingMoneyValue?.Value;
                        break;

                    default:
                        var existingValue = existingRecord.GetAttributeValue<object>(key);
                        isEqual = value == existingValue || value?.Equals(existingValue) == true;
                        break;
                }

                if (isEqual)
                {
                    newRecord.Attributes.Remove(key);
                }
            }

            newRecord.Id = id;

            return newRecord;
        }

		/// <summary>
		///     Executes given requests in a transaction. The returned value should only be taken into consideration
		///     if 'isReturnResponses' is 'true'.<br />
		///     All executed requests will be rolled back if one fails.<br />
		///     The handler takes 'current batch index (1, 2 ... etc.), total batch count, responses' as parameters.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IDictionary<OrganizationRequest, ExecuteBulkResponse> ExecuteTransaction(this IEnumerable<OrganizationRequest> requestsParam,
			IOrganizationService service, bool isReturnResponses = false, int batchSize = 1000,
	        Action<int, int, IDictionary<OrganizationRequest, ExecuteBulkResponse>> bulkFinishHandler = null)
		{
			var requests = requestsParam.ToArray();

	        if (requests?.Any() != true)
	        {
                return new Dictionary<OrganizationRequest, ExecuteBulkResponse>();
	        }

            var bulkRequest =
                new ExecuteTransactionRequest
                {
                    Requests = new OrganizationRequestCollection(),
                    ReturnResponses = isReturnResponses
                };

            var responses = new Dictionary<OrganizationRequest, ExecuteBulkResponse>();
	        var perBulkResponses = new Dictionary<OrganizationRequest, ExecuteBulkResponse>();

            var batchCount = Math.Ceiling(requests.Length / (double)batchSize);

            // take bulk size only for each iteration
            for (var i = 0; i < batchCount; i++)
            {
                // clear the previous batch
                bulkRequest.Requests.Clear();
	            perBulkResponses.Clear();

                // take batches
                bulkRequest.Requests.AddRange(requests.Skip(i * batchSize).Take(batchSize));
                var bulkResponses = (ExecuteTransactionResponse)service.Execute(bulkRequest);

                // no need to build a response
                if (!isReturnResponses)
                {
	                bulkFinishHandler?.Invoke(i + 1, (int)batchCount, perBulkResponses);
                    continue;
                }

                for (var j = 0; j < bulkResponses.Responses.Count; j++)
                {
                    var request = bulkRequest.Requests[j];
                    var bulkResponse = bulkResponses.Responses[j];

                    var response =
                        new ExecuteBulkResponse
                        {
                            RequestType = request.GetType(),
                            Response = bulkResponse,
                            ResponseType = bulkResponse?.GetType()
                        };
                    responses[request] = response;
					perBulkResponses[request] = response;
                }

				bulkFinishHandler?.Invoke(i + 1, (int)batchCount, perBulkResponses);
            }

            return responses;
        }

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IDictionary<OrganizationRequest, ExecuteBulkResponse> ExecuteBulk(IOrganizationService service,
			IReadOnlyList<OrganizationRequest> requests,
			bool isReturnResponses = false, int batchSize = 1000, bool isContinueOnError = true,
			Action<int, int, IDictionary<OrganizationRequest, ExecuteBulkResponse>> bulkFinishHandler = null)
		{
			return requests.ExecuteBulk(service, isReturnResponses, batchSize, isContinueOnError, bulkFinishHandler);
		}

		/// <summary>
		///     Executes given requests in bulk. The returned value should only be taken into consideration
		///     if 'isReturnResponses' is 'true'.<br />
		///     The handler takes 'current batch index (1, 2 ... etc.), total batch count, responses' as parameters.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IDictionary<OrganizationRequest, ExecuteBulkResponse> ExecuteBulk(this IEnumerable<OrganizationRequest> requestsParam,
			IOrganizationService service,
			bool isReturnResponses = false, int batchSize = 1000, bool isContinueOnError = true,
			Action<int, int, IDictionary<OrganizationRequest, ExecuteBulkResponse>> bulkFinishHandler = null)
		{
			var requests = requestsParam.ToArray();

			if (requests?.Any() != true)
			{
				return new Dictionary<OrganizationRequest, ExecuteBulkResponse>();
			}

			var bulkRequest =
				new ExecuteMultipleRequest
				{
					Requests = new OrganizationRequestCollection(),
					Settings =
						new ExecuteMultipleSettings
						{
							ContinueOnError = isContinueOnError,
							ReturnResponses = isReturnResponses
						}
				};

			var responses = new Dictionary<OrganizationRequest, ExecuteBulkResponse>();
			var perBulkResponses = new Dictionary<OrganizationRequest, ExecuteBulkResponse>();

			var batchCount = Math.Ceiling(requests.Length / (double)batchSize);

			// take bulk size only for each iteration
			for (var i = 0; i < batchCount; i++)
			{
				// clear the previous batch
				bulkRequest.Requests.Clear();
				perBulkResponses.Clear();

				// take batches
				bulkRequest.Requests.AddRange(requests.Skip(i * batchSize).Take(batchSize));
				var bulkResponses = (ExecuteMultipleResponse)service.Execute(bulkRequest);

				// no need to build a response
				if (!isReturnResponses)
				{
					// break on error and no 'continue on error' option
					if (!isContinueOnError && (bulkResponses.IsFaulted || bulkResponses.Responses.Any(e => e.Fault != null)))
					{
						break;
					}
					else
					{
						bulkFinishHandler?.Invoke(i + 1, (int)batchCount, perBulkResponses);
						continue;
					}
				}

				for (var j = 0; j < bulkResponses.Responses.Count; j++)
				{
					var request = bulkRequest.Requests[j];
					var bulkResponse = bulkResponses.Responses[j];
					var fault = bulkResponse.Fault;
					string faultMessage = null;

					// build fault message
					if (fault != null)
					{
						var builder = new StringBuilder();
						builder.AppendFormat("Message: \"{0}\", code: {1}", fault.Message, fault.ErrorCode);

						if (fault.TraceText != null)
						{
							builder.AppendFormat(", trace: \"{0}\"", fault.TraceText);
						}

						if (fault.InnerFault != null)
						{
							builder.AppendFormat(", inner message: \"{0}\", inner code: {1}", fault.InnerFault.Message,
								fault.InnerFault.ErrorCode);

							if (fault.InnerFault.TraceText != null)
							{
								builder.AppendFormat(", trace: \"{0}\"", fault.InnerFault.TraceText);
							}
						}

						faultMessage = builder.ToString();
					}

					var response =
						new ExecuteBulkResponse
						{
							RequestType = request.GetType(),
							Response = bulkResponse.Response,
							ResponseType = bulkResponse.Response == null ? null : bulkResponse.Response.GetType(),
							Fault = fault,
							FaultMessage = faultMessage
						};
					responses[request] = response;
					perBulkResponses[request] = response;
				}

				bulkFinishHandler?.Invoke(i + 1, (int)batchCount, perBulkResponses);

				// break on error and no 'continue on error' option
				if (!isContinueOnError && (bulkResponses.IsFaulted || bulkResponses.Responses.Any(e => e.Fault != null)))
				{
					break;
				}
			}

			return responses;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RunWorkflow(IOrganizationService service, Guid entityId, Guid workflowId)
		{
			service.Execute(
				new ExecuteWorkflowRequest
				{
					EntityId = entityId,
					WorkflowId = workflowId
				});
		}

		/// <summary>
		///     Checks whether the given FetchXML returns any records.
		///  The record's ID is added to the FetchXML is as a condition.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsConditionMet(IOrganizationService service, string fetchXml,
			EntityReference record, Guid? orgId = null)
		{
			service.Require("service");
			fetchXml.RequireNotEmpty("fetchXml");
			record.Require("record");

			var primaryIdName = MetadataHelpers.GetEntityAttributes(service, record.LogicalName, orgId,
				MetadataHelpers.EntityAttribute.PrimaryIdAttribute).PrimaryIdAttribute;
			var finalFetchXml = string.Empty;

			var querySplit = fetchXml.Split(new[] { "</entity>" }, StringSplitOptions.None);

			finalFetchXml += querySplit[0];
			finalFetchXml += "<filter type='and'> ";
			finalFetchXml += "<condition attribute='" + primaryIdName + "' operator='eq' value= '" + record.Id + "' /> ";
			finalFetchXml += "</filter>" + "</entity>";
			finalFetchXml += querySplit[querySplit.Length - 1];

			return service.RetrieveMultiple(new FetchExpression(finalFetchXml)).Entities.Any();
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string BuildExceptionMessage(Exception ex, string preMessage = null, bool isUseExStackTrace = false, int depth = 0)
		{
			return ex.BuildExceptionMessage(preMessage, isUseExStackTrace, depth);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string BuildFaultMessage(OrganizationServiceFault fault, int depth)
		{
			return fault.BuildFaultMessage(depth);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static InvalidPluginExecutionException BuildInvalidPluginExecException(Exception ex, string preMessage = null)
		{
			preMessage = (preMessage == null ? string.Empty : preMessage + " ") +
				"<div style=\"display:none\">Exception: " + ex.GetType() + " => \"" + ex.Message + "\"." +
				(ex.InnerException == null
					? string.Empty
					: " Inner exception: " + ex.InnerException.GetType() + " => \"" + ex.InnerException.Message + "\".") +
				"</div>";

			var message = "\nException: " + ex.GetType() + " => \"" + ex.Message + "\"." +
				"\nSource: " + ex.Source +
				"\n\n" + (ex.StackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common")) + "\n" +
				(ex.InnerException == null
					? string.Empty
					: "\n\nInner exception: " + ex.InnerException.GetType() + " => \"" +
						ex.InnerException.Message + "\"." +
						"\nSource: " + ex.InnerException.Source +
						"\n\n" + ex.InnerException.StackTrace + "\n");

			message = message
				.Replace("\"", "&quot;").Replace("'", "\\'").Replace("\n", "<br />").Replace("\\n", "<br />").Replace("\r",
					string.Empty);

			var script = "<br />" +
				"<button class=\"ms-crm-RefreshDialog-Button\" style=\"margin-right: 30px; margin-left: 8px;\"" +
				"onclick=\"" +
				" var w = window.open('', 'Error Details', 'height=100, width=600, toolbar=no, menubar=no, resizable=no, scrollbars=yes, location=no, directories=no, status=no');"
				+
				" parent.$(w.document.body).html('" + message + "');" +
				" w.document.title = 'Error Details';" +
				" parent.$(w.document.body).css({ 'color': 'blue', 'font-size': 13 });" +
				"\">More Details</button>"
				+ "<br />"
				+ "<br />";

			return new InvalidPluginExecutionException(preMessage + script, ex);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetAttributeName(string field, Entity record)
		{
			record.FormattedValues.TryGetValue(field, out var label);
			return label.IsFilled() ? label : GetAttributeName(record.GetAttributeValue<object>(field));
		}

		public static string GetAttributeName(object fieldValue)
		{
			if (fieldValue == null)
			{
				return null;
			}

			if (fieldValue is string s)
			{
				return s;
			}

			if (fieldValue is OptionSetValue value)
			{
				return value.Value.ToString();
			}

			if (fieldValue is DateTime time)
			{
				return time.ToString("yyyy-MM-ddTHH:mm:ss.fffK");
			}

			if (fieldValue is EntityReference fieldRef)
			{
				return $"{fieldRef.LogicalName}:{fieldRef.Id.ToString().ToUpper()}";
			}

			if (fieldValue is Guid fieldGuid)
			{
				return fieldGuid.ToString().ToUpper();
			}

			if (fieldValue is Money fieldMoney)
			{
				return fieldMoney.Value.ToString();
			}

			return fieldValue.ToString();
		}

		#region Relations helpers

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IReadOnlyList<Entity> GetRelatedRecords(IOrganizationService service, EntityReference entity,
			MetadataHelpers.RelationType[] relationTypes, FilterExpression filter = null,
			Guid? orgId = null, params string[] attributes)
		{
			if (relationTypes == null || relationTypes.Length <= 0)
			{
				return Array.Empty<Entity>();
			}

			var relationAttributes =
				new[]
				{
					MetadataHelpers.RelationAttribute.SchemaName, MetadataHelpers.RelationAttribute.RelationshipType, MetadataHelpers.RelationAttribute.IntersectEntityName,
					MetadataHelpers.RelationAttribute.ReferencedEntity, MetadataHelpers.RelationAttribute.ReferencedAttribute,
					MetadataHelpers.RelationAttribute.ReferencingEntity, MetadataHelpers.RelationAttribute.ReferencingAttribute,
					MetadataHelpers.RelationAttribute.Entity1LogicalName, MetadataHelpers.RelationAttribute.Entity1IntersectAttribute,
					MetadataHelpers.RelationAttribute.Entity2LogicalName, MetadataHelpers.RelationAttribute.Entity2IntersectAttribute
				};

			var relations = MetadataHelpers
				.GetCustomRelationships(service, entity.LogicalName, relationTypes, relationAttributes, orgId)
				.Select(r =>
						{
							var relation =
								MetadataHelpers.BuildRelationMetadata(r,
									r.RelationshipType == RelationshipType.OneToManyRelationship
										? MetadataHelpers.RelationType.OneToManyRelationships
										: MetadataHelpers.RelationType.ManyToManyRelationships);
							relation.Require(nameof(relation), $"Unable to find relation '{r.SchemaName}' in entity '{entity.LogicalName}'.");
							return relation;
						});
			return GetRelatedRecordsInner(service, entity, relations.ToArray(), filter, orgId, attributes);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IReadOnlyList<Entity> GetRelatedRecords(IOrganizationService service, EntityReference entity,
			string relationName, FilterExpression filter = null, Guid? orgId = null, params string[] attributes)
		{
			service.Require(nameof(service));
			entity.Require(nameof(entity));
			relationName.RequireNotEmpty(nameof(relationName));

			var relation = MetadataHelpers.GetRelation(service, entity.LogicalName, relationName, orgId);
			relation.Require(nameof(relation), $"Unable to find relation '{relationName}' in entity '{entity.LogicalName}'.");

			return GetRelatedRecordsInner(service, entity, new[] { relation }, filter,
				orgId, attributes);
		}

		private static IReadOnlyList<Entity> GetRelatedRecordsInner(IOrganizationService service, EntityReference entity,
			IReadOnlyList<RelationMetadata> relations, FilterExpression filter = null, Guid? orgId = null, params string[] attributes)
		{
			var related = new List<Entity>();

			var idFieldName = MetadataHelpers.GetEntityAttribute<string>(service, entity.LogicalName,
				MetadataHelpers.EntityAttribute.PrimaryIdAttribute, orgId);

			var manyToMany = relations.Where(relation => relation.Type == MetadataHelpers.RelationType.ManyToManyRelationships).ToArray();

			if (manyToMany.Any())
			{
				foreach (var rel in manyToMany)
				{
					var entity2Name = rel.Entity1Name == entity.LogicalName
						? rel.Entity2Name
						: rel.Entity1Name;
					var entity2Id = rel.Entity1Name == entity.LogicalName
						? rel.Entity2FieldName
						: rel.Entity1FieldName;
					var intersectEntity = rel.IntersectingEntityName;

					related.AddRange(GetRecords(entity, service, entity2Name, intersectEntity, entity2Id,
						entity2Id, idFieldName, -1, -1, filter, attributes));
				}
			}

			var oneToMany = relations.Where(relation => relation.Type == MetadataHelpers.RelationType.OneToManyRelationships).ToArray();

			if (oneToMany.Any())
			{
				foreach (var rel in oneToMany)
				{
					var entity2Name = rel.Entity2Name;
					var entity2LookupName = rel.Entity2FieldName;

					related.AddRange(GetRecords(entity, service, entity2Name, entity.LogicalName,
						entity2LookupName, idFieldName, idFieldName, -1, -1, filter, attributes));
				}
			}

			var manyToOne = relations.Where(relation => relation.Type == MetadataHelpers.RelationType.ManyToOneRelationships).ToArray();

			if (manyToOne.Any())
			{
				foreach (var rel in manyToOne)
				{
					var entity2Name = rel.Entity1Name;
					var entity2LookupName = rel.Entity1FieldName;

					related.AddRange(GetRecords(entity, service, entity2Name, entity.LogicalName,
						entity2LookupName, idFieldName, idFieldName, -1, -1, filter, attributes));
				}
			}

			return related;
		}

		#endregion

		#region User helpers

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IReadOnlyList<Guid> GetTeamMembers(IOrganizationService service, Guid teamId)
		{
			using (var svcContext = new OrganizationServiceContext(service))
			{
				return
					(from user in svcContext.CreateQuery("systemuser")
						join member in svcContext.CreateQuery("teammembership")
							on user["systemuserid"] equals member["systemuserid"]
						join teamQ in svcContext.CreateQuery("team")
							on member["teamid"] equals teamQ["teamid"]
						where teamQ["teamid"].Equals(teamId)
						select (Guid)user["systemuserid"]).ToArray();
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IReadOnlyList<Guid> GetQueueMembers(IOrganizationService service, Guid queueId)
		{
			using (var svcContext = new OrganizationServiceContext(service))
			{
				return
					(from user in svcContext.CreateQuery("systemuser")
						join member in svcContext.CreateQuery("queuemembership")
							on user["systemuserid"] equals member["systemuserid"]
						join queue in svcContext.CreateQuery("queue")
							on member["queueid"] equals queue["queueid"]
						where queue["queueid"].Equals(queueId)
						select (Guid)user["systemuserid"]).ToArray();
			}
		}

		/// <summary>
		///     From the SDK: http://msdn.microsoft.com/en-us/library/hh670609.aspx <br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static int GetPreferredLangCode(IOrganizationService service, EntityReference record)
		{
			if (record.LogicalName == "systemuser")
			{
				var userSettingsQuery = new QueryExpression("usersettings");
				userSettingsQuery.ColumnSet.AddColumns("uilanguageid", "systemuserid");
				userSettingsQuery.Criteria.AddCondition("systemuserid", ConditionOperator.Equal, record.Id);
				var userSettings = service.RetrieveMultiple(userSettingsQuery);

				if (userSettings.Entities.Count > 0)
				{
					var code = (int)userSettings.Entities[0]["uilanguageid"];
					return code <= 0 ? 1033 : code;
				}
			}
			else if (record.LogicalName == "account" || record.LogicalName == "contact")
			{
				Entity result;

				result = service.Retrieve(record.LogicalName, record.Id, new ColumnSet("ys_preferredcommunicationlanguage"));

				if (!result.Contains("ys_preferredcommunicationlanguage"))
				{
					return 1033;
				}

				return ((OptionSetValue)result["ys_preferredcommunicationlanguage"]).Value;
			}
			else
			{
				throw new NotSupportedException("Entity does not support a default language spec '" + record.LogicalName + "'.");
			}

			return 1033;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static int GetUserTimeZoneBiasMinutes(IOrganizationService service, Guid userId)
		{
			return GetUsersTimeZoneBiasMinutes(service, userId).FirstOrDefault().Value;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IDictionary<Guid, int> GetUsersTimeZoneBiasMinutes(IOrganizationService service, params Guid[] userIds)
		{
			var query = new QueryExpression("usersettings");
			var filter = new FilterExpression(LogicalOperator.Or);

			foreach (var userId in userIds)
			{
				filter.AddCondition("systemuserid", ConditionOperator.Equal, userId);
			}

			query.ColumnSet = new ColumnSet("systemuserid", "timezonebias");
			query.Criteria.Filters.Add(filter);

			var userSettings = service.RetrieveMultiple(query).Entities;

			if (userSettings == null || userSettings.Count < userIds.Length
				|| userSettings.Any(settings => !settings.Contains("timezonebias")))
			{
				throw new Exception("Can't retrieve the settings of the users.");
			}

			return userSettings.ToDictionary(
				settings => settings.GetAttributeValue<Guid>("systemuserid"),
				settings => settings.GetAttributeValue<int>("timezonebias") * -1);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static Guid? GetManagerId(IOrganizationService service, Guid userId)
		{
			var user = service.Retrieve("systemuser", userId, new ColumnSet("parentsystemuserid"));

			if (!user.Contains("parentsystemuserid"))
			{
				throw new Exception("User record does not contain a manager.");
			}

			return ((EntityReference)user["parentsystemuserid"]).Id;
		}

		/// <summary>
		///     Validates that the owner can edit the record.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="targetRecord">The target record to check for access rights.</param>
		/// <param name="targetOwner">The owner to check the rights for.</param>
		public static bool CanUpdateRecord(IOrganizationService service, EntityReference targetRecord,
			EntityReference targetOwner)
		{
			// request user's access rights to current record
			var principalAccessRequest =
				new RetrievePrincipalAccessRequest
				{
					Principal = targetOwner,
					Target = targetRecord
				};

			// response will contain AccessRights mask, like AccessRights.WriteAccess | AccessRights.ReadAccess | ...
			var principalAccessResponse = (RetrievePrincipalAccessResponse)service.Execute(principalAccessRequest);

			// if user can't edit record
			if ((principalAccessResponse.AccessRights & AccessRights.WriteAccess) != AccessRights.WriteAccess)
			{
				return false;
			}

			return true;
		}

		#endregion

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetRecordUrl(IOrganizationService service, EntityReference recordRef, Guid? orgId = null)
		{
			recordRef.Require(nameof(recordRef));

			var config = GetGenericConfig(service, orgId);
			var baseUrl = config.GetAttributeValue<string>("ys_organisationbaseurl");
			baseUrl.RequireNotEmpty(nameof(baseUrl));
			var rowTemplate = config.GetAttributeValue<string>("ys_rowurltemplate");
			rowTemplate.RequireNotEmpty(nameof(rowTemplate));

			return $"{baseUrl.Trim('/')}/main.aspx"
				+ $"?{(rowTemplate.Replace("{id}", recordRef.Id.ToString().ToUpper()).Replace("{table}", recordRef.LogicalName))}";
		}

		/// <summary>
		private static IReadOnlyList<Entity> GetRecords(EntityReference entity, IOrganizationService service,
			string fromEntityName, string toEntityName, string fromFieldName, string toFieldName,
			string intersectIdFieldName, int limit = -1, int page = -1,
			FilterExpression filter = null, params string[] attributes)
		{
			return RetrieveRecords(service, BuildRetrieveQuery(entity, fromEntityName, toEntityName,
				fromFieldName, toFieldName, intersectIdFieldName, filter, attributes), limit, page);
		}

		private static QueryExpression BuildRetrieveQuery(EntityReference entity,
			string fromEntityName, string toEntityName, string fromFieldName, string toFieldName,
			string intersectIdFieldName, FilterExpression filter = null, params string[] attributes)
		{
			// create the query taking into account paging
			var query = new QueryExpression(fromEntityName);
			query.LinkEntities.Add(new LinkEntity(fromEntityName, toEntityName, fromFieldName, toFieldName, JoinOperator.Inner));
			query.LinkEntities[0].EntityAlias = "linkedEntityAlias";
			query.Criteria.AddCondition("linkedEntityAlias", intersectIdFieldName, ConditionOperator.Equal, entity.Id);

			if (filter != null)
			{
				query.Criteria.AddFilter(filter);
			}

			if (attributes.Length == 1 && attributes[0] == "*")
			{
				query.ColumnSet = new ColumnSet(true);
			}
			else if (attributes.Length > 0)
			{
				query.ColumnSet = new ColumnSet(attributes);
			}
			else
			{
				query.ColumnSet = new ColumnSet(false);
			}

			return query;
		}

		public static string SecureConnectionString(string connectionString)
		{
			return Regex
				.Replace(Regex
					.Replace(connectionString, @"Password\s*?=.*?(?:;{0,1}$|;)", "Password=********;")
					.Replace("\r\n", " "),
					@"\s+", " ")
				.Replace(" = ", "=");
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IEnumerable<TEntity> ToEntity<TEntity>(this IEnumerable<Entity> entities) where TEntity : Entity
		{
			return entities.Select(e => e.ToEntity<TEntity>());
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static int? GetTimeZoneBias(int timeZoneCode, IOrganizationService service)
		{
			var query = new QueryByAttribute("timezonedefinition");
			query.AddAttributeValue("timezonecode", timeZoneCode);
			query.ColumnSet = new ColumnSet("bias");
			var bias = service.RetrieveMultiple(query).Entities.FirstOrDefault()?.GetAttributeValue<int?>("bias");
			return -bias;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetTimeZoneStandardName(int timeZoneCode, IOrganizationService service)
		{
			var query = new QueryByAttribute("timezonedefinition");
			query.AddAttributeValue("timezonecode", timeZoneCode);
			query.ColumnSet = new ColumnSet("standardname");
			return service.RetrieveMultiple(query).Entities.FirstOrDefault()?.GetAttributeValue<string>("standardname")
				?? throw new TimeZoneNotFoundException($"Time zone not found in CRM ({timeZoneCode}).");
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static DateTime ConvertToUtc(DateTime date, int timeZoneCode, IOrganizationService service)
		{
			return TimeZoneInfo
				.ConvertTimeToUtc(date,
					TimeZoneInfo.FindSystemTimeZoneById(GetTimeZoneStandardName(timeZoneCode, service)));
		}
	}

	/// <summary>
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static partial class MetadataHelpers
	{
		private static readonly string[] nonStandard =
		{
			"applicationfile",
			"attachment", // Not included with CrmSvcUtil 6.0.0001.0061
			"authorizationserver", // Not included with CrmSvcUtil 6.0.0001.0061
			"businessprocessflowinstance",
			// Not included with CrmSvcUtil 2013  http://community.dynamics.com/crm/f/117/t/117642.aspx
			"businessunitmap", // Not included with CrmSvcUtil 2013
			"clientupdate", // Not included with CrmSvcUtil 2013
			"commitment", // Not included with CrmSvcUtil 2013
			"competitoraddress", // isn't include in CrmSvcUtil but it shows in the default solution
			"complexcontrol", // Not Included with CrmSvcUtil 2013
			"dependencynode", // Not Included with CrmSvcUtil 2013
			"displaystringmap", // Not Included with CrmSvcUtil 2013
			"documentindex", // Not Included with CrmSvcUtil 2013
			"emailhash", // Not Included with CrmSvcUtil 2013
			"emailsearch", // Not Included with CrmSvcUtil 2013
			"filtertemplate", // Not Included with CrmSvcUtil 2013
			"imagedescriptor", // Not included with CrmSvcUtil 2013
			"importdata", // Not included with CrmSvcUtil 6.0.0001.0061
			"integrationstatus", // Not included with CrmSvcUtil 6.0.0001.0061
			"interprocesslock", // Not included with CrmSvcUtil 6.0.0001.0061
			"multientitysearchentities", // Not included with CrmSvcUtil 6.0.0001.0061
			"multientitysearch", // Not included with CrmSvcUtil 6.0.0001.0061
			"notification", // Not included with CrmSvcUtil 6.0.0001.0061
			"organizationstatistic", // Not included with CrmSvcUtil 6.0.0001.0061
			"owner", // Not included with CrmSvcUtil 2013
			"partnerapplication", // Not included with CrmSvcUtil 6.0.0001.0061
			"principalattributeaccessmap", // Not included with CrmSvcUtil 6.0.0001.0061
			"principalobjectaccessreadsnapshot", // Not included with CrmSvcUtil 6.0.0001.0061
			"principalobjectaccess", // Not included with CrmSvcUtil 6.0.0001.0061
			"privilegeobjecttypecodes", // Not included with CrmSvcUtil 6.0.0001.0061
			"postregarding", // Not included with CrmSvcUtil 2013
			"postrole", // Not included with CrmSvcUtil 2013
			"subscriptionclients", // Not included with CrmSvcUtil 6.0.0001.0061
			"salesprocessinstance", // Not included with CrmSvcUtil 6.0.0001.0061
			"recordcountsnapshot", // Not included with CrmSvcUtil 6.0.0001.0061
			"replicationbacklog", // Not included with CrmSvcUtil 6.0.0001.0061
			"resourcegroupexpansion", // Not included with CrmSvcUtil 6.0.0001.0061
			"ribboncommand", // Not included with CrmSvcUtil 6.0.0001.0061
			"ribboncontextgroup", // Not included with CrmSvcUtil 6.0.0001.0061
			"ribbondiff", // Not included with CrmSvcUtil 6.0.0001.0061
			"ribbonrule", // Not included with CrmSvcUtil 6.0.0001.0061
			"ribbontabtocommandmap", // Not included with CrmSvcUtil 6.0.0001.0061
			"roletemplate", // Not included with CrmSvcUtil 6.0.0001.0061
			"statusmap", // Not included with CrmSvcUtil 6.0.0001.0061
			"stringmap", // Not included with CrmSvcUtil 6.0.0001.0061
			"sqlencryptionaudit",
			"subscriptionsyncinfo",
			"subscription", // Not included with CrmSvcUtil 6.0.0001.0061
			"subscriptiontrackingdeletedobject",
			"systemapplicationmetadata", // Not included with CrmSvcUtil 6.0.0001.0061
			"systemuserbusinessunitentitymap", // Not included with CrmSvcUtil 6.0.0001.0061
			"systemuserprincipals", // Not included with CrmSvcUtil 6.0.0001.0061
			"traceassociation", // Not included with CrmSvcUtil 6.0.0001.0061
			"traceregarding", // Not included with CrmSvcUtil 6.0.0001.0061
			"unresolvedaddress", // Not included with CrmSvcUtil 6.0.0001.0061
			"userapplicationmetadata", // Not included with CrmSvcUtil 6.0.0001.0061
			"userfiscalcalendar", // Not included with CrmSvcUtil 6.0.0001.0061
			"webwizard", // Not included with CrmSvcUtil 6.0.0001.0061
			"wizardaccessprivilege", // Not included with CrmSvcUtil 6.0.0001.0061
			"wizardpage", // Not included with CrmSvcUtil 6.0.0001.0061
			"workflowwaitsubscription", // Not included with CrmSvcUtil 6.0.0001.0061
			// the following cause duplicate errors in generated code
			"bulkdeleteoperation",
			"reportlink",
			"rollupjob"
		};

		public enum EntityAttribute
		{
			LogicalName,
			SchemaName,
			DisplayName,
			PrimaryIdAttribute,
			PrimaryNameAttribute,
			ObjectTypeCode,
			IsActivity,
			Keys
		}

		public enum FieldAttribute
		{
			OptionSet,
			DisplayName
		}

		public enum RelationAttribute
		{
			SchemaName,
			RelationshipType,
			ReferencedEntity,
			ReferencedAttribute,
			ReferencingEntity,
			ReferencingAttribute,
			IntersectEntityName,
			Entity1LogicalName,
			Entity1IntersectAttribute,
			Entity2LogicalName,
			Entity2IntersectAttribute
		}

		public enum RelationType
		{
			OneToManyRelationships,
			ManyToOneRelationships,
			ManyToManyRelationships
		}

		/// <summary>
		///     Checks whether the given field exists in the entity by its logical name.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsFieldExistInEntity(IOrganizationService service, string entityName, string fieldName, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.IsFieldExistInEntity|{entityName}|{fieldName}";
			var isExist = CacheHelpers.GetFromMemCache<bool?>(cacheKey, orgId: orgId);

			if (isExist.HasValue)
			{
				return isExist.Value;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.AddRange("Attributes");

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions
				.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entityName));

			var attributeProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			attributeProperties.PropertyNames.AddRange("LogicalName");

			var attributeFilter = new MetadataFilterExpression(LogicalOperator.And);
			attributeFilter.Conditions
				.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, fieldName));

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties,
					AttributeQuery =
						new AttributeQueryExpression
						{
							Criteria = attributeFilter,
							Properties = attributeProperties
						}
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			var result = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest)).EntityMetadata;
			return CacheHelpers.AddToMemCache(cacheKey,
				result != null && result.Count > 0 && result.First().Attributes.Length > 0
					&& result.First().Attributes.Any(attribute => attribute.LogicalName == fieldName),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
		}

		/// <summary>
		///     Get the names of all entities.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IDictionary<string, string> GetEntityNames(IOrganizationService service, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.GetEntityNames";
			var entityNames = CacheHelpers.GetFromMemCache<IDictionary<string, string>>(cacheKey, orgId: orgId);

			if (entityNames != null)
			{
				return entityNames;
			}

			return CacheHelpers.AddToMemCache(cacheKey,
				GetEntities(service, orgId, EntityAttribute.LogicalName, EntityAttribute.DisplayName)
					.Where(e => e.DisplayName?.UserLocalizedLabel?.Label != null)
					.OrderBy(e => e.LogicalName)
					.ToDictionary(e => e.LogicalName, e => e.DisplayName?.UserLocalizedLabel?.Label),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
		}

		/// <summary>
		///     Get the given properties of all entities.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IReadOnlyList<EntityMetadata> GetEntities(IOrganizationService service, Guid? orgId = null,
			params EntityAttribute[] attributes)
		{
			return GetEntities(service, orgId, attributes.Select(attribute => attribute.ToString()).ToArray());
		}

		/// <summary>
		///     Get the names of all entities.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IReadOnlyList<EntityMetadata> GetEntities(IOrganizationService service, Guid? orgId = null, params string[] attributes)
		{
			var cacheKey = $"Yagasoft.Common.GetEntities|{attributes.Aggregate("", (a1, a2) => a1 + "," + a2)}";
			var entities = CacheHelpers.GetFromMemCache<IReadOnlyList<EntityMetadata>>(cacheKey, orgId: orgId);

			if (entities != null)
			{
				return entities;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};

			if (attributes?.Any() == true)
			{
				entityProperties.PropertyNames.AddRange(attributes);
			}

			var logicalNameString = EntityAttribute.LogicalName.ToString();

			if (attributes?.Contains(logicalNameString) != true)
			{
				entityProperties.PropertyNames.Add(logicalNameString);
			}

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Properties = entityProperties
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			return CacheHelpers.AddToMemCache(cacheKey,
				((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest)).EntityMetadata
					.Where(entity =>
					{
						if (entity.LogicalName == null)
						{
							return false;
						}

						return !nonStandard.Contains(entity.LogicalName);
					}).ToArray(),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
		}

		/// <summary>
		///     Get the entity meta data from the metadata cache.<br />
		///     Includes: LogicalName, DisplayName, PrimaryIdAttribute, PrimaryNameAttribute, Keys,
		///     Attributes, OneToManyRelationships, ManyToOneRelationships, ManyToManyRelationships<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static EntityMetadata GetEntity(IOrganizationService service, string logicalName, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.GetEntity|{logicalName}";
			var entity = CacheHelpers.GetFromMemCache<EntityMetadata>(cacheKey, orgId: orgId);

			if (entity != null)
			{
				return entity;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.AddRange("LogicalName", "DisplayName", "PrimaryIdAttribute", "PrimaryNameAttribute",
				"Keys", "Attributes", "OneToManyRelationships", "ManyToOneRelationships", "ManyToManyRelationships");

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions
				.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, logicalName));

			var attributeProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			attributeProperties.PropertyNames.AddRange("LogicalName", "DisplayName");

			var attributeFilter = new MetadataFilterExpression(LogicalOperator.And);
			attributeFilter.Conditions
				.Add(new MetadataConditionExpression("AttributeOf", MetadataConditionOperator.Equals, null));

			var keyProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			keyProperties.PropertyNames.AddRange("KeyAttributes");

			var relationProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			relationProperties.PropertyNames.AddRange("SchemaName",
				"ReferencedEntity", "ReferencedAttribute", "ReferencingEntity", "ReferencingAttribute",
				"IntersectEntityName", "Entity1LogicalName", "Entity1IntersectAttribute",
				"Entity2LogicalName", "Entity2IntersectAttribute");

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties,
					AttributeQuery =
						new AttributeQueryExpression
						{
							Properties = attributeProperties,
							Criteria = attributeFilter
						},
					KeyQuery =
						new EntityKeyQueryExpression
						{
							Properties = keyProperties
						},
					RelationshipQuery =
						new RelationshipQueryExpression
						{
							Properties = relationProperties
						}
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			return CacheHelpers.AddToMemCache(cacheKey,
				((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
					.EntityMetadata?.FirstOrDefault(),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
		}

		/// <summary>
		///     Checks whether the entity exists in the metadata cache.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsEntityExist(IOrganizationService service, string logicalName, Guid? orgId = null, bool isNoCache = false)
		{
			var cacheKey = $"Yagasoft.Common.IsEntityExist|{logicalName}";
			var isExist = CacheHelpers.GetFromMemCache<bool?>(cacheKey, orgId: orgId);

			if (isExist.HasValue)
			{
				return isExist.Value;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.Add("LogicalName");

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions
				.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, logicalName));

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			var result = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
				.EntityMetadata?.Any() == true;

			return isNoCache
				? result
				: CacheHelpers.AddToMemCache(cacheKey, result,
					CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
		}

		/// <summary>
		///     Get the value of an entity attribute from the metadata.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static T GetEntityAttribute<T>(IOrganizationService service, string entityName,
			EntityAttribute attribute, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.GetEntityAttribute|{entityName}|{attribute}";
			var attributeCached = CacheHelpers.GetFromMemCache<T>(cacheKey, orgId: orgId);

			if (attributeCached != null)
			{
				return attributeCached;
			}

			var entityProperties = new MetadataPropertiesExpression
			{
				AllProperties = false
			};
			entityProperties.PropertyNames.AddRange(attribute.ToString());

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions.Add(
				new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals,
					entityName));

			var entityQueryExpression = new EntityQueryExpression
			{
				Criteria = entityFilter,
				Properties = entityProperties
			};

			var retrieveMetadataChangesRequest = new RetrieveMetadataChangesRequest
			{
				Query = entityQueryExpression,
				ClientVersionStamp = null
			};

			var metadata = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
				.EntityMetadata?.FirstOrDefault();
			return CacheHelpers.AddToMemCache(cacheKey,
				(T)metadata?.GetType().GetProperty(attribute.ToString())?.GetValue(metadata),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
		}

		/// <summary>
		///     Get the value of a list of entity attributes from the metadata.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static EntityMetadata GetEntityAttributes(IOrganizationService service, string entityName,
			Guid? orgId = null, params EntityAttribute[] attributes)
		{
			var cacheKey = $"Yagasoft.Common.GetEntityAttributes|{entityName}|"
				+ $"{attributes.Select(a => a.ToString()).Aggregate<string>((a1, a2) => a1 + "," + a2)}";
			var attributesCached = CacheHelpers.GetFromMemCache<EntityMetadata>(cacheKey, orgId: orgId);

			if (attributesCached != null)
			{
				return attributesCached;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.AddRange(attributes.Select(a => a.ToString()));

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions
				.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entityName));

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			return CacheHelpers.AddToMemCache(cacheKey,
				((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
					.EntityMetadata?.FirstOrDefault(),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
		}

		/// <summary>
		///     Gets the logical name using the entity's object type code.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetEntityNameUsingTypeCode(IOrganizationService service, int typeCode, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.GetEntityNameUsingTypeCode|{typeCode}";
			var entityName = CacheHelpers.GetFromMemCache<string>(cacheKey, orgId: orgId);

			if (entityName != null)
			{
				return entityName;
			}

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions.Add(new MetadataConditionExpression("ObjectTypeCode",
				MetadataConditionOperator.Equals, typeCode));

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.AddRange("LogicalName");

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			return CacheHelpers.AddToMemCache(cacheKey,
				((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
					.EntityMetadata?.FirstOrDefault()?.LogicalName,
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
		}

		/// <summary>
		///     Gets the entity's object type code using its logical name.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static int GetTypeCodeUsingEntityName(IOrganizationService service, string entityName,
			Guid? orgId = null)
		{
			return GetEntityAttribute<int?>(service, entityName, EntityAttribute.ObjectTypeCode, orgId) ?? 0;
		}

		/// <summary>
		///     Get the value of a field attribute from the metadata.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static T GetFieldAttribute<T>(IOrganizationService service, string entityName, string fieldName,
			FieldAttribute attribute, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.GetFieldAttribute|{entityName}|{fieldName}|{attribute}";
			var attributeCached = CacheHelpers.GetFromMemCache<T>(cacheKey, orgId: orgId);

			if (attributeCached != null)
			{
				return attributeCached;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.AddRange("Attributes");

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions.Add(
				new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entityName));

			var attributeFilter = new MetadataFilterExpression(LogicalOperator.And);
			attributeFilter.Conditions
				.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, fieldName));

			var attributeProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			attributeProperties.PropertyNames.AddRange(attribute.ToString());

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties,
					AttributeQuery =
						new AttributeQueryExpression
						{
							Properties = attributeProperties,
							Criteria = attributeFilter
						}
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			var metadata = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
				.EntityMetadata?.FirstOrDefault();

			AttributeMetadata fieldmetadata = null;

			if (metadata != null)
			{
				fieldmetadata = metadata.Attributes?.FirstOrDefault();
			}

			return CacheHelpers.AddToMemCache(cacheKey,
				(T)fieldmetadata?.GetType().GetProperty(attribute.ToString())?.GetValue(fieldmetadata),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
		}

		/// <summary>
		///     Get the properties of all relations of a given type in an the entity from the metadata cache.<br />
		///     Includes: "SchemaName", "ReferencedEntity", "ReferencedAttribute", "ReferencingEntity",
		///     "ReferencingAttribute", "IntersectEntityName", "Entity1LogicalName", "Entity1IntersectAttribute",
		///     "Entity2LogicalName", "Entity2IntersectAttribute"<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IEnumerable<RelationMetadata> GetEntityRelations(IOrganizationService service, string entityName,
			RelationType? type, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.GetEntityRelations|{entityName}|{type}";
			var metadata = CacheHelpers.GetFromMemCache<EntityMetadata>(cacheKey, orgId: orgId);

			if (metadata == null)
			{
				var entityProperties =
					new MetadataPropertiesExpression
					{
						AllProperties = false
					};

				if (type == null)
				{
					entityProperties.PropertyNames.AddRange(Enum.GetNames(typeof(RelationType)));
				}
				else
				{
					entityProperties.PropertyNames.Add(type.ToString());
				}

				var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
				entityFilter.Conditions
					.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entityName));

				var relationProperties =
					new MetadataPropertiesExpression
					{
						AllProperties = false
					};
				relationProperties.PropertyNames.AddRange("SchemaName",
					"ReferencedEntity", "ReferencedAttribute", "ReferencingEntity", "ReferencingAttribute",
					"IntersectEntityName", "Entity1LogicalName", "Entity1IntersectAttribute",
					"Entity2LogicalName", "Entity2IntersectAttribute");

				var entityQueryExpression =
					new EntityQueryExpression
					{
						Criteria = entityFilter,
						Properties = entityProperties,
						RelationshipQuery =
							new RelationshipQueryExpression
							{
								Properties = relationProperties,
							}
					};

				var retrieveMetadataChangesRequest =
					new RetrieveMetadataChangesRequest
					{
						Query = entityQueryExpression,
						ClientVersionStamp = null
					};

				metadata = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
					.EntityMetadata?.FirstOrDefault();

				if (metadata == null)
				{
					return new RelationMetadata[0];
				}

				CacheHelpers.AddToMemCache(cacheKey, metadata, CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
			}

			return BuildRelationMetadata(metadata);
		}

		/// <summary>
		///     Get the properties of the relation from the metadata cache.<br />
		///     Includes: "SchemaName", "ReferencedEntity", "ReferencedAttribute", "ReferencingEntity",
		///     "ReferencingAttribute", "IntersectEntityName", "Entity1LogicalName", "Entity1IntersectAttribute",
		///     "Entity2LogicalName", "Entity2IntersectAttribute"<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static RelationMetadata GetRelation(IOrganizationService service, string entityName, string relationName,
			Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.GetRelation|{entityName}|{relationName}";
			var metadata = CacheHelpers.GetFromMemCache<EntityMetadata>(cacheKey, orgId: orgId);

			if (metadata == null)
			{
				var entityProperties =
					new MetadataPropertiesExpression
					{
						AllProperties = false
					};
				entityProperties.PropertyNames.AddRange(Enum.GetNames(typeof(MetadataHelpers.RelationType)));

				var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
				entityFilter.Conditions
					.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entityName));

				var relationFilter = new MetadataFilterExpression(LogicalOperator.And);
				relationFilter.Conditions
					.Add(new MetadataConditionExpression("SchemaName", MetadataConditionOperator.Equals, relationName));

				var relationProperties =
					new MetadataPropertiesExpression
					{
						AllProperties = false
					};
				relationProperties.PropertyNames.AddRange("SchemaName",
					"ReferencedEntity", "ReferencedAttribute", "ReferencingEntity", "ReferencingAttribute",
					"IntersectEntityName", "Entity1LogicalName", "Entity1IntersectAttribute",
					"Entity2LogicalName", "Entity2IntersectAttribute");

				var entityQueryExpression =
					new EntityQueryExpression
					{
						Criteria = entityFilter,
						Properties = entityProperties,
						RelationshipQuery =
							new RelationshipQueryExpression
							{
								Properties = relationProperties,
								Criteria = relationFilter
							}
					};

				var retrieveMetadataChangesRequest =
					new RetrieveMetadataChangesRequest
					{
						Query = entityQueryExpression,
						ClientVersionStamp = null
					};

				metadata = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
					.EntityMetadata?.FirstOrDefault();

				if (metadata == null)
				{
					return null;
				}

				CacheHelpers.AddToMemCache(cacheKey, metadata, CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
			}

			return BuildRelationMetadata(metadata).FirstOrDefault();
		}

		/// <summary>
		///     Get the value of a relation attribute from the metadata cache.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static T GetRelationAttribute<T>(IOrganizationService service, string entityName, string relationName,
			RelationType type, RelationAttribute attribute, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.GetRelationAttribute|{entityName}|{relationName}|{type}|{attribute}";
			var attributeCached = CacheHelpers.GetFromMemCache<T>(cacheKey, orgId: orgId);

			if (attributeCached != null)
			{
				return attributeCached;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.Add(type.ToString());

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions
				.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entityName));

			var relationFilter = new MetadataFilterExpression(LogicalOperator.And);
			relationFilter.Conditions
				.Add(new MetadataConditionExpression("SchemaName", MetadataConditionOperator.Equals, relationName));

			var relationProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			relationProperties.PropertyNames.AddRange(attribute.ToString());

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties,
					RelationshipQuery =
						new RelationshipQueryExpression
						{
							Properties = relationProperties,
							Criteria = relationFilter
						}
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			var metadata = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
				.EntityMetadata?.FirstOrDefault();

			if (metadata == null)
			{
				return default(T);
			}

			RelationshipMetadataBase relationMetadata = null;

			if (metadata.OneToManyRelationships != null)
			{
				relationMetadata = metadata.OneToManyRelationships.FirstOrDefault();
			}

			if (metadata.ManyToOneRelationships != null)
			{
				relationMetadata = metadata.ManyToOneRelationships.FirstOrDefault();
			}

			if (metadata.ManyToManyRelationships != null)
			{
				relationMetadata = metadata.ManyToManyRelationships.FirstOrDefault();
			}

			return CacheHelpers.AddToMemCache(cacheKey,
				(T)relationMetadata?.GetType().GetProperty(attribute.ToString())?.GetValue(relationMetadata),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static List<RelationshipMetadataBase> GetCustomRelationships(IOrganizationService service,
			string entityName, RelationType[] types, RelationAttribute[] attributes,
			Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.GetCustomRelationships|{entityName}|"
				+ $"{types.Select(t => t.ToString()).Aggregate<string>((t1, t2) => t1 + "," + t2)}"
				+ $"{attributes.Select(a => a.ToString()).Aggregate<string>((a1, a2) => a1 + "," + a2)}";
			var relations = CacheHelpers.GetFromMemCache<List<RelationshipMetadataBase>>(cacheKey, orgId: orgId);

			if (relations != null)
			{
				return relations;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.AddRange(types.Select(type => type.ToString()));

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions.Add(
				new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entityName));

			var relationFilter = new MetadataFilterExpression(LogicalOperator.And);
			relationFilter.Conditions
				.Add(new MetadataConditionExpression("IsCustomRelationship", MetadataConditionOperator.Equals, true));

			var relationProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			relationProperties.PropertyNames.AddRange(attributes.Select(attribute => attribute.ToString()));
			if (!attributes.Contains(MetadataHelpers.RelationAttribute.RelationshipType))
			{
				relationProperties.PropertyNames.AddRange(MetadataHelpers.RelationAttribute.RelationshipType.ToString());
			}

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties,
					RelationshipQuery =
						new RelationshipQueryExpression
						{
							Properties = relationProperties,
							Criteria = relationFilter
						}
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			var metadata = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
				.EntityMetadata?.FirstOrDefault();

			var relationMetadata = new List<RelationshipMetadataBase>();

			if (metadata == null)
			{
				return relationMetadata;
			}

			if (metadata.OneToManyRelationships != null)
			{
				relationMetadata.AddRange(metadata.OneToManyRelationships);
			}

			if (metadata.ManyToOneRelationships != null)
			{
				relationMetadata.AddRange(metadata.ManyToOneRelationships);
			}

			if (metadata.ManyToManyRelationships != null)
			{
				relationMetadata.AddRange(metadata.ManyToManyRelationships);
			}

			return CacheHelpers.AddToMemCache(cacheKey, relationMetadata, CrmHelpers.GetMetadataCacheExpiryDate(service, orgId),
				orgId: orgId);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetOptionSetLabel(IOrganizationService service, string entityName, string fieldName,
			int value, int? language = null, Guid? orgId = null)
		{
			var label = GetFieldAttribute<OptionSetMetadata>(service, entityName, fieldName, FieldAttribute.OptionSet,
				orgId)?.Options.FirstOrDefault(optionQ => optionQ.Value == value)?.Label;

			return language == null
				? label?.UserLocalizedLabel?.Label
				: label?.LocalizedLabels?.Where(l => l.LanguageCode == language).FirstOrDefault()?.Label;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IEnumerable<RelationMetadata> BuildRelationMetadata(EntityMetadata entityMetadata)
		{
			IEnumerable<RelationMetadata> relationMetadata = new RelationMetadata[0];

			if (entityMetadata.OneToManyRelationships?.Length > 0)
			{
				relationMetadata = relationMetadata.Union(entityMetadata.OneToManyRelationships
					.Select(m => BuildRelationMetadata(m, RelationType.OneToManyRelationships))
					.Where(r => r != null));
			}

			if (entityMetadata.ManyToOneRelationships?.Length > 0)
			{
				relationMetadata = relationMetadata.Union(entityMetadata.ManyToOneRelationships
					.Select(m => BuildRelationMetadata(m, RelationType.ManyToOneRelationships))
					.Where(r => r != null));
			}

			if (entityMetadata.ManyToManyRelationships?.Length > 0)
			{
				relationMetadata = relationMetadata.Union(entityMetadata.ManyToManyRelationships
					.Select(m => BuildRelationMetadata(m, RelationType.ManyToManyRelationships))
					.Where(r => r != null));
			}

			return relationMetadata;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static RelationMetadata BuildRelationMetadata(RelationshipMetadataBase relationMetadata, RelationType type)
		{
			if (relationMetadata is OneToManyRelationshipMetadata relation1NTypeSpecific
				&& type == RelationType.OneToManyRelationships)
			{
				return new RelationMetadata
				{
					SchemaName = relation1NTypeSpecific.SchemaName,
					Entity1Name = relation1NTypeSpecific.ReferencedEntity,
					Entity1FieldName = relation1NTypeSpecific.ReferencedAttribute,
					Entity2Name = relation1NTypeSpecific.ReferencingEntity,
					Entity2FieldName = relation1NTypeSpecific.ReferencingAttribute,
					Type = type
				};
			}

			if (relationMetadata is OneToManyRelationshipMetadata relationN1TypeSpecific
				&& type == RelationType.ManyToOneRelationships)
			{
				return new RelationMetadata
				{
					SchemaName = relationN1TypeSpecific.SchemaName,
					Entity1Name = relationN1TypeSpecific.ReferencedEntity,
					Entity1FieldName = relationN1TypeSpecific.ReferencedAttribute,
					Entity2Name = relationN1TypeSpecific.ReferencingEntity,
					Entity2FieldName = relationN1TypeSpecific.ReferencingAttribute,
					Type = type
				};
			}

			if (relationMetadata is ManyToManyRelationshipMetadata relationNnTypeSpecific
				&& type == RelationType.ManyToManyRelationships)
			{
				return new RelationMetadata
				{
					SchemaName = relationNnTypeSpecific.SchemaName,
					Entity1Name = relationNnTypeSpecific.Entity1LogicalName,
					Entity1FieldName = relationNnTypeSpecific.Entity1IntersectAttribute,
					Entity2Name = relationNnTypeSpecific.Entity2LogicalName,
					Entity2FieldName = relationNnTypeSpecific.Entity2IntersectAttribute,
					IntersectingEntityName = relationNnTypeSpecific.IntersectEntityName,
					Type = type
				};
			}

			return null;
		}
	}

	//[ExcludeFromCodeCoverage]
	//[DebuggerNonUserCode]
	//[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	//public static class HttpExtensions
	//{
	//	public static HttpResponseMessage PatchAsync(this HttpClient client, Uri requestUri, HttpContent content)
	//	{
	//		var method = new HttpMethod("PATCH");
	//		var request = new HttpRequestMessage(method, requestUri) { Content = content };
	//		return client.SendAsync(request).Result;
	//	}
	//}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public static class MessageHelpers
	{
		private const string CustomMessagesCacheKey = "ys_custommessages_73651786581";
		private const string CustomMessagesCacheExpiryTargetCacheKey = "ys_custommessages_cacheexpirytarget_3982618659127";

		public static void LoadCustomMessages(IOrganizationService service, Guid? orgId = null)
		{
			var cacheParams = CacheHelpers.BuildCacheParams(service, orgId: orgId);
			var messagesCache = CacheHelpers.GetFromMemCache<Dictionary<int, Dictionary<int, string>>>(CustomMessagesCacheKey, orgId: orgId);
			var messagesCacheExpiryTarget = CacheHelpers.GetFromMemCache<DateTime?>(CustomMessagesCacheExpiryTargetCacheKey, orgId: orgId);
			var isStale = messagesCache == null || messagesCacheExpiryTarget == null || messagesCacheExpiryTarget < DateTime.Now.AddMinutes(3);

			if (!isStale)
			{
				return;
			}
			
			var customMessagesQuery =
				new FetchExpression(
					@"<fetch version='1.0' output-format='xml-platform' mapping='logical' distinct='false' no-lock='true'>
                      <entity name='ys_custommessage'>
                        <all-attributes />
                      </entity>
                    </fetch>");

			var customMessages = service.RetrieveMultiple(customMessagesQuery).Entities;

			cacheParams.CacheExpiryTarget =
				cacheParams.CacheExpiryTarget < DateTime.Now.AddMinutes(3)
					? DateTime.Now.AddMinutes(3)
					: cacheParams.CacheExpiryTarget.GetValueOrDefault(DateTime.Now.AddMinutes(3));

			CacheHelpers
				.AddToMemCache(CustomMessagesCacheKey,
					customMessages
						.Select(
							e =>
							{
								var messages = new Dictionary<int, string>();

								foreach (var pair in e.Attributes.Where(a => Regex.IsMatch(a.Key, @"^ys_message_\d{4}$")))
								{
									var lcid = int.TryParse(Regex.Match(pair.Key, @"^ys_message_(\d{4})$").Groups[1].ExtractCaptures().FirstOrDefault(),
										out var lcidParse)
										? lcidParse
										: 1033;
										
									messages[lcid] = pair.Value.ToString();
								}

								return
									new
									{
										id = int.TryParse(e.GetAttributeValue<string>("ys_name")?.Replace("0x", string.Empty) ?? "0", NumberStyles.HexNumber,
											CultureInfo.InvariantCulture, out var messageId)
											? messageId
											: 0,
										messages
									};
							})
						.DistinctBy(e => e.id)
						.ToDictionary(e => e.id, e => e.messages),
					cacheParams.CacheExpiryTarget, orgId: orgId);

			CacheHelpers.AddToMemCache(CustomMessagesCacheExpiryTargetCacheKey, cacheParams.CacheExpiryTarget, orgId: orgId);
		}

		public static IDictionary<int, string> GetCustomMessage(int code, Guid? orgId = null)
		{
			var messagesCache = CacheHelpers.GetFromMemCache<Dictionary<int, Dictionary<int, string>>>(CustomMessagesCacheKey, orgId: orgId);

			if (messagesCache == null)
			{
				throw new InvalidPluginExecutionException("Custom messages cache hasn't been loaded.");
			}

			messagesCache.TryGetValue(code, out var message);

			return message;
		}
	}
	
	/// <summary>
	///		Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class ErrorHelpers
	{
		public static string BuildErrorCustomMessage(int errorCode, IOrganizationService service, Guid userId, Guid? orgId = null,
			IDictionary<string, string> replacementMap = null, string defaultMessage = null)
		{
			return BuildErrorCustomMessage(errorCode, CrmHelpers.GetPreferredLangCode(service, new EntityReference("systemuser", userId)),
				orgId, replacementMap, defaultMessage);
		}

		public static string BuildErrorCustomMessage(int errorCode, int? lcid, Guid? orgId = null,
			IDictionary<string, string> replacementMap = null, string defaultMessage = null)
		{
			var message = MessageHelpers.GetCustomMessage(errorCode, orgId);
			var errorCodeText = $"0x{errorCode:x8}";
			
			var text = message is null
				? $"{defaultMessage} ()"
				: lcid is null || message.ContainsKey(lcid.Value) is not true
				? message.Select(p => $"{p.Value} ({errorCodeText})").StringAggregate(" | ")
				: $"{(message.TryGetValue(lcid.Value, out var textTry) ? textTry : defaultMessage)} ({errorCodeText})";

			return replacementMap is null ? text : replacementMap.Aggregate(text, (current, pair) => current.Replace(pair.Key, pair.Value));
		}

		public static void ThrowCrmException(int errorCode, IOrganizationService service, Guid userId, Guid? orgId = null,
			IDictionary<string, string> replacementMap = null, string defaultMessage = null)
		{
			throw new InvalidPluginExecutionException(BuildErrorCustomMessage(errorCode, service, userId, orgId,
				replacementMap, defaultMessage));
		}

		public static void ThrowCrmException(int errorCode, IOrganizationService service, Guid? orgId = null,
			IDictionary<string, string> replacementMap = null, string defaultMessage = null)
		{
			ThrowCrmException(errorCode, service, ((WhoAmIResponse)service.Execute(new WhoAmIRequest())).UserId, orgId,
				replacementMap, defaultMessage);
		}

		public static void ThrowCrmException(int errorCode, int lcid, Guid? orgId = null,
			IDictionary<string, string> replacementMap = null, string defaultMessage = null)
		{
			throw new InvalidPluginExecutionException(BuildErrorCustomMessage(errorCode, lcid, orgId,
				replacementMap, defaultMessage));
		}

		public static void ThrowCrmException(int errorCode, Guid? orgId = null,
			IDictionary<string, string> replacementMap = null, string defaultMessage = null)
		{
			ThrowCrmException(errorCode, 1033, orgId, replacementMap, defaultMessage);
		}
		
		public static string BuildExceptionMessage(this Exception ex, string preMessage = null, bool isUseExStackTrace = false,
			int depth = 0)
		{
			if (ex == null || depth > 5)
			{
				return string.Empty;
			}

			depth++;

			var message = (preMessage == null ? string.Empty : preMessage + "\r\n")
				+ "- Exception: " + ex.GetType()
				+ "\r\n- Message: " + ex.Message
				+ (ex.Source == null ? string.Empty : "\r\n- Source: " + ex.Source)
				+ (ex.HelpLink == null ? string.Empty : "\r\n- Help link: " + ex.HelpLink);

			try
			{
				message += (ex.TargetSite == null ? string.Empty : "\r\n- Target site: " + ex.TargetSite);
			}
			catch
			{
				// ignored
			}

			message += $"\r\n- HResult: {ex.HResult}"
				+ (ex.StackTrace == null
					? string.Empty
					: "\r\n- Stack trace:"
						+ "\r\n" + (ex.StackTrace
							?? (isUseExStackTrace
								? string.Empty
								: Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common"))));

			if (ex is System.ServiceModel.FaultException<OrganizationServiceFault> fault
				&& fault.CreateMessageFault().HasDetail)
			{
				message += $"\r\n\r\n--- START ** ORG SRV FAULT ---\r\n"
					+ $"\r\n{fault.Detail.BuildFaultMessage(depth)}"
					+ $"\r\n\r\n--- END ** ORG SRV FAULT ---";
			}

			if (ex.InnerException != null)
			{
				message += $"\r\n\r\n----- START ** INNER EXCEPTION -----\r\n"
					+ $"\r\n{ex.InnerException.BuildExceptionMessage(null, true, depth)}"
					+ $"\r\n\r\n----- END ** INNER EXCEPTION -----";
			}

			return message;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string BuildFaultMessage(this OrganizationServiceFault fault, int depth = 0)
		{
			if (fault == null || depth > 5)
			{
				return string.Empty;
			}

			depth++;

			var message = $"- Error: {fault.Message}"
				+ $"\r\n- Error code: {fault.ErrorCode}"
				+ $"\r\n- Timestamp: {fault.Timestamp}"
				+ $"\r\n- Activity ID: {fault.ActivityId}";

			var text = fault.TraceText;

			if (text.IsFilled())
			{
				message += $"\r\n- Trace text:\r\n{text}";
			}

			if (fault.ErrorDetails?.Any() == true)
			{
				message = fault.ErrorDetails.Aggregate($"{message}\r\n- Error details:",
					(current, errorDetail) =>
						current + $"\r\n({errorDetail.Key}, {errorDetail.Value})");
			}

			if (fault.InnerFault != null)
			{
				message += $"\r\n\r\n--- INNER ORG SRV FAULT ---\r\n"
					+ $"\r\n{fault.InnerFault.BuildFaultMessage(depth)}";
			}

			return message;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string BuildShortExceptionMessage(this Exception ex, int depth = 0)
		{
			if (ex == null || depth > 5)
			{
				return string.Empty;
			}

			depth++;

			var message = "Exception: " + ex.GetType()
				+ " | Message: " + ex.Message
				+ (ex.Source == null ? string.Empty : " | Source: " + ex.Source);

			try
			{
				message += (ex.TargetSite == null ? string.Empty : " | Target site: " + ex.TargetSite);
			}
			catch
			{
				// ignored
			}

			message += $" | HResult: {ex.HResult}";

			if (ex is System.ServiceModel.FaultException<OrganizationServiceFault> fault
				&& fault.CreateMessageFault().HasDetail)
			{
				message += $" |> SRV FAULT: {fault.Detail.BuildShortFaultMessage(depth)} <|";
			}

			if (ex.InnerException != null)
			{
				message += $" |>> {ex.InnerException.BuildExceptionMessage(null, true, depth)} <<|";
			}

			return message;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string BuildShortFaultMessage(this OrganizationServiceFault fault, int depth = 0)
		{
			if (fault == null || depth > 5)
			{
				return string.Empty;
			}

			depth++;

			var message = $"Error: {fault.Message}"
				+ $" | Error code: {fault.ErrorCode}"
				+ $" | Timestamp: {fault.Timestamp}"
				+ $" | Activity ID: {fault.ActivityId}";

			var text = fault.TraceText;

			if (fault.ErrorDetails?.Any() == true)
			{
				message = fault.ErrorDetails.Aggregate($"{message} | Error details:",
					(current, errorDetail) =>
						current + $" ({errorDetail.Key}, {errorDetail.Value})");
			}

			if (fault.InnerFault != null)
			{
				message += $" |> INNER SRV FAULT: {fault.InnerFault.BuildFaultMessage(depth)} <|";
			}

			return message;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string ExtractErrorCode(this string message)
		{
			var code = new Regex(@"0x\d*").Match(message).Value;
			return code.IsHexErrorCode() ? code : null;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsHexErrorCode(this string code)
		{
			return new Regex(@"^0x\d*$").IsMatch(code);
		}
	}

	/// <summary>
	///     credit: http://stackoverflow.com/a/961904/1919456 <br />
	///     Credit: http://stackoverflow.com/questions/19049514/strategy-for-logging-in-production-for-dynamics-crm-plugins
	///     <br />
	///		Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class PluginInfo
	{
		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetPluginExecutionInfo(IExecutionContext context, IOrganizationService organizationService = null)
		{
			context.Require(nameof(context), "Plugin execution context is required.");

			var contextTemp = context as IPluginExecutionContext;

			var lines =
				new List<string>
				{
					"MessageName: " + context.MessageName,
					"PrimaryEntityName: " + context.PrimaryEntityName,
					"PrimaryEntityId: " + context.PrimaryEntityId,
					"SecondaryEntityName: " + context.SecondaryEntityName,
					"BusinessUnitId: " + context.BusinessUnitId,
					"CorrelationId: " + context.CorrelationId,
					"Depth: " + context.Depth,
					"InitiatingUserId: " + context.InitiatingUserId,
					"UserId: " + context.UserId,
					"IsInTransaction: " + context.IsInTransaction,
					"IsolationMode: " + context.IsolationMode,
					"Mode: " + context.Mode,
					"OperationCreatedOn: " + context.OperationCreatedOn,
					"OperationId: " + context.OperationId,
					"Organization: " + context.OrganizationName + " (" + context.OrganizationId + ")"
				};


			if (contextTemp != null)
			{
				lines.Add("Stage: " + contextTemp.Stage);
			}

			AddEntityReference(lines, context.OwningExtension, "OwningExtension");
			
			ParameterCollection inputParams = null;

			try
			{
				inputParams = context.InputParameters;
			}
			catch
			{
				// ignored
			}

			if (inputParams != null)
			{
				AddParameters(lines, inputParams, "Input Parameters", organizationService);
			}

			AddParameters(lines, context.OutputParameters, "Output Parameters", organizationService);
			AddParameters(lines, context.SharedVariables, "Shared Variables", organizationService);
			AddEntityImages(lines, context.PostEntityImages, "Post Entity Images", organizationService);
			AddEntityImages(lines, context.PreEntityImages, "Pre Entity Images", organizationService);

			if (contextTemp != null)
			{
				lines.Add("Has Parent Context: " + (contextTemp.ParentContext != null));

				if (contextTemp.ParentContext != null)
				{
					lines.Add("-- Parent Context --");
					lines.Add(GetPluginExecutionInfo(contextTemp.ParentContext, organizationService));
				}
			}

			return string.Join(Environment.NewLine, lines);
		}

		private static void AddEntity(List<string> nameValuePairs, Entity entity, string name, IOrganizationService service = null)
		{
			if (entity != null)
			{
				nameValuePairs.Add($"** {name} **");
				nameValuePairs.AddRange(entity.Attributes
					.Select(att =>
						"    Entity[" + att.Key + "]: " +
							GetAttributeValue(entity.LogicalName, att.Key, att.Value, service)));
			}
			else
			{
				nameValuePairs.Add(name + ": Empty");
			}
		}

		private static string GetAttributeValue(string logicalName, string key, object value,
			IOrganizationService organizationService = null)
		{
			if (value == null)
			{
				return "Null";
			}

			var type = value.GetType();

			if (type == typeof(OptionSetValue) && organizationService != null && logicalName.IsFilled() && key.IsFilled())
			{
				var retrieveOptionSetRequest =
					new RetrieveAttributeRequest
					{
						EntityLogicalName = logicalName,
						LogicalName = key,
						RetrieveAsIfPublished = true
					};

				var response = (RetrieveAttributeResponse)organizationService.Execute(retrieveOptionSetRequest);

				var metadata = response.AttributeMetadata as EnumAttributeMetadata;

				if (metadata != null)
				{
					var valueTemp = ((OptionSetValue)value).Value;
					return valueTemp + " (" +
						metadata.OptionSet.Options
							.FirstOrDefault(option => option.Value == valueTemp)?
							.Label.UserLocalizedLabel?.Label + ")";
				}
			}

			if (type == typeof(EntityReference))
			{
				var reference = (EntityReference)value;

				if (reference.LogicalName == null)
				{
					return value.ToString();
				}

				if (organizationService != null)
				{
					var primaryAttribute = ((RetrieveEntityResponse)organizationService
						.Execute(
							new RetrieveEntityRequest
							{
								EntityFilters = EntityFilters.Entity,
								LogicalName = reference.LogicalName
							})).EntityMetadata.PrimaryNameAttribute;

					return reference.Id + " (" +
						organizationService.Retrieve(reference.LogicalName, reference.Id, new ColumnSet(primaryAttribute))
							.GetAttributeValue<string>(primaryAttribute) + ")";
				}
			}

			return Helpers.GetStringRepresentation(value);
		}

		private static void AddEntityReference(ICollection<string> nameValuePairs, EntityReference entity, string name)
		{
			if (entity != null)
			{
				nameValuePairs.Add(name + ": " + entity.Name);
			}
		}

		private static void AddEntityImages(List<string> nameValuePairs, EntityImageCollection images,
			string name, IOrganizationService organizationService = null)
		{
			if (images != null && images.Count > 0)
			{
				nameValuePairs.Add("** " + name + " **");

				foreach (var image in images)
				{
					if (image.Value == null || image.Value.Attributes.Count == 0)
					{
						if (image.Value != null)
						{
							nameValuePairs.Add("    Image[" + image.Key + "] " + image.Value.ToEntityReference().Name + ": Empty");
						}
					}
					else
					{
						nameValuePairs.Add("*   Image[" + image.Key + "] " + image.Value.ToEntityReference().Name + "   *");
						nameValuePairs.AddRange(image.Value.Attributes
							.Select(att =>
								"        Entity[" + att.Key + "]: " +
									GetAttributeValue(image.Value.ToEntityReference().LogicalName, att.Key, att.Value,
										organizationService)));
					}
				}
			}
			else
			{
				nameValuePairs.Add(name + ": Empty");
			}
		}

		private static void AddParameters(List<string> nameValuePairs, ParameterCollection parameters,
			string name, IOrganizationService service = null)
		{
			if (parameters != null && parameters.Count > 0)
			{
				nameValuePairs.Add("* " + name + " *");
				nameValuePairs.AddRange(parameters
					.Where(param => !(param.Value is Entity))
					.Select(param => "    Param[" + param.Key + "]: " + Helpers.GetStringRepresentation(param.Value)));

				foreach (var kv in parameters
					.Where(param => param.Value is Entity))
				{
					var entity = (Entity)kv.Value;
					AddEntity(nameValuePairs, entity, $"{kv.Key} {entity.ToEntityReference().Name}", service);
				}
			}
			else
			{
				nameValuePairs.Add(name + ": Empty");
			}
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static partial class BpfHelpers
	{
		/// <summary>
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		///     Returns all stages in the process, in order, with their names.<br />
		/// </summary>
		/// <param name="service">The service.</param>
		/// <param name="processId">The process identifier.</param>
		public static List<BpfStageInfo> GetStages(IOrganizationService service, Guid processId, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.GetStages|{processId}";
			var process = CacheHelpers.GetFromMemCache<Entity>(cacheKey, orgId: orgId)
				?? CacheHelpers.AddToMemCache(cacheKey,
					service.Retrieve("workflow", processId, new ColumnSet("xaml")),
					CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);

			if (!process.Contains("xaml"))
			{
				return null;
			}

			var doc = new XmlDocument();
			doc.LoadXml((string)process["xaml"]);

			var stepNodes = doc.SelectNodes("//*[local-name()='Workflow']/*[local-name()='ActivityReference']" +
				"/*[local-name()='ActivityReference.Properties']/*[local-name()='Collection']" +
				"/*[local-name()='ActivityReference']/*[local-name()='ActivityReference.Properties']");

			var stages = new List<BpfStageInfo>();

			if (stepNodes == null || stepNodes.Count <= 0)
			{
				return null;
			}

			for (var i = 0; i < stepNodes.Count; i++)
			{
				var idText = stepNodes[i].SelectSingleNode("*[local-name()='String' and @*[local-name()='Key']='StageId']");
				var id = idText?.InnerText;
				var labelNode =
					stepNodes[i].SelectSingleNode("*[local-name()='Collection']/*[local-name()='StepLabel']/@Description");
				var label = labelNode?.InnerText;

				if (id != null)
				{
					stages.Add(
						new BpfStageInfo
						{
							Id = Guid.Parse(id),
							Name = label,
							Index = i
						});
				}
			}

			return stages.Any() ? stages : null;
		}

		/// <summary>
		///     Fetches the BPF entity's record related to the given record as raw Entity object.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="service">CRM service.</param>
		/// <param name="record">Target record with the process set.</param>
		/// <param name="processId">The process.</param>
		/// <param name="isIncludeStage">Include the current Stage ID and Traversed Path in the retrieved info.</param>
		/// <param name="primaryEntityPrefix">
		///     Prefix of the Primary Entity ID attribute.
		///     Default: "bpf", and for OoB Entities it's empty.
		/// </param>
		public static BpfRecord GetBpfRecord(IOrganizationService service, EntityReference record, Guid processId,
			bool isIncludeStage = false, string primaryEntityPrefix = "bpf", Guid? orgId = null)
		{
			var processRecord = GetBpfRecordRaw(service, record, processId, isIncludeStage, primaryEntityPrefix, orgId);

			return
				new BpfRecord
				{
					LogicalName = processRecord.LogicalName,
					Id = processRecord.GetAttributeValue<Guid>("businessprocessflowinstanceid"),
					ProcessId = processRecord.GetAttributeValue<EntityReference>("processid").Id,
					StageId = processRecord.GetAttributeValue<EntityReference>("activestageid") == null
						? (Guid?)null
						: processRecord.GetAttributeValue<EntityReference>("activestageid").Id,
					TraversedPath = processRecord.GetAttributeValue<string>("traversedpath")
				};
		}

		/// <summary>
		///     Fetches the BPF entity's record related to the given record as raw Entity object.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="service">CRM service.</param>
		/// <param name="record">Target record with the process set.</param>
		/// <param name="processId">The process.</param>
		/// <param name="isIncludeStage">Include the current Stage ID and Traversed Path in the retrieved info.</param>
		/// <param name="primaryEntityPrefix">
		///     Prefix of the Primary Entity ID attribute.
		///     Default: "bpf", and for OoB Entities it's empty.
		/// </param>
		public static Entity GetBpfRecordRaw(IOrganizationService service, EntityReference record, Guid processId,
			bool isIncludeStage = false, string primaryEntityPrefix = "bpf", Guid? orgId = null)
		{
			var cacheKeyRecordName = $"Yagasoft.Common.GetBpfRecordRaw|{record.Id}|{processId}|processRecordName";
			var processRecordName = CacheHelpers.GetFromMemCache<string>(cacheKeyRecordName, orgId: orgId);

			var cacheKeyRecord = $"Yagasoft.Common.GetBpfRecordRaw|{record.Id}|{processId}|processRecord";
			var processRecord = CacheHelpers.GetFromMemCache<Entity>(cacheKeyRecord, orgId: orgId);

			if (!isIncludeStage && processRecord != null)
			{
				return processRecord;
			}

			using (var context = new OrganizationServiceContext(service) { MergeOption = MergeOption.NoTracking })
			{
				if (processRecordName == null)
				{
					// can't figure out the process record name except from the process's name in the DB
					processRecordName = CacheHelpers.AddToMemCache(cacheKeyRecordName,
						(from process in context.CreateQuery("workflow")
						 where (Guid)process["workflowid"] == processId
						 select (string)process["uniquename"]).FirstOrDefault(),
						CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);

					if (processRecordName == null)
					{
						throw new Exception($"Could not get the entity name of process: {processId}.");
					}
				}

				// get the special entity's record for this process and given target record
				processRecord =
					(from processRecordQ in context.CreateQuery(processRecordName)
					 where processRecordQ["processid"] == (object)processId
						 && processRecordQ[$"{(primaryEntityPrefix.IsFilled() ? $"{primaryEntityPrefix}_" : "")}{record.LogicalName}id"]
							 == (object)record.Id
					 select processRecordQ).FirstOrDefault();

				if (isIncludeStage)
				{
					return processRecord;
				}

				return CacheHelpers.AddToMemCache(cacheKeyRecord, processRecord,
					CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
			}
		}

		/// <summary>
		///     Returns the BPF Instance records. Logical Name of the Process Entity, and the Traversed Path are excluded.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IEnumerable<BpfRecord> GetBpfInstances(IOrganizationService service, EntityReference record, bool isIncludeStage = false,
			Guid? orgId = null)
		{
			return GetBpfInstancesRaw(service, record, isIncludeStage, orgId)?
				.Select(
					e =>
						new BpfRecord
						{
							Id = e.Id,
							ProcessId = e.GetAttributeValue<EntityReference>("processid")?.Id,
							StageId = e.GetAttributeValue<Guid?>("processstageid")
						});
		}

		/// <summary>
		///     Returns the BPF Instance records as raw Entity objects.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IReadOnlyList<Entity> GetBpfInstancesRaw(IOrganizationService service, EntityReference record, bool isIncludeStage = false,
			Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.GetBpfInstancesRaw|{record.Id}";
			var instances = CacheHelpers.GetFromMemCache<IReadOnlyList<Entity>>(cacheKey, orgId: orgId);

			if (!isIncludeStage && instances != null)
			{
				return instances;
			}

			instances =
				((RetrieveProcessInstancesResponse)service.Execute(
					new RetrieveProcessInstancesRequest
					{
						EntityId = record.Id,
						EntityLogicalName = record.LogicalName
					})).Processes?.Entities;

			if (isIncludeStage)
			{
				return instances;
			}

			return CacheHelpers.AddToMemCache(cacheKey, instances,
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
		}

		/// <summary>
		///     Returns the BPF Instance record of the given Process. The Traversed Path is excluded.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static BpfRecord GetBpfInstance(IOrganizationService service, EntityReference record, string processLogicalName,
			Guid processId, bool isIncludeStage = false, Guid? orgId = null)
		{
			var instance = GetBpfInstances(service, record, isIncludeStage, orgId)?
				.FirstOrDefault(e => e.ProcessId == processId);

			if (instance != null)
			{
				instance.LogicalName = processLogicalName;
			}

			return instance;
		}

		/// <summary>
		///     Returns the BPF Instance record of the given Process as raw Entity object.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static Entity GetBpfInstanceRaw(IOrganizationService service, EntityReference record,
			Guid processId, bool isIncludeStage = false, Guid? orgId = null)
		{
			return GetBpfInstancesRaw(service, record, isIncludeStage, orgId)
				.FirstOrDefault(e => e.GetAttributeValue<EntityReference>("processid")?.Id == processId);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static Guid? GetActiveProcessId(IOrganizationService service, EntityReference record, Guid? orgId = null)
		{
			return GetBpfInstances(service, record, false, orgId).FirstOrDefault()?.ProcessId;
		}

		public static Guid? GetActiveStageId(IOrganizationService service, EntityReference record, Guid? orgId = null)
		{
			return GetBpfInstances(service, record, true, orgId).FirstOrDefault()?.StageId;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static BpfStageRecord GetActiveStage(IOrganizationService service, EntityReference record, Guid? processId, string primaryEntityPrefix = "bpf",
			Guid? orgId = null)
		{
			service.Require(nameof(service));
			record.Require(nameof(record));
			processId.Require(nameof(processId));

			var bpfRecord = GetBpfRecordRaw(service, record, processId.GetValueOrDefault(), true, primaryEntityPrefix, orgId);
			var stageId = bpfRecord.GetAttributeValue<EntityReference>("activestageid")?.Id;
			stageId.Require(nameof(stageId), $"Unable to find Stage ID in Process ({processId}) record ({bpfRecord.Id})"
				+ $" for record ({record.LogicalName}|{record.Id}).");
			var activePath = GetActivePathRaw(service, bpfRecord.Id);
			var stage = activePath.FirstOrDefault(e => e.Id == stageId);
			stage.Require(nameof(stage), $"Unable to find Stage ({stageId}) info in Active Path of Process ({processId})"
				+ $" for record ({record.LogicalName}|{record.Id}).");
			var stageEntityName = stage?.GetAttributeValue<string>("primaryentitytypecode");
			var stageEntityRef = bpfRecord.GetAttributeValue<EntityReference>(
				$"{(primaryEntityPrefix.IsFilled() ? $"{primaryEntityPrefix}_" : "")}{stageEntityName}id");

			return
				new BpfStageRecord
				{
					Id = stageId.GetValueOrDefault(),
					StageRecord = stageEntityRef,
					ActivePath = activePath.Select(s => s.Id.ToString().ToLower()).StringAggregate(),
					TraversedPath = bpfRecord.GetAttributeValue<string>("traversedpath")
				};
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void MoveStage(IOrganizationService service, EntityReference record, string processLogicalName, Guid processId, bool moveBackwards = false,
			EntityReference stageRecordRef = null, string stageRecordLookupName = null, Guid? orgId = null)
		{
			service.Require(nameof(service));
			record.Require(nameof(record));
			processLogicalName.RequireNotEmpty(nameof(processLogicalName));

			var instance = GetBpfInstance(service, record, processLogicalName, processId, false, orgId);

			if (instance == null)
			{
				throw new Exception($"Can't find the BPF instance for process: {processId}.");
			}

			var activePath = GetActivePath(service, instance.Id).ToArray();

			Guid? targetStage = null;

			for (var i = 0; i < activePath.Length; i++)
			{
				if (activePath[i] != instance.StageId)
				{
					continue;
				}

				if (moveBackwards)
				{
					if (i <= 0)
					{
						throw new Exception("Can't move backwards from first stage in the process.");
					}

					targetStage = activePath[i - 1];
				}
				else
				{
					if (i >= activePath.Length - 1)
					{
						throw new Exception("Can't move forwards from last stage in the process.");
					}

					targetStage = activePath[i + 1];
				}

				break;
			}

			if (targetStage == null)
			{
				throw new Exception($"Can't find a stage to move to. Process: '{processId}', backwards: {moveBackwards}.");
			}

			var traversedPath = BuildTraversedPath(targetStage.Value, activePath);
			MoveToStage(service, record, targetStage.Value, instance, traversedPath, traversedPath, stageRecordRef, stageRecordLookupName, orgId);
		}

		/// <summary>
		///     Moves the process to the given stage.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="service">CRM service.</param>
		/// <param name="record">The target record to set the Stage in.</param>
		/// <param name="processLogicalName">The Logical Name of the BPF Entity.</param>
		/// <param name="processId">The process that includes the Stage.</param>
		/// <param name="stageId">The Stage.</param>
		/// <param name="stageRecordRef">The Stage record if multi-entity BPF.</param>
		/// <param name="stageRecordLookupName">The name of the Lookup in the Stage record Entity pointing to the main Entity.</param>
		public static void MoveToStage(IOrganizationService service, EntityReference record, string processLogicalName, Guid processId, Guid stageId,
			EntityReference stageRecordRef = null, string stageRecordLookupName = null, Guid? orgId = null)
		{
			service.Require(nameof(service));
			record.Require(nameof(record));
			processLogicalName.RequireNotEmpty(nameof(processLogicalName));

			var instance = GetBpfInstance(service, record, processLogicalName, processId, true, orgId);

			// first time the record is going to this process, so invoke a change so that CRM creates a BPF record first
			if (instance == null)
			{
				service.Update(
					new Entity(record.LogicalName, record.Id)
					{
						["processid"] = processId,
						["stageid"] = stageId
					});
				instance = GetBpfInstance(service, record, processLogicalName, processId, true, orgId);

				if (instance == null)
				{
					throw new Exception($"Can't find the BPF instance for Process: {processId}, for record: {record.Id}|{record.LogicalName}.");
				}
			}

			if (instance.StageId == null)
			{
				throw new Exception($"Can't find Active Stage ID in BPF record: {instance.Id},"
					+ $" for Process: {processId}, for record: {record.Id}|{record.LogicalName}.");
			}

			if (instance.StageId == stageId)
			{
				return;
			}

			if (instance == null)
			{
				throw new Exception($"Can't find the BPF instance for BPF record: {instance.Id},"
					+ $" for process: {processId}, for record: {record.Id}|{record.LogicalName}.");
			}

			var activePath = GetActivePath(service, instance.Id).ToArray();
			var oldTraversedPath = BuildTraversedPath(instance.StageId.Value, activePath);
			var newTraversedPath = BuildTraversedPath(stageId, activePath);
			MoveToStage(service, record, stageId, instance, oldTraversedPath, newTraversedPath, stageRecordRef, stageRecordLookupName, orgId);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void MoveToStage(IOrganizationService service, EntityReference record, Guid stageId, BpfRecord bpfInstanceRecord,
			string oldTraversedPath, string newTraversedPath, EntityReference stageRecordRef = null, string stageRecordLookupName = null,
			Guid? orgId = null)
		{
			service.Require(nameof(service));
			record.Require(nameof(record));
			bpfInstanceRecord.Require(nameof(bpfInstanceRecord));
			bpfInstanceRecord.ProcessId.Require(nameof(bpfInstanceRecord.ProcessId));
			oldTraversedPath.RequireNotEmpty(nameof(oldTraversedPath));
			newTraversedPath.RequireNotEmpty(nameof(newTraversedPath));

			var oldPathLength = oldTraversedPath.Split(',').Length;
			var newPathLength = newTraversedPath.Split(',').Length;

			//if (Math.Abs(oldPathLength - newPathLength) > 1)
			//{
			//	MoveStage(service, record, bpfInstanceRecord.LogicalName, bpfInstanceRecord.ProcessId.GetValueOrDefault(), orgId,
			//		oldPathLength > newPathLength);
			//}

			var updatedProcessRecord =
				new Entity(bpfInstanceRecord.LogicalName)
				{
					Id = bpfInstanceRecord.Id,
					[$"bpf_{record.LogicalName}id"] = record,
					["activestageid"] = new EntityReference("processstage", stageId)
				};

			if (stageRecordRef != null)
			{
				updatedProcessRecord[$"bpf_{stageRecordRef.LogicalName}id"] = stageRecordRef;

				// before jumping into a stage entity record, it has to be related to the current record first, if not already so
				if (stageRecordLookupName.IsFilled())
				{
					service.Update(
						new Entity(stageRecordRef.LogicalName, stageRecordRef.Id) { [stageRecordLookupName] = record });
				}
			}

			service.Update(updatedProcessRecord);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IEnumerable<Guid> GetActivePath(IOrganizationService service, Guid instanceId)
		{
			return GetActivePathRaw(service, instanceId).Select(s => s.Id);
		}

		public static IReadOnlyList<Entity> GetActivePathRaw(IOrganizationService service, Guid instanceId)
		{
			return
				((RetrieveActivePathResponse)service.Execute(
					new RetrieveActivePathRequest
					{
						ProcessInstanceId = instanceId
					})).ProcessStages.Entities;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string BuildTraversedPath(Guid stageId, IEnumerable<Guid> activePath)
		{
			var path = activePath.TakeWhile(s => s != stageId).Union(new[] { stageId }).Select(s => s.ToString()).StringAggregate();

			return path.IsFilled()
				? path
				: throw new Exception($"Couldn't find target stage '{stageId}' in the active path of the process.");
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static partial class SlaHelpers
	{
		/// <summary>
		///     Get the date by adding duration to the start date within timeslots
		/// Credit: https://www.codeproject.com/Articles/1181377/Calculate-Due-Date-Based-on-the-Customer-Service-C
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="calendarName">Calendar name as it appears in CRM</param>
		/// <param name="startDate">Date to measure from, in UTC</param>
		/// <param name="duration">Duration after the start date in minutes</param>
		/// <param name="service">CRM service</param>
		/// <returns>DateTime after adding the duration to the start date</returns>
		public static DateTime GetDueDate(string calendarName, DateTime startDate, int duration,
			IOrganizationService service, Guid? orgId = null)
		{
			var calendar = RetrieveCalender(calendarName, service, orgId);
			var holidays = RetrieveHolidays(calendar.HolidayRef, service, orgId);
			return ProcessCalendar(startDate, duration, calendar, holidays, service, orgId);
		}

		/// <summary>
		///     Get the date by adding duration to the start date within timeslots
		/// Credit: https://www.codeproject.com/Articles/1181377/Calculate-Due-Date-Based-on-the-Customer-Service-C
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="calendarId">ID of calendar to use</param>
		/// <param name="startDate">Date to measure from, in UTC</param>
		/// <param name="duration">Duration after the start date in minutes</param>
		/// <param name="service">CRM service</param>
		/// <returns>DateTime after adding the duration to the start date</returns>
		public static DateTime GetDueDate(Guid calendarId, DateTime startDate, int duration,
			IOrganizationService service, Guid? orgId = null)
		{
			var calendar = RetrieveCalender(calendarId, service, orgId);
			var holidays = RetrieveHolidays(calendar.HolidayRef, service, orgId);
			return ProcessCalendar(startDate, duration, calendar, holidays, service, orgId);
		}

		/// <summary>
		///     Get the date by adding duration to the start date within timeslots
		/// Credit: https://www.codeproject.com/Articles/1181377/Calculate-Due-Date-Based-on-the-Customer-Service-C
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="calendarName">Calendar name as it appears in CRM</param>
		/// <param name="startDate">Date to measure from, in UTC</param>
		/// <param name="endDate">Date to measure to, in UTC</param>
		/// <param name="service">CRM service</param>
		/// <returns>Duration, in minutes, within the given range</returns>
		public static int GetDuration(string calendarName, DateTime startDate, DateTime endDate,
			IOrganizationService service, Guid? orgId = null)
		{
			var calendar = RetrieveCalender(calendarName, service, orgId);
			var holidays = RetrieveHolidays(calendar.HolidayRef, service, orgId);
			return ProcessCalendar(startDate, endDate, calendar, holidays, service, orgId);
		}

		/// <summary>
		///     Get the date by adding duration to the start date within timeslots
		/// Credit: https://www.codeproject.com/Articles/1181377/Calculate-Due-Date-Based-on-the-Customer-Service-C
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="calendarId">ID of calendar to use</param>
		/// <param name="startDate">Date to measure from, in UTC</param>
		/// <param name="endDate">Date to measure to, in UTC</param>
		/// <param name="service">CRM service</param>
		/// <returns>Duration, in minutes, within the given range</returns>
		public static int GetDuration(Guid calendarId, DateTime startDate, DateTime endDate,
			IOrganizationService service, Guid? orgId = null)
		{
			var calendar = RetrieveCalender(calendarId, service, orgId);
			var holidays = RetrieveHolidays(calendar.HolidayRef, service, orgId);
			return ProcessCalendar(startDate, endDate, calendar, holidays, service, orgId);
		}

		private static CrmCalendar RetrieveCalender(string calendarName, IOrganizationService service, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.RetrieveCalender|{calendarName}";
			var calendars = CacheHelpers.GetFromMemCache<DataCollection<Entity>>(cacheKey, orgId: orgId);

			if (calendars == null)
			{
				var query =
					new QueryExpression("calendar") { ColumnSet = new ColumnSet("holidayschedulecalendarid") };
				query.Criteria.AddCondition("name", ConditionOperator.Equal, calendarName);
				query.NoLock = true;
				calendars = service.RetrieveMultiple(query).Entities;

				CacheHelpers.AddToMemCache(cacheKey, calendars, CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
			}

			return calendars.Select(calendar =>
				new CrmCalendar
				{
					Id = calendar.Id,
					HolidayRef = calendar.GetAttributeValue<EntityReference>("holidayschedulecalendarid")
				}).FirstOrDefault();
		}

		private static CrmCalendar RetrieveCalender(Guid calendarId, IOrganizationService service, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.RetrieveCalender|{calendarId}";
			var calendar = CacheHelpers.GetFromMemCache<Entity>(cacheKey, orgId: orgId);

			if (calendar == null)
			{
				calendar = service.Retrieve("calendar", calendarId, new ColumnSet("holidayschedulecalendarid"));
				CacheHelpers.AddToMemCache(cacheKey, calendar, CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
			}

			return
				new CrmCalendar
				{
					Id = calendar.Id,
					HolidayRef = calendar.GetAttributeValue<EntityReference>("holidayschedulecalendarid")
				};
		}

		private static DateTime ProcessCalendar(DateTime startDate, int duration, CrmCalendar calendar, IEnumerable<Holiday> holidays,
			IOrganizationService service, Guid? orgId = null)
		{
			var holidaysArray = holidays as Holiday[] ?? holidays?.ToArray();

			DateTime? targetDate = null;
			var defaultTarget = DateTime.UtcNow.AddMinutes(duration);
			
			while (targetDate == null)
			{
				var timeSlots = RetrieveCalendarTimeSlots(calendar.Id, service, startDate, null, orgId);
				var availableSlots = GetAvailableTimeSlots(timeSlots, holidaysArray);

				foreach (var slot in availableSlots.Where(s => s.End > startDate))
				{
					var slotStart = slot.Start >= startDate ? slot.Start : startDate;
					var slotEnd = slot.End;
					var slotDuration = (int)((slotEnd - slotStart)?.TotalMinutes).GetValueOrDefault();

					// startDate was at the slot's end, or startDate was after the slot's end
					if (slotDuration <= 0)
					{
						continue;
					}

					if (slotDuration <= duration)
					{
						duration -= slotDuration;
						continue;
					}

					// something is wrong, assign default target date
					targetDate = slotStart?.AddMinutes(duration);
					break;
				}

				// duration > available slots
				if (targetDate == null)
				{
					var slotsEnd = timeSlots.LastOrDefault()?.End;

					// something is wrong, exit
					if (slotsEnd == null)
					{
						targetDate = defaultTarget;
					}
					else
					{
						// get more slots from CRM
						startDate = slotsEnd.Value;
					}
				}
			}

			return targetDate.Value;
		}

		private static int ProcessCalendar(DateTime startDate, DateTime endDate, CrmCalendar calendar, IEnumerable<Holiday> holidays,
			IOrganizationService service, Guid? orgId = null)
		{
			var timeSlots = RetrieveCalendarTimeSlots(calendar.Id, service, startDate, endDate, orgId);
			var availableSlots = GetAvailableTimeSlots(timeSlots, holidays);

			return
				(from slot in availableSlots.Where(s => s.End > startDate)
				 let slotStart = slot.Start >= startDate ? slot.Start : startDate
				 let slotEnd = slot.End <= endDate ? slot.End : endDate
				 let slotDuration = (int)Math.Round(((slotEnd - slotStart)?.TotalMinutes).GetValueOrDefault())
				 where slotDuration > 0
				 select slotDuration).Sum();
		}

		private static IEnumerable<Holiday> RetrieveHolidays(EntityReference holidayRef, IOrganizationService service, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.RetrieveHolidays|{holidayRef}";
			var rules = CacheHelpers.GetFromMemCache<DataCollection<Entity>>(cacheKey, orgId: orgId);

			if (rules == null && holidayRef != null)
			{
				rules = service.Retrieve(holidayRef.LogicalName, holidayRef.Id, new ColumnSet(true))
					.GetAttributeValue<EntityCollection>("calendarrules").Entities;
				CacheHelpers.AddToMemCache(cacheKey, rules, CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
			}

			return holidayRef == null
				? new Holiday[0]
				: rules.Select(holidayCalrule =>
						new Holiday
						{
							Start = holidayCalrule.GetAttributeValue<DateTime>("effectiveintervalstart"),
							End = holidayCalrule.GetAttributeValue<DateTime>("effectiveintervalend"),
							TimeZoneCode = holidayCalrule.GetAttributeValue<int?>("timezonecode")
						});
		}

		private static TimeInfo[] RetrieveCalendarTimeSlots(Guid calendarId, IOrganizationService service, DateTime startDate,
			DateTime? endDate = null, Guid? orgId = null)
		{
			startDate = startDate.Date;
			endDate = endDate?.AddDays(1).Date ?? startDate.AddDays(30);

			var cacheKey = $"Yagasoft.Common.RetrieveCalendarTimeSlots|{calendarId}|{startDate}|{endDate}";
			var slots = CacheHelpers.GetFromMemCache<TimeInfo[]>(cacheKey, orgId: orgId);

			if (slots == null)
			{
				slots = ((ExpandCalendarResponse)service.Execute(
					new ExpandCalendarRequest
					{
						CalendarId = calendarId,
						Start = startDate,
						End = endDate.Value
					})).result;
				CacheHelpers.AddToMemCache(cacheKey, slots, CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
			}

			return slots;
		}

		private static IEnumerable<TimeInfo> GetAvailableTimeSlots(TimeInfo[] timeSlots, IEnumerable<Holiday> holidays)
		{
			return
				from timeSlotQ in timeSlots
				where holidays?.Any(holiday => holiday.Start < timeSlotQ.Start && holiday.End > timeSlotQ.End) != true
				select timeSlotQ;
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class FetchXmlTriggerHelpers
	{
		/// <summary>
		/// Register steps to handle FetchXML condition changes.<br />
		/// If you only care about satisfaction of conditions, then only pass plugin configs for post-operations.<br />
		/// If you need to check for negative/dissatisfaction of conditions, use pre and post-operations,
		/// passing the list of 'root' record IDs from the pre to the post plugin through the SharedVariables object.<br />
		/// You must mark the 'root' plugin, which can be common with other triggers.<br />
		/// 'GetFilteredTriggerConfigs' method can be used to get the serialised trigger config from the plugin config,
		/// which contains the FetchXML used for fetching the 'root' records.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RegisterTriggeringStep(IOrganizationService service, string id, string suffix, string fetchXml,
			TriggerConfigPlugin[] pluginConfigs, Guid? orgId = null)
		{
			service.Require(nameof(service));
			pluginConfigs.Require(nameof(pluginConfigs));
			id.RequireNotEmpty(nameof(id));
			fetchXml.RequireNotEmpty(nameof(fetchXml));

			var triggerConfigs = new List<TriggerConfig>();

			ParseConditionFields(service, $"{id}{(string.IsNullOrWhiteSpace(suffix) ? "" : $"-{suffix}")}",
				fetchXml, triggerConfigs, orgId);
			RegisterTriggeringStep(service, pluginConfigs, triggerConfigs, false, orgId);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void UnregisterTriggeringStep(IOrganizationService service, string id, string suffix, string fetchXml,
			TriggerConfigPlugin[] pluginConfigs, Guid? orgId = null)
		{
			service.Require(nameof(service));
			pluginConfigs.Require(nameof(pluginConfigs));
			id.RequireNotEmpty(nameof(id));
			fetchXml.RequireNotEmpty(nameof(fetchXml));

			var triggerConfigs = new List<TriggerConfig>();

			ParseConditionFields(service, $"{id}{(string.IsNullOrWhiteSpace(suffix) ? "" : $"-{suffix}")}",
				fetchXml, triggerConfigs, orgId);
			RegisterTriggeringStep(service, pluginConfigs, triggerConfigs, true, orgId);
		}

		public static IEnumerable<TriggerConfig> GetFilteredTriggerConfigs(string pluginConfig, params string[] fields)
		{
			return GetFilteredTriggerConfigs(ParseTriggerConfigs(pluginConfig), fields);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IEnumerable<TriggerConfig> GetFilteredTriggerConfigs(IEnumerable<TriggerConfig> triggerConfigs,
			params string[] fields)
		{
			return triggerConfigs.Where(t => fields.Contains("*") || fields.Intersect(t.Fields).Any());
		}

		private static void RegisterTriggeringStep(IOrganizationService service, TriggerConfigPlugin[] pluginConfigs,
			IReadOnlyList<TriggerConfig> triggerConfigs, bool isRemoveCurrent = false, Guid? orgId = null)
		{
			service.Require(nameof(service));
			pluginConfigs.Require(nameof(pluginConfigs));
			triggerConfigs.Require(nameof(triggerConfigs));

			foreach (var triggerConfig in triggerConfigs)
			{
				var id = triggerConfig.Id;
				var entityName = triggerConfig.EntityName;

				foreach (var pluginConfig in pluginConfigs)
				{
					if (triggerConfig.IsRootEntity != pluginConfig.IsRootEntity)
					{
						continue;
					}

					var step = GetStep(service, GetStepName(pluginConfig.Type, pluginConfig.Message, entityName));

					// get existing entity map from plugin configuration
					var stepConfig = step?.GetAttributeValue<string>("configuration");
					var parsedStepConfig = stepConfig == null
						? new List<TriggerConfig>()
						: ParseTriggerConfigs(stepConfig).Where(c => c.Id != id).ToList();

					foreach (var config in parsedStepConfig.Where(c => string.IsNullOrWhiteSpace(c.EntityName)))
					{
						config.EntityName = entityName;
					}

					if (!isRemoveCurrent)
					{
						parsedStepConfig.Add(triggerConfig);
					}

					if (pluginConfig.ExtraTriggerFields?.Any() == true)
					{
						foreach (var field in pluginConfig.ExtraTriggerFields)
						{
							triggerConfig.Fields.Add(field);
						}
					}

					var filteredStepConfigs = parsedStepConfig.Where(c => c.Fields.Any()).ToArray();

					var parsedStepConfigString = filteredStepConfigs
						.Select(c => $"{c.Id}|||{c.IsRootEntity}|||{c.Fields.StringAggregate()}"
							+ $"{(c.IsRootEntity ? "" : $"|||{c.FetchXml.StringAggregate("^^^")}")}")
						.Aggregate("", (c1, c2) => $"{c1};;;{c2}").Trim(',', ';');

					string[] filteringAttributes = null;

					if (pluginConfig.Message == "Update")
					{
						filteringAttributes = filteredStepConfigs.SelectMany(c => c.Fields).Distinct().ToArray();
					}

					RegisterStep(service, entityName, pluginConfig, parsedStepConfigString, orgId, filteringAttributes);
				}
			}
		}

		private static IEnumerable<TriggerConfig> ParseTriggerConfigs(string rawString)
		{
			rawString.RequireNotEmpty(nameof(rawString));

			return rawString.Decompress()
				.Split(new[] { ";;;" }, StringSplitOptions.RemoveEmptyEntries)
				.Select(c => c.Split(new[] { "|||" }, StringSplitOptions.RemoveEmptyEntries))
				.Where(c => c.Any() && !string.IsNullOrWhiteSpace(c[0]))
				.Select(c =>
					new TriggerConfig
					{
						Id = c[0],
						IsRootEntity = c.Length > 1 && bool.Parse(c[1]),
						Fields = c.Length > 2 ? new HashSet<string>(c[2].Split(',')) : new HashSet<string>(),
						FetchXml = c.Length > 3
							? c[3].Split(new[] { "^^^" }, StringSplitOptions.RemoveEmptyEntries).ToList()
							: new List<string>()
					});
		}

		private static void ParseConditionFields(IOrganizationService service, string id, string fetchXml,
			List<TriggerConfig> triggerConfigs, Guid? orgId = null)
		{
			fetchXml.RequireNotEmpty(nameof(fetchXml));
			triggerConfigs.Require(nameof(triggerConfigs));

			var doc = new XmlDocument();
			doc.LoadXml(fetchXml);

			var parentNodes = doc.SelectNodes("//entity")?.Cast<XmlNode>().ToList();

			if (parentNodes == null)
			{
				throw new FormatException("FetchXML is not properly formatted.");
			}

			var linkNodes = doc.SelectNodes("//link-entity")?.Cast<XmlNode>();

			if (linkNodes != null)
			{
				parentNodes.AddRange(linkNodes);
			}

			foreach (var parent in parentNodes)
			{
				var conditionNodes = parent?.SelectNodes("filter//condition")?.Cast<XmlNode>();

				if (conditionNodes == null)
				{
					continue;
				}

				foreach (var node in conditionNodes)
				{
					var entityName = parent.Attributes?["name"]?.Value;
					var attributeName = node.Attributes?["attribute"]?.Value;

					if (entityName == null || attributeName == null)
					{
						continue;
					}

					var isRoot = parent.Name == "entity";
					var triggerConfig = triggerConfigs
							.FirstOrDefault(c => c.IsRootEntity == isRoot && c.EntityName == entityName);

					if (triggerConfig == null)
					{
						triggerConfig =
							new TriggerConfig
							{
								Id = id,
								IsRootEntity = isRoot,
								EntityName = entityName,
								FetchXml = new List<string>(),
								Fields = new HashSet<string>()
							};
						triggerConfigs.Add(triggerConfig);
					}

					triggerConfig.Fields.Add(attributeName);

					var xmlParser = new XmlDocument();
					var primaryIdField = MetadataHelpers.GetEntityAttribute<string>(service, entityName,
						MetadataHelpers.EntityAttribute.PrimaryIdAttribute, orgId);

					xmlParser.LoadXml("<temp><filter>"
						+ $@"<condition attribute=""{primaryIdField}"" operator=""eq"" value=""{{{{recordId}}}}""/></filter></temp>");

					var tempXmlNodes = xmlParser.SelectSingleNode("/temp")?.ChildNodes.Cast<XmlNode>();
					var newXmlNodes = new List<XmlNode>();

					if (tempXmlNodes != null)
					{
						foreach (var tempNode in tempXmlNodes)
						{
							var newNode = parent.OwnerDocument?.ImportNode(tempNode, true);
							newXmlNodes.Add(newNode);

							if (newNode != null)
							{
								parent.AppendChild(newNode);
							}
						}
					}

					var newFetchXml = doc.OuterXml;
					triggerConfig.FetchXml.Add(newFetchXml);

					foreach (var newXmlNode in newXmlNodes)
					{
						parent.RemoveChild(newXmlNode);
					}
				}
			}
		}

		private static void RegisterStep(IOrganizationService service, string entity, TriggerConfigPlugin pluginConfig,
			string unsecureConfig, Guid? orgId = null, params string[] filteringAttributes)
		{
			service.Require(nameof(service));
			entity.RequireNotEmpty(nameof(entity));
			pluginConfig.Require(nameof(pluginConfig));

			var message = GetMessage(service, entity, pluginConfig.Message, orgId);

			if (message == null)
			{
				throw new Exception($"Couldn't find a message '{pluginConfig.Message}' for entity '{entity}'.");
			}

			var query =
				new QueryExpression("plugintype")
				{
					Distinct = true,
					NoLock = true,
					ColumnSet = new ColumnSet("name", "plugintypeid")
				};
			query.Criteria.AddCondition("name", ConditionOperator.Equal, pluginConfig.Type);

			var type = service.RetrieveMultiple(query).Entities
				.Select(e =>
					new
					{
						e.Id,
						Name = e.GetAttributeValue<string>("name")
					}).FirstOrDefault();

			if (type == null)
			{
				throw new Exception($"Couldn't find '{pluginConfig.Type}' plugin type.");
			}

			message.PluginTypeId = type.Id;
			message.TypeName = type.Name;

			var stepName = GetStepName(message.TypeName, message.MessageName, entity);
			var step = GetStep(service, stepName);

			if (string.IsNullOrWhiteSpace(unsecureConfig))
			{
				if (step != null)
				{
					service.Delete("sdkmessageprocessingstep", step.Id);
				}
			}
			else
			{
				step = step
					?? new Entity("sdkmessageprocessingstep")
					{
						["name"] = stepName,
						["rank"] = 999,
						["stage"] = new OptionSetValue((int)pluginConfig.Stage),
						["supporteddeployment"] = new OptionSetValue(0),
						["sdkmessageid"] = new EntityReference("sdkmessage", message.MessageId),
						["sdkmessagefilterid"] = new EntityReference("sdkmessagefilter", message.FilteredId),
						["eventhandler"] = new EntityReference("plugintype", message.PluginTypeId)
					};

				step["configuration"] = unsecureConfig.Compress();

				if (filteringAttributes?.Any() == true)
				{
					step["filteringattributes"] = filteringAttributes.Aggregate("", (f1, f2) => $"{f1},{f2}").Trim(',', ';');
				}

				if (pluginConfig.Mode == PluginMode.Asynchronous)
				{
					step["asyncautodelete"] = true;
				}

				step["mode"] = new OptionSetValue((int)pluginConfig.Mode);

				if (step.Id == Guid.Empty)
				{
					var stepId = service.Create(step);

					if (pluginConfig.IsPreImage || pluginConfig.IsPostImage)
					{
						RegisterImage(service, pluginConfig, stepId);
					}
				}
				else
				{
					service.Update(step);
				}
			}
		}

		private static void RegisterImage(IOrganizationService service, TriggerConfigPlugin pluginConfig, Guid stepId)
		{
			service.Require(nameof(service));
			pluginConfig.Require(nameof(pluginConfig));

			int imageType;

			if (pluginConfig.IsPreImage && !pluginConfig.IsPostImage)
			{
				imageType = 0;
			}
			else if (!pluginConfig.IsPreImage && pluginConfig.IsPostImage)
			{
				imageType = 1;
			}
			else if (pluginConfig.IsPreImage && pluginConfig.IsPostImage)
			{
				imageType = 2;
			}
			else
			{
				throw new ArgumentOutOfRangeException("ImageType", "Image type is not supported.");
			}

			var image =
				new Entity("sdkmessageprocessingstepimage")
				{
					["name"] = "image",
					["entityalias"] = "image",
					["imagetype"] = new OptionSetValue(imageType),
					["messagepropertyname"] = pluginConfig.Message == "Create" ? "Id" : "Target",
					["sdkmessageprocessingstepid"] = new EntityReference("sdkmessageprocessingstep", stepId)
				};
			service.Create(image);
		}

		private static SdkMessageInfo GetMessage(IOrganizationService service, string entityName, string messageName,
			Guid? orgId = null)
		{
			service.Require(nameof(service));
			entityName.RequireNotEmpty(nameof(entityName));
			messageName.RequireNotEmpty(nameof(messageName));

			var query =
				new FetchExpression("<fetch no-lock='true' >" +
					"  <entity name='sdkmessage' >" +
					"    <attribute name='name' />" +
					"    <attribute name='sdkmessageid' />" +
					"    <filter>" +
					$"      <condition attribute='name' operator='eq' value='{messageName}' />" +
					"    </filter>" +
					"    <link-entity name='sdkmessagefilter' from='sdkmessageid' to='sdkmessageid' alias='messagefilter' >" +
					"      <attribute name='sdkmessagefilterid' />" +
					"      <filter>" +
					"        <condition attribute='primaryobjecttypecode' operator='eq'"
					+ $" value='{MetadataHelpers.GetTypeCodeUsingEntityName(service, entityName, orgId)}' />" +
					"      </filter>" +
					"    </link-entity>" +
					"  </entity>" +
					"</fetch>");

			var message = service.RetrieveMultiple(query).Entities
				.Select(e =>
					new SdkMessageInfo
					{
						MessageId = e.GetAttributeValue<Guid>("sdkmessageid"),
						MessageName = e.GetAttributeValue<string>("name"),
						FilteredId = (Guid)
							(e.GetAttributeValue<AliasedValue>("messagefilter.sdkmessagefilterid")?.Value ?? Guid.Empty)
					}).FirstOrDefault();

			if (message == null || message.MessageId == Guid.Empty || message.FilteredId == Guid.Empty)
			{
				throw new Exception($"Couldn't find {messageName} message for entity '{entityName}'.");
			}

			return message;
		}

		private static Entity GetStep(IOrganizationService service, string stepName)
		{
			service.Require(nameof(service));
			stepName.RequireNotEmpty(nameof(stepName));

			var query =
				new QueryExpression("sdkmessageprocessingstep")
				{
					NoLock = true,
					ColumnSet = new ColumnSet(true)
				};
			query.Criteria.AddCondition("name", ConditionOperator.Equal, stepName);
			return service.RetrieveMultiple(query).Entities.FirstOrDefault();
		}

		private static string GetStepName(string typeName, string messageName, string entityName)
		{
			var builder = new StringBuilder();
			builder.Append("FetchXmlTrigger: ");
			builder.Append(typeName);
			builder.Append(": ");
			builder.Append(messageName);
			builder.Append(" of ");
			builder.Append(entityName == "none" ? "any entity" : entityName);

			return builder.ToString();
		}
	}

	public class CacheParams
	{
		public Guid? OrgId;
		public string CacheSuffix;
		public DateTime? CacheExpiryTarget;
	}

	public class SdkMessageInfo
	{
		public Guid MessageId;
		public Guid FilteredId;
		public string MessageName;
		public Guid PluginTypeId;
		public string TypeName;
	}

	public class TriggerConfig
	{
		public string Id;
		public bool IsRootEntity;
		public string EntityName;
		public HashSet<string> Fields;
		public List<string> FetchXml;
	}

	public class TriggerConfigPlugin
	{
		public string Type;
		public string Message;
		public bool IsRootEntity;
		public PluginStage Stage;
		public PluginMode Mode;
		public bool IsPreImage;
		public bool IsPostImage;
		public string[] ExtraTriggerFields;
	}

	public class CrmCalendar
	{
		public Guid Id;
		public EntityReference HolidayRef;
	}

	public class Holiday
	{
		public DateTime Start;
		public DateTime End;
		public int? TimeZoneCode;
	}

	public class RetrievePagingInfo
	{
		public string Cookie
		{
			get; set;
		}

		public int NextPage { get; set; } = 1;

		public int RecordCountLimit { get; set; } = -1;

		public bool IsMoreRecords { get; set; } = true;
	}

	public class BpfRecord
	{
		public Guid Id
		{
			get; set;
		}
		public string LogicalName
		{
			get; set;
		}
		public Guid? ProcessId
		{
			get; set;
		}
		public Guid? StageId
		{
			get; set;
		}
		public string TraversedPath
		{
			get; set;
		}
	}

	public class BpfStageRecord
	{
		public Guid Id { get; set; }
		public EntityReference StageRecord { get; set; }
		public string ActivePath { get; set; }
		public string TraversedPath { get; set; }
	}

	public class BpfStageInfo
	{
		public Guid Id
		{
			get; set;
		}

		public string Name
		{
			get; set;
		}

		public int Index
		{
			get; set;
		}
	}

	public class ExecuteBulkResponse
	{
		public OrganizationResponse Response
		{
			get; set;
		}

		public Type RequestType
		{
			get; set;
		}

		public Type ResponseType
		{
			get; set;
		}

		public OrganizationServiceFault Fault
		{
			get; set;
		}

		public string FaultMessage
		{
			get; set;
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	public class EntityComparer : IEqualityComparer<Entity>
	{
		public bool Equals(Entity x, Entity y)
		{
			return x.Id == y.Id;
		}

		public int GetHashCode(Entity obj)
		{
			return obj.Id.GetHashCode();
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	public class EntityRefComparer : IEqualityComparer<EntityReference>
	{
		public bool Equals(EntityReference x, EntityReference y)
		{
			return x.Id == y.Id;
		}

		public int GetHashCode(EntityReference obj)
		{
			return obj.Id.GetHashCode();
		}
	}

	public class RelationMetadata
	{
		public string SchemaName
		{
			get; set;
		}
		public string Entity1Name
		{
			get; set;
		}
		public string Entity1FieldName
		{
			get; set;
		}
		public string Entity2Name
		{
			get; set;
		}
		public string Entity2FieldName
		{
			get; set;
		}
		public MetadataHelpers.RelationType Type
		{
			get; set;
		}
		public string IntersectingEntityName
		{
			get; set;
		}
	}

	/// <summary>
	///     Unlike <see cref="Semaphore" />, this implementation ensures that holds are released in the order of acquiring the
	///     hold.
	///     It also implements <see cref="IDisposable" />, but in a reusable fashion; e.g:
	///     <code>	using (fifoSemaphore.GetPermit())
	/// 	{
	///  		// code ...
	///   	}
	///     </code>
	///     After exiting the 'using' block, <see cref="ReleasePermit" /> is called automatically.<br />
	///		Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public sealed class FifoSemaphore : IDisposable
	{
		private readonly Queue<ManualResetEvent> threadLocksQueue = new Queue<ManualResetEvent>();

		private readonly int maxConcurrency;

		private readonly object lockObject = new object();
		private int currentRequests;

		public FifoSemaphore(int maxConcurrency)
		{
			this.maxConcurrency = maxConcurrency;
		}

		public void Dispose()
		{
			ReleasePermit();
		}

		/// <summary>
		///     Check how many permits have been requested before, and if the number is greater than the limit,
		///     hold this request until a permit elsewhere is released.
		/// </summary>
		public FifoSemaphore AcquirePermit()
		{
			lock (lockObject)
			{
				currentRequests++;

				// if the limit hasn't been reached yet, note it, and give permission
				if (currentRequests <= maxConcurrency)
				{
					return this;
				}
			}

			using (var newLock = new ManualResetEvent(false))
			{
				// we have to wait for a slot to open
				threadLocksQueue.Enqueue(newLock);
				newLock.WaitOne();
			}

			return this;
		}

		/// <summary>
		///     Release a permit, and release the hold on the next in line.
		/// </summary>
		public void ReleasePermit()
		{
			lock (lockObject)
			{
				// note the release
				currentRequests--;

				// give permission to the next in line
				if (threadLocksQueue.Any())
				{
					threadLocksQueue.Dequeue().Set();
				}
			}
		}
	}

	/// <summary>
	///     credits: http://joe-bq-wang.iteye.com/blog/1878940 <br />
	///		Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public sealed class QueuedLock : IDisposable
	{
		private readonly object innerLock;
		private volatile int ticketsCount;
		private volatile int ticketToRide;

		public QueuedLock()
		{
			innerLock = new object();
			ticketToRide = ticketsCount + 1;
		}

		public void Dispose()
		{
			Exit();
		}

		public QueuedLock Enter()
		{
			var myTicket = Interlocked.Increment(ref ticketsCount);
			Monitor.Enter(innerLock);

			while (true)
			{
				if (myTicket == ticketToRide)
				{
					return this;
				}

				Monitor.Wait(innerLock);
			}
		}

		public void Exit()
		{
			Interlocked.Increment(ref ticketToRide);
			Monitor.PulseAll(innerLock);
			Monitor.Exit(innerLock);
		}
	}

	/// <summary>
	///     credits: http://joe-bq-wang.iteye.com/blog/1878940<br />
	///		Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public class BlockingQueue<T> : BlockingCollection<T>
	{
		#region ctor(s)

		public BlockingQueue() : base(new ConcurrentQueue<T>())
		{ }

		public BlockingQueue(int maxSize) : base(new ConcurrentQueue<T>(), maxSize)
		{ }

		#endregion ctor(s)

		#region Methods

		/// <summary>
		///     Enqueue an Item
		/// </summary>
		/// <param name="item">Item to enqueue</param>
		/// <remarks>Blocks if the blocking queue is full</remarks>
		public void Enqueue(T item)
		{
			Add(item);
		}

		/// <summary>
		///     Dequeue an item
		/// </summary>
		/// <param name="timeout">[Optional] The number of milliseconds to timeout while waiting. Value of -1 is infinite wait.</param>
		/// <returns>Item dequeued</returns>
		/// <remarks>Blocks if the blocking queue is empty</remarks>
		/// <exception cref="TimeoutException">Timeout expired.</exception>
		public T Dequeue(TimeSpan? timeout = null)
		{
			if (timeout == null)
			{
				return Take();
			}

			try
			{
				return Take(new CancellationTokenSource(timeout.Value).Token);
			}
			catch (OperationCanceledException)
			{
				throw new TimeoutException($"Timeout while waiting for an item to be added to the queue (timeout: {timeout} ms).");
			}
		}

		public T Dequeue(CancellationTokenSource cancellationToken)
		{
			return Take(cancellationToken.Token);
		}

		/// <summary>
		///     Clears the queue of all items
		/// </summary>
		public void Clear()
		{
			while (this.Any())
			{
				Dequeue();
			}
		}

		#endregion Methods
	}

	/// <summary>
	///     Adds to the queue, up to the limit, after which it dequeues to keep the size within the limit.<br />
	///     credits: https://stackoverflow.com/a/5852926/1919456<br />
	///		Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public class FixedSizeQueue<T> : ICollection<T>, IEnumerable<T>, IEnumerable, ICollection
	{
		public virtual int Limit => limit;
		public virtual int Count => q.Count;
		public virtual object SyncRoot => throw new NotSupportedException();
		public virtual bool IsSynchronized => false;
		public virtual bool IsReadOnly => false;

		protected readonly ConcurrentQueue<T> q = new ConcurrentQueue<T>();
		protected int limit;

		public FixedSizeQueue(int limit)
		{
			limit.RequireAtLeast(1, nameof(limit));
			this.limit = limit;
		}

		public virtual void Enqueue(T obj)
		{
			q.Enqueue(obj);
			while (q.Count > limit && q.TryDequeue(out var _)) ;
		}

		public virtual T Dequeue()
		{
			q.TryDequeue(out var e);
			return e;
		}

		public virtual void Add(T item)
		{
			Enqueue(item);
		}

		public virtual void Clear()
		{
			while (q.Any())
			{
				Dequeue();
			}
		}

		public virtual bool Contains(T item)
		{
			return q.Contains(item);
		}

		public virtual void CopyTo(T[] array, int arrayIndex)
		{
			array.Require(nameof(array));
			q.CopyTo(array, arrayIndex);
		}

		public virtual bool Remove(T item)
		{
			throw new NotSupportedException();
		}

		public virtual void CopyTo(Array array, int index)
		{
			array.Require(nameof(array));
			this.ToArray().CopyTo(array, index);
		}

		public virtual IEnumerator<T> GetEnumerator()
		{
			return q.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}

	#endregion

	#region CRM Logger

	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	[DebuggerNonUserCode]
	public sealed class LogAttribute : Attribute
	{ }

	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	[DebuggerNonUserCode]
	public sealed class NoLogAttribute : Attribute
	{ }

	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	[DebuggerNonUserCode]
	public sealed class LogExecEndAttribute : Attribute
	{ }

	public enum ExecutionEndState
	{
		Success = 0,
		Failure = 1
	}

	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	[DebuggerNonUserCode]
	public class Log
	{
		public string Name { get; set; }
		public string Title { get; set; }
		public string Assembly { get; set; }
		public string EntryClass { get; set; }
		public string EntryFunction { get; set; }
		public DateTime? StartDate { get; set; }
		public Guid? UserId { get; set; }
		public ExecutionEndState? ExecutionEndState { get; set; }
		public string RegardingType { get; set; }
		public Guid? RegardingId { get; set; }
		public string RegardingName { get; set; }
	}

	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	[DebuggerNonUserCode]
	public class LogEntryAddedEventArgs : EventArgs
	{
		public ILogger Logger { get; set; }
		public Log Log { get; set; }
		public LogEntry LogEntry { get; set; }
	}

	/// <summary>
	///     Contains information related to the log entry.<br />
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	[DebuggerNonUserCode]
	public class LogEntry
	{
		public LogEntry(string message, LogLevel level = LogLevel.Info, string information = "")
			: this()
		{
			Message = message;
			Information = information;
			Level = level;
		}

		public LogEntry(Exception exception, string message = null, string information = "", LogLevel level = LogLevel.Error)
			: this()
		{
			Message = message;
			Exception = exception;
			Information = information;
			Level = level;
		}

		public LogEntry(string message, string information, LogLevel level = LogLevel.Info)
			: this(message, level, information)
		{ }

		private LogEntry()
		{
			Id = Guid.NewGuid();
		}

		public Guid Id { get; set; }

		public LogEntry ParentLogEntry { get; set; }

		public string Message { get; set; }

		public DateTime? StartDate { get; set; }

		public LogLevel Level { get; set; }

		public Guid? UserId { get; set; }

		public string RegardingType { get; set; }

		public Guid? RegardingId { get; set; }

		public string RegardingName { get; set; }

		public Exception Exception { get; set; }

		public bool ExceptionThrown { get; set; }

		public string Assembly { get; set; }

		public string StackTrace { get; set; }

		public string CallingClass { get; set; }

		public string CallingFunction { get; set; }

		public int? CallingLineNumber { get; set; }

		public string Information { get; set; }

		public int? CurrentEntryIndex { get; set; }

		public int? ElapsedTime { get; set; }
	}

	/// <summary>
	///     Logging functions.<br />
	///		Author: Ahmed Elsawalhy (Yagasoft.com)<br />
	/// </summary>
	public interface ILogger
	{
		/// <summary>
		///     Sets the 'regarding' fields in the parent log.
		/// </summary>
		/// <param name="regardingType">The logical name of the concerned entity.</param>
		/// <param name="regardingId">The ID of the regarding record.</param>
		/// <param name="regardingName">
		///     [OPTIONAL] The primary field value of the concerned entity (usually the 'xxx_name' field
		///     value).
		/// </param>
		void SetRegarding(string regardingType, Guid regardingId, string regardingName = "");

		/// <summary>
		///     Sets the 'regarding' fields in the parent log. It is recommended to fill the 'Name' property.
		/// </summary>
		/// <param name="regarding">The reference to the concerned entity.</param>
		void SetRegarding(EntityReference regarding);

		/// <summary>
		///     Sets the title field in the parent log.
		/// </summary>
		/// <param name="title">Title to set.</param>
		void SetTitle(string title);

		/// <summary>
		///     Sets the entry class of the parent log.
		/// </summary>
		void SetEntryClass(string entryClass = null);

		/// <summary>
		///     Logs the start of execution.
		/// </summary>
		/// <param name="message">The message to set in the log entry</param>
		void LogExecutionStart(string message, [CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0);

		/// <summary>
		///     Logs the start of execution.
		/// </summary>
		/// <param name="logEntry">[Optional] The log entry object that includes all relevant information</param>
		void LogExecutionStart(LogEntry logEntry = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0);

		/// <summary>
		///     Logs the start of a function.
		/// </summary>
		/// <param name="message">The message to set in the log entry</param>
		void LogFunctionStart(string message, [CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0);

		/// <summary>
		///     Logs the start of a function.
		/// </summary>
		/// <param name="logEntry">[Optional] The log entry object that includes all relevant information</param>
		void LogFunctionStart(LogEntry logEntry = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0);

		/// <summary>
		///     Logs the end of a function.
		/// </summary>
		/// <param name="message">The message to set in the log entry</param>
		void LogFunctionEnd(string message, [CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0);

		/// <summary>
		///     Logs the end of a function.
		/// </summary>
		/// <param name="logEntry">[Optional] The log entry object that includes all relevant information</param>
		void LogFunctionEnd(LogEntry logEntry = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0);

		/// <summary>
		///     Logs the end of execution.
		/// </summary>
		/// <param name="message">The message to set in the log entry</param>
		/// <param name="state">[Optional] The state at which the execution ended</param>
		void LogExecutionEnd(string message, ExecutionEndState state = ExecutionEndState.Success,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0);

		/// <summary>
		///     Logs the end of execution.
		/// </summary>
		/// <param name="state">[Optional] The state at which the execution ended</param>
		/// <param name="logEntry">[Optional] The log entry object that includes all relevant information</param>
		void LogExecutionEnd(LogEntry logEntry = null, ExecutionEndState state = ExecutionEndState.Success,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0);

		void LogError(string message, string information = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0);

		void LogError(Exception exception, [CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0);

		void LogWarning(string message, string information = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0);

		void LogInfo(string message, string information = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0);

		void LogDebug(string message, string information = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0);

		/// <summary>
		///     Logs an entry.
		/// </summary>
		/// <param name="message">The message to set in the log entry</param>
		/// <param name="level">[Optional] The logging level, above which, this entry will be skipped</param>
		void Log(string message, LogLevel level = LogLevel.Info, string information = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0);

		/// <summary>
		///     Logs an exception.
		/// </summary>
		/// <param name="exception">The exception that was thrown</param>
		/// <param name="information">
		///     [Optional] Extra information to add to the log entry. If not given, a default detailed message will be built.
		/// </param>
		void Log(Exception exception, string information = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0);

		/// <summary>
		///     Logs an entry.
		/// </summary>
		void Log(LogEntry logEntry, bool parent = false, int? elapsedTime = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0);

		void LogKeyValues(string title, IDictionary<string, object> parameters, LogLevel level = LogLevel.Info,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0);

		void LogKeyValues(string title, string[] paramNames, object[] paramValues, LogLevel level = LogLevel.Info,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0);

		void LogAttributeValues(Entity labelsRecord, AttributeCollection attributes = null, string entryTitle = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0);

		/// <summary>
		///     Logs the current execution line in the code. You do not need to pass any arguments for it to work.
		/// </summary>
		void LogLine([CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0);

		/// <summary>
		///     Sets the state at which the execution ended
		/// </summary>
		/// <param name="state">The state at which the execution ended</param>
		void SetExecutionState(ExecutionEndState state);

		/// <summary>
		///     Sets the state at which the execution ended as a failure
		/// </summary>
		void ExecutionFailed();
	}

	/// <summary>
	///     Basic logic for logging.<br />
	///		Author: Ahmed Elsawalhy (Yagasoft.com)<br />
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public abstract class LoggerBase : ILogger
	{
		/// <summary>
		///     The end states of the program that contains the logging object
		/// </summary>
		#region Instance variables

		public LogLevel MaxLogLevel { get; protected set; }

		public ExecutionEndState AssemblyExecutionState { get; protected set; }

		public int CurrentEntryIndex { get; protected set; }

		public DateTime LogStartDate { get; protected set; }

		public bool ExecutionStarted { get; protected set; }

		public virtual event EventHandler<LogEntryAddedEventArgs> LogEntryGiven;
		public virtual event EventHandler<LogEntryAddedEventArgs> LogEntryBuilt;
		public virtual event EventHandler<LogEntryAddedEventArgs> LogEntryProcessed;

		#endregion

		#region Fields

		protected readonly Log ParentLog;
		protected LogEntry ExceptionLogEntry;

		protected readonly Stack<LogEntry> ExecSeqStack;
		protected readonly Stack<Stopwatch> FunctionTimersStack;
		protected readonly Stack<int> DurationsStack;

		protected bool ExceptionThrown;
		protected Stopwatch ExecutionTimer;
		
		protected Thread WorkerThread;
		protected BlockingQueue<Action> WorkerQueue;
		private bool isWorker;
		private bool finished;

		#endregion

		#region Constructors

		/// <summary>
		///     Constructor!
		/// </summary>
		/// <param name="maximumLevel">[Optional] The maximum logging level to use, above which, no logs will be saved</param>
		public LoggerBase(LogLevel? maximumLevel = null, [CallerMemberName] string callingFunction = "")
			: this(callingFunction)
		{
			MaxLogLevel = maximumLevel ?? LogLevel.Warning;
		}

		protected LoggerBase([CallerMemberName] string callingFunction = "")
		{
			ExecSeqStack = new Stack<LogEntry>();

			FunctionTimersStack = new Stack<Stopwatch>();
			DurationsStack = new Stack<int>();

			LogStartDate = DateTime.UtcNow;

			CurrentEntryIndex = 1;

			ParentLog =
				new Log
				{
					Name = $"Log-{LogStartDate.ToLocalTime():yyyy_MM_dd-HH_mm_ss_fff}",
					Assembly = Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common"),
					EntryClass = Helpers.GetClassName(-1, "Yagasoft.Libraries.Common"),
					EntryFunction = callingFunction,
					StartDate = LogStartDate,
					ExecutionEndState = ExecutionEndState.Success
				};
		}

		#endregion

		#region Init

		public virtual void SetRegarding(string regardingType, Guid regardingId, string regardingName = "")
		{
			ParentLog.RegardingType = regardingType;
			ParentLog.RegardingId = regardingId;
			ParentLog.RegardingName = regardingName;
		}

		public virtual void SetRegarding(EntityReference regarding)
		{
			regarding.Require(nameof(regarding));
			SetRegarding(regarding.LogicalName, regarding.Id, regarding.Name);
		}

		public virtual void SetTitle(string title)
		{
			ParentLog.Title = title;
		}

		public virtual void SetEntryClass(string entryClass = null)
		{
			ParentLog.EntryClass = entryClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common");
		}

		public virtual void StartWorker()
		{
			if (WorkerThread != null)
			{
				return;
			}

			finished = false;
			WorkerQueue = new();

			WorkerThread =
				new Thread(
					() =>
					{
						while (!finished || WorkerQueue.Any())
						{
							WorkerQueue.Dequeue()();
						}

						WorkerThread = null;
						isWorker = false;
					});
			
			WorkerThread.Start();
			isWorker = true;
		}

		#endregion

		protected virtual void ExecuteAction(Action action)
		{
			if (!ExecutionStarted)
			{
				return;
			}
			
			if (isWorker)
			{
				WorkerQueue.Enqueue(action);
			}
			else
			{
				action();
			}
		}
		
		#region Function start/end logging

		public virtual void LogExecutionStart(string message, [CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			LogExecutionStart(new LogEntry(message), callingFunction, callingLineNumber);
		}

		public virtual void LogExecutionStart(LogEntry logEntry = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			if (MaxLogLevel == LogLevel.None || ExecutionStarted)
			{
				return;
			}

			ExecutionStarted = true;

			ExecuteAction(() => LogExecutionStartInner(logEntry, callingFunction, callingLineNumber));
		}

		protected virtual void LogExecutionStartInner(LogEntry logEntry = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			var defaultMessage = "Started execution: " + callingFunction;

			logEntry = logEntry ?? new LogEntry(defaultMessage);

			// log this at any level
			logEntry.Level = LogLevel.None;

			// set as root in call sequence
			ExecSeqStack.Push(logEntry); 

			if (logEntry.Message.IsEmpty())
			{
				logEntry.Message = defaultMessage;
			}

			// start measuring execution duration
			ExecutionTimer = Stopwatch.StartNew();

			// push a zero-based timestamp
			DurationsStack.Push(0);

			LogInner(logEntry, true, null, callingFunction, callingLineNumber);
		}

		public virtual void LogFunctionStart(string message, [CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			LogFunctionStart(new LogEntry(message), callingFunction, callingLineNumber);
		}

		public virtual void LogFunctionStart(LogEntry logEntry = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			if (MaxLogLevel == LogLevel.None)
			{
				return;
			}

			ExecuteAction(() => LogFunctionStartInner(logEntry, callingFunction, callingLineNumber));
		}

		protected virtual void LogFunctionStartInner(LogEntry logEntry = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			var defaultMessage = "Started: " + callingFunction;

			logEntry = logEntry ?? new LogEntry(defaultMessage);

			// set the parent as the previous in the stack, and set as parent in call sequence for next entries
			logEntry.ParentLogEntry = ExecSeqStack.Peek();
			ExecSeqStack.Push(logEntry);

			if (logEntry.Message.IsEmpty())
			{
				logEntry.Message = defaultMessage;
			}

			logEntry.Level = LogLevel.Debug;

			LogInner(logEntry, true, null, callingFunction, callingLineNumber);

			// start measuring function duration
			FunctionTimersStack.Push(Stopwatch.StartNew());
			ExecutionTimer = ExecutionTimer ?? FunctionTimersStack.Peek(); // keep the first timer to log execution time
			// push a zero-based timestamp
			DurationsStack.Push(0);
		}

		public virtual void LogFunctionEnd(string message, [CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			LogFunctionEnd(new LogEntry(message), callingFunction, callingLineNumber);
		}

		public virtual void LogFunctionEnd(LogEntry logEntry = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			if (MaxLogLevel == LogLevel.None)
			{
				return;
			}

			ExecuteAction(() => LogFunctionEndInner(logEntry, callingFunction, callingLineNumber));
		}

		protected virtual void LogFunctionEndInner(LogEntry logEntry = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			// stop function timer and get the elapsed time
			FunctionTimersStack.Peek().Stop();
			var elapsedTime = (int)FunctionTimersStack.Pop().ElapsedMilliseconds;

			// remove the duration reference of the function
			DurationsStack.Pop();

			var defaultMessage = "Finished: " + callingFunction;

			logEntry ??= new LogEntry(defaultMessage);

			// log this at any level
			logEntry.Level = LogLevel.None;

			// set parent, then remove it from sequence of calls
			ExecSeqStack.Pop();

			if (ExecSeqStack.Any())
			{
				logEntry.ParentLogEntry = ExecSeqStack.Peek();
			}

			if (logEntry.Message.IsEmpty())
			{
				logEntry.Message = defaultMessage;
			}

			logEntry.Level = LogLevel.Debug;

			LogInner(logEntry, true, elapsedTime, callingFunction, callingLineNumber);
		}

		public virtual void LogExecutionEnd(string message, ExecutionEndState state = ExecutionEndState.Success,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			LogExecutionEnd(new LogEntry(message), state, callingFunction, callingLineNumber);
		}

		public virtual void LogExecutionEnd(LogEntry logEntry = null, ExecutionEndState state = ExecutionEndState.Success,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			ExecuteAction(() => LogExecutionEndInner(logEntry, state, callingFunction, callingLineNumber));
				StopWorker();
		}

		protected virtual void LogExecutionEndInner(LogEntry logEntry = null, ExecutionEndState state = ExecutionEndState.Success,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
				if (MaxLogLevel == LogLevel.None)
				{
					return;
				}

				// stop execution timer
				ExecutionTimer.Stop();

				// remove the duration reference of the function
				DurationsStack.Pop();

				AssemblyExecutionState = (AssemblyExecutionState == ExecutionEndState.Failure) ? AssemblyExecutionState : state;

				var defaultMessage = "Finished execution: " + callingFunction;

				logEntry ??= new LogEntry(defaultMessage);

				// log this at any level
				logEntry.Level = LogLevel.None;

				// set parent, then remove it from sequence of calls
				if (ExecSeqStack.Any())
				{
					logEntry.ParentLogEntry = ExecSeqStack.Pop();
				}

				if (logEntry.Message.IsEmpty())
				{
					logEntry.Message = defaultMessage;
				}

				LogInner(logEntry, true, (int)ExecutionTimer.ElapsedMilliseconds, callingFunction, callingLineNumber);

				ExecutionStarted = false;
		}

		private void StopWorker()
		{
			finished = true;
			
			if (isWorker && WorkerThread.IsAlive)
			{
				WorkerQueue.Enqueue(() => {});
				WorkerThread.Join();
			}
		}

		#endregion

		#region Logging Helpers

		public virtual void LogError(string message, string information = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			Log(message, LogLevel.Error, information, callingFunction, callingLineNumber);
		}

		public virtual void LogError(Exception exception, [CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			Log(exception, null, callingFunction, callingLineNumber);
		}

		public virtual void LogWarning(string message, string information = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			Log(message, LogLevel.Warning, information, callingFunction, callingLineNumber);
		}

		public virtual void LogInfo(string message, string information = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			Log(message, LogLevel.Info, information, callingFunction, callingLineNumber);
		}

		public virtual void LogDebug(string message, string information = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			Log(message, LogLevel.Debug, information, callingFunction, callingLineNumber);
		}

		#endregion

		#region Logging

		public virtual void Log(string message, LogLevel level = LogLevel.Info, string information = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			Log(new LogEntry(message, level, information), false, null, callingFunction, callingLineNumber);
		}

		public virtual void Log(Exception exception, string information = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			Log(new LogEntry(exception, exception.Message, information ?? exception.BuildExceptionMessage())
				{
					StackTrace = exception.StackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common")
				}, false, null,
				callingFunction, callingLineNumber);
		}

		public virtual void Log(LogEntry logEntry, bool parent = false, int? elapsedTime = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			if (MaxLogLevel == LogLevel.None)
			{
				return;
			}

			ExecuteAction(() => LogInner(logEntry, parent, elapsedTime, callingFunction, callingLineNumber));
		}

		protected virtual void LogInner(LogEntry logEntry, bool parent = false, int? elapsedTime = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			OnLogEntryGiven(logEntry);

			// set parent of this entry to top of the stack entry
			if (!parent)
			{
				logEntry.Require(nameof(logEntry));
				logEntry.ParentLogEntry = ExecSeqStack.Peek();
			}

			// calculate the duration between the last log entry in this function and this one
			if (logEntry.ElapsedTime == null)
			{
				// get the last recorded duration since function start
				var lastDuration = DurationsStack.Any() ? DurationsStack.Pop() : 0;

				// get the function timer
				var functionDuration = (int)(
					FunctionTimersStack.Any()
						? FunctionTimersStack.Peek().ElapsedMilliseconds
						: ExecutionTimer.ElapsedMilliseconds);

				// add a snapshot
				DurationsStack.Push(functionDuration);

				// calculate the time it took to get from the last recorded entry to this entry
				logEntry.ElapsedTime = functionDuration - lastDuration;
			}
			else
			{
				logEntry.ElapsedTime = elapsedTime;
			}

			logEntry.StartDate = DateTime.UtcNow.AddMilliseconds(-logEntry.ElapsedTime.GetValueOrDefault());

			// exception flag
			if (logEntry.Exception != null)
			{
				ExceptionThrown = true;
				logEntry.ExceptionThrown = true;

				var logEntryTemp = logEntry;

				while ((logEntryTemp = logEntryTemp.ParentLogEntry) != null)
				{
					logEntryTemp.ExceptionThrown = true;
				}
			}

			// increment the log entries index
			logEntry.CurrentEntryIndex = CurrentEntryIndex++;

			// code info
			logEntry.CallingClass = logEntry.CallingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common");
			logEntry.CallingFunction = logEntry.CallingFunction ?? callingFunction;
			logEntry.CallingLineNumber = logEntry.CallingLineNumber ?? callingLineNumber;

			// keep the first entry with an exception to show in root
			ExceptionLogEntry = logEntry.ExceptionThrown ? logEntry : ExceptionLogEntry;

			OnLogEntryBuilt(logEntry);

			ProcessLogEntry(logEntry);
			OnLogEntryProcessed(logEntry);
		}

		public virtual void LogKeyValues(string title, IDictionary<string, object> parameters, LogLevel level = LogLevel.Info,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			parameters.Require(nameof(parameters));
			LogKeyValues(title, parameters.Keys.ToArray(), parameters.Values.ToArray(), level, callingFunction, callingLineNumber);
		}

		public virtual void LogKeyValues(string title, string[] paramNames, object[] paramValues, LogLevel level = LogLevel.Info,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			paramNames.Require(nameof(paramNames));
			paramValues.Require(nameof(paramValues));

			var paramInfoBuilder = new StringBuilder();

			for (var i = 0; i < paramNames.Length; i++)
			{
				if (i != 0)
				{
					paramInfoBuilder.Append("\r\n");
				}

				paramInfoBuilder
					.Append(paramNames[i])
					.Append(" = ")
					.Append(Helpers.GetStringRepresentation(paramValues[i]));
			}

			Log(title, level, paramInfoBuilder.ToString(), callingFunction, callingLineNumber);
		}

		public void LogAttributeValues(Entity labelsRecord, AttributeCollection attributes = null, string entryTitle = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			labelsRecord.Require("labelsRecord");

			attributes = attributes ?? labelsRecord.Attributes;

			var attributesInfo = new StringBuilder();
			attributesInfo.Append("Attribute values (" + attributes.Count + "):");

			foreach (var attribute in attributes.OrderBy(pair => pair.Key))
			{
				attributesInfo.Append($"\r\n    \"{attribute.Key}\""
					+ $" => \"{CrmHelpers.GetAttributeName(attribute.Key, labelsRecord)}\""
					+ $" | \"{CrmHelpers.GetAttributeName(attribute.Value)}\".");
			}

			Log(entryTitle ?? "Entity Object Values", LogLevel.Debug, attributesInfo.ToString(),
				callingFunction, callingLineNumber);
		}

		public virtual void LogLine([CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			if (MaxLogLevel == LogLevel.None)
			{
				return;
			}

			Log("Execution reached line " + callingLineNumber, LogLevel.Debug, null, callingFunction, callingLineNumber);
		}

		public virtual void SetExecutionState(ExecutionEndState state)
		{
			AssemblyExecutionState = state;
		}

		public virtual void ExecutionFailed()
		{
			SetExecutionState(ExecutionEndState.Failure);
		}

		protected void PostBuildLogEntry(LogEntry logEntry)
		{}

		protected abstract void ProcessLogEntry(LogEntry logEntry);

		protected virtual void OnLogEntryGiven(LogEntry e)
		{
			LogEntryGiven?.Invoke(this, BuildEventArgs(e));
		}

		protected virtual void OnLogEntryBuilt(LogEntry e)
		{
			LogEntryBuilt?.Invoke(this, BuildEventArgs(e));
		}

		protected virtual void OnLogEntryProcessed(LogEntry e)
		{
			LogEntryProcessed?.Invoke(this, BuildEventArgs(e));
		}

		protected virtual LogEntryAddedEventArgs BuildEventArgs(LogEntry e)
		{
			return
				new LogEntryAddedEventArgs
				{
					Logger = this,
					Log = ParentLog,
					LogEntry = e
				};
		}

		#endregion
	}

	/// <summary>
	///     Plugin logging.<br />
	///		Author: Ahmed Elsawalhy (Yagasoft.com)<br />
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public class PluginLogger : LoggerBase
	{
		public Guid UserId { get; protected set; }
		public Guid OrganisationId { get; protected set; }

		public IOrganizationService Service { get; protected set; }
		public ITracingService TracingService { get; protected set; }
		public IExecutionContext Context { get; protected set; }
		public bool IsCrmLogEnabled { get; protected set; }

		private readonly Queue<LogEntry> logQueue = new Queue<LogEntry>();
		private string pluginExecInfo;
		private Entity logRecord;
		
		public PluginLogger(IServiceProvider serviceProvider, LogLevel? maximumLevel = null, [CallerMemberName] string callingFunction = "")
			: base(maximumLevel, callingFunction)
		{
			serviceProvider.Require(nameof(serviceProvider));

			Context = (IPluginExecutionContext)serviceProvider.GetService(typeof(IPluginExecutionContext));
			UserId = Context.InitiatingUserId;
			OrganisationId = Context.OrganizationId;

			Service = ((IOrganizationServiceFactory)serviceProvider.GetService(typeof(IOrganizationServiceFactory)))
				.CreateOrganizationService(null);
			TracingService = (ITracingService)serviceProvider.GetService(typeof(ITracingService));

			InitialiseLog(maximumLevel, callingFunction);
		}
		
		public PluginLogger(ActivityContext activityContext, LogLevel? maximumLevel = null, [CallerMemberName] string callingFunction = "")
			: base(maximumLevel, callingFunction)
		{
			activityContext.Require(nameof(activityContext));

			Context = activityContext.GetExtension<IWorkflowContext>();
			UserId = Context.InitiatingUserId;
			OrganisationId = Context.OrganizationId;

			Service = activityContext.GetExtension<IOrganizationServiceFactory>().CreateOrganizationService(null);
			TracingService = activityContext.GetExtension<ITracingService>();

			InitialiseLog(maximumLevel, callingFunction);
		}

		private void InitialiseLog(LogLevel? maximumLevel = null, [CallerMemberName] string callingFunction = "")
		{
			LogStartDate = DateTime.UtcNow;
			CurrentEntryIndex = 1;

			var config = GetConfiguration();

			IsCrmLogEnabled = config?.IsCrmLogEnabled == true;
			MaxLogLevel = maximumLevel ?? config?.LogLevel ?? LogLevel.Warning;

			if (!IsCrmLogEnabled)
			{
				TracingService?.Trace("CRM log disabled in Common Config.");
			}

			// if assembly is excluded, then turn off logging
			if (config?.AssemblyFilter.IsFilled() == true)
			{
				var isAssemblyIncluded = Regex
					.IsMatch(Helpers
						.GetAssemblyName(-1, "Yagasoft.Libraries.Common"), config.AssemblyFilter);
				MaxLogLevel = isAssemblyIncluded ? MaxLogLevel : LogLevel.None;
			}

			if (config?.AssemblyExclusion.IsFilled() == true)
			{
				var isAssemblyExcluded = Regex
					.IsMatch(Helpers
						.GetAssemblyName(-1, "Yagasoft.Libraries.Common"), config.AssemblyExclusion);
				MaxLogLevel = isAssemblyExcluded ? LogLevel.None : MaxLogLevel;
			}

			if (UserId == Guid.Empty && Service != null && MaxLogLevel != LogLevel.None)
			{
				UserId = ((WhoAmIResponse)Service.Execute(new WhoAmIRequest())).UserId;
			}

			ParentLog.UserId = UserId;

			if (Context != null && IsCrmLogEnabled)
			{
				LogExecutionStart((LogEntry)null, ParentLog.EntryFunction, 0);
			}

			InitLogRecord();

			LogEntryGiven +=
				(sender, args) =>
				{
					if (!ExecutionStarted)
					{
						LogExecutionStart((LogEntry)null, ParentLog.EntryFunction, 0);
					}
				};

			if (MaxLogLevel == LogLevel.None)
			{
				TracingService?.Trace($"Max log level has been determined as {MaxLogLevel}.");
			}
		}

		public override void SetExecutionState(ExecutionEndState state)
		{
			base.SetExecutionState(state);

			// plugin context
			if (pluginExecInfo == null && Context != null && IsCrmLogEnabled)
			{
				pluginExecInfo =
					state == ExecutionEndState.Failure && Service != null
						? PluginInfo.GetPluginExecutionInfo(Context, Service)
						: PluginInfo.GetPluginExecutionInfo(Context);
				Log("Plugin context info.", LogLevel.Debug, pluginExecInfo, ParentLog.EntryFunction, 0);
			}
		}

		public override void LogExecutionEnd(LogEntry logEntry = null, ExecutionEndState state = ExecutionEndState.Success,
			string callingFunction = "", int callingLineNumber = 0)
		{
			base.LogExecutionEnd(logEntry, state, callingFunction, callingLineNumber);
			FinaliseLogRecord();
			Flush();
		}

		private LogConfiguration GetConfiguration()
		{
			if (Service == null)
			{
				return null;
			}

			var config = CrmHelpers.GetGenericConfig(Service, OrganisationId);

			return config == null
				? null
				: new LogConfiguration
				  {
					  IsCrmLogEnabled = config.GetAttributeValue<bool?>("ys_iscrmlogenabled").GetValueOrDefault(),
					  LogLevel = (LogLevel)(config.GetAttributeValue<OptionSetValue>("ys_loglevel")
						  ?? new OptionSetValue((int)LogLevel.Warning)).Value,
					  AssemblyFilter = config.GetAttributeValue<string>("ys_assemblyfilter"),
					  AssemblyExclusion = config.GetAttributeValue<string>("ys_assemblyexclusion")
				  };
		}

		private void InitLogRecord()
		{
			var stage = (Context as IPluginExecutionContext)?.Stage;

			logRecord =
				new Entity("ys_log")
				{
					["ys_correlationid"] = Context?.CorrelationId.ToString().ToUpper(),
					["ys_businessunitid"] = Context?.BusinessUnitId.ToString().ToUpper(),
					["ys_depth"] = Context?.Depth,
					["ys_messagename"] = Context?.MessageName,
					["ys_isolationmodevalue"] = Context?.IsolationMode == null ? null : new OptionSetValue(Context.IsolationMode),
					["ys_stagevalue"] = stage == null ? null : new OptionSetValue(stage.Value),
					["ys_modevalue"] = Context?.Mode == null ? null : new OptionSetValue(Context.Mode),
					["ys_operationid"] = Context?.OperationId.ToString().ToUpper()
				};
		}

		private void FinaliseLogRecord()
		{
			logRecord["ys_name"] = ParentLog.Name;
			logRecord["ys_title"] = ParentLog.Title;
			logRecord["ys_assembly"] = ParentLog.Assembly;
			logRecord["ys_entryclass"] = ParentLog.EntryClass;
			logRecord["ys_entryfunction"] = ParentLog.EntryFunction;
			logRecord["ys_startdate"] = ParentLog.StartDate;
			logRecord["ys_user"] = new EntityReference("systemuser", ParentLog.UserId.GetValueOrDefault());
			logRecord["ys_executionendstate"] = new OptionSetValue((int)AssemblyExecutionState);
			logRecord["ys_executionduration"] = (int)ExecutionTimer.ElapsedMilliseconds;
			logRecord["ys_exceptionthrown"] = ExceptionThrown;
			logRecord["ys_regardingtype"] = ParentLog.RegardingType ?? Context?.PrimaryEntityName;
			logRecord["ys_regardingid"] = (ParentLog.RegardingId ?? Context?.PrimaryEntityId).ToString().ToUpper();
			logRecord["ys_regardingname"] = ParentLog.RegardingName;
		}
		
		protected override void ProcessLogEntry(LogEntry logEntry)
		{
			if (logEntry.Level > LogLevel.None && logEntry.Level <= MaxLogLevel)
			{
				TracingService?.Trace(GetTraceServiceFormattedEntry(logEntry));
			}

			if (logEntry.ExceptionThrown)
			{
				ExceptionLogEntry = logEntry;
			}

			logQueue.Enqueue(logEntry);
		}

		private string GetTraceServiceFormattedEntry(LogEntry logEntry)
		{
			try
			{
				var stringBuilder = new StringBuilder();

				////stringBuilder.Append($"Start date: {logEntry.StartDate.GetValueOrDefault().ToLocalTime()}");
				////stringBuilder.AppendFormat("\r\nLog level: {0}", logEntry.Level);
				////stringBuilder.AppendFormat("\r\nDuration: {0} ms", logEntry.ElapsedTime);
				////stringBuilder.AppendFormat("\r\nClass: {0}", logEntry.CallingClass.Split('.').LastOrDefault());
				////stringBuilder.AppendFormat("\r\nMethod: {0}", logEntry.CallingFunction);
				////stringBuilder.AppendFormat("\r\nLine: {0}", logEntry.CallingLineNumber);

				if (logEntry.Exception == null)
				{
					if (logEntry.Level != LogLevel.Info)
					{
						stringBuilder.Append($"[{logEntry.Level}] ");
					}

					stringBuilder.Append($"{logEntry.Message}"
						+ $" | {logEntry.ElapsedTime} ms"
						+ $" | {logEntry.CallingClass?.Split('.').LastOrDefault()}"
						+ $".{logEntry.CallingFunction} at {logEntry.CallingLineNumber}");
				}
				else
				{
					stringBuilder.Append($"\r\n-- START ** EXCEPTION -"
						+ $"\r\n{logEntry.Exception.BuildExceptionMessage()}"
						+ $"\r\n-- END ** EXCEPTION -");
				}

				return stringBuilder.ToString();
			}
			catch (Exception e)
			{
				return $"Logger error:\r\n{e}";
			}
		}

		private void Flush()
		{
			TracingService?.Trace("Flushing log entries ...");

			if (!IsCrmLogEnabled || MaxLogLevel == LogLevel.None
				|| logQueue.All(entry => entry.Level == LogLevel.None)
				|| (logQueue.All(entry => entry.Level == LogLevel.None || entry.Level > MaxLogLevel)
					&& AssemblyExecutionState != ExecutionEndState.Failure))
			{
				TracingService?.Trace("No log entries.");
				return;
			}

			var requests = new List<OrganizationRequest>();
			var serialisedLogEntries = new StringBuilder();

			TracingService?.Trace($"{logQueue.Count} log entries.");

			while (logQueue.Count > 0)
			{
				var logEntry = logQueue.Dequeue();

				// if the log entry's level is above the maximum, then no need to log it
				// unless the execution failed
				if (logEntry.Level > MaxLogLevel
					&& AssemblyExecutionState != ExecutionEndState.Failure)
				{
					continue;
				}

				serialisedLogEntries.Append("<|||>").Append(EntitySerializer.SerializeObject(CreateEntryEntity(logEntry)));
			}

			logRecord["ys_serialisedlogentries"] = serialisedLogEntries.ToString().Compress();
			requests.Add(new CreateRequest { Target = logRecord });
			var response = CrmHelpers.ExecuteBulk(Service, requests, true);
			var fault = response.Values.FirstOrDefault()?.Fault.BuildFaultMessage();

			if (fault.IsFilled())
			{
				TracingService?.Trace($"Failed to create log:");
				TracingService?.Trace(fault);
			}
		}

		/// <summary>
		///     Creates an entity containing the log entry data
		/// </summary>
		/// <param name="logEntry">The log entry.</param>
		/// <returns>The CRM entity object including all info in the log entry object</returns>
		private Entity CreateEntryEntity(LogEntry logEntry)
		{
			var target =
				new Entity("ys_logentry")
				{
					Id = logEntry.Id,
					["ys_name"] = BuildLogId(logEntry),
					["ys_message"] = logEntry.Message,
					["ys_entryindex"] = logEntry.CurrentEntryIndex,
					["ys_startdate"] = logEntry.StartDate,
					["ys_regardingtype"] = logEntry.RegardingType,
					["ys_regardingname"] = logEntry.RegardingName,
					["ys_stacktrace"] = logEntry.StackTrace
				};

			if (logEntry.Exception != null)
			{
				if (logEntry.Message.IsEmpty())
				{
					target["ys_message"] = logEntry.Message = "Exception: " + logEntry.Exception.Message;
				}

				target["ys_exception"] = logEntry.Exception.GetType().Name;
				target["ys_exceptionsource"] = logEntry.Exception.Source;
				target["ys_stacktrace"] = logEntry.Exception.StackTrace;

				if (logEntry.Exception.InnerException != null)
				{
					target["ys_innerexception"] = logEntry.Exception.InnerException.GetType().Name;
					target["ys_innerexceptionmessage"] = logEntry.Exception.InnerException.Message;
					target["ys_innerexceptionsource"] = logEntry.Exception.InnerException.Source;
					target["ys_innerexceptionstacktrace"] = logEntry.Exception.InnerException.StackTrace;
				}
			}

			target["ys_exceptionthrown"] = logEntry.ExceptionThrown;

			target["ys_level"] = new OptionSetValue((int)logEntry.Level);

			if (logEntry.UserId.HasValue)
			{
				target["ys_user"] = new EntityReference("systemuser", logEntry.UserId.Value);
			}
			else if (UserId != Guid.Empty)
			{
				target["ys_user"] = new EntityReference("systemuser", UserId);
			}

			target["ys_assembly"] = logEntry.Assembly ?? Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common");
			target["ys_class"] = logEntry.CallingClass;
			target["ys_callingfunction"] = logEntry.CallingFunction;
			target["ys_linenumber"] = logEntry.CallingLineNumber;

			if (logEntry.ElapsedTime > -1)
			{
				target["ys_executionduration"] = logEntry.ElapsedTime;
			}

			target["ys_information"] = logEntry.Information;

			if (logEntry.ParentLogEntry != null)
			{
				target["ys_parentlogentryid"] = new EntityReference("ys_logentry", logEntry.ParentLogEntry.Id);
			}

			return target;
		}

		private static string BuildLogId(LogEntry logEntry)
		{
			return $"LogEntry-{logEntry.StartDate?.ToLocalTime() ?? DateTime.Now:yyyy_MM_dd-HH_mm_ss_fff}";
		}

		private class LogConfiguration
		{
			internal bool IsCrmLogEnabled { get; set; }

			internal LogLevel LogLevel { get; set; }

			internal string AssemblyFilter { get; set; }

			internal string AssemblyExclusion { get; set; }
		}
	}

	#endregion

	#region Plugin classes

	public enum PluginStage
	{
		All,
		PreValidation = 10,
		PreOperation = 20,
		PostOperation = 40
	}

	public enum PluginMode
	{
		Synchronous = 0,
		Asynchronous = 1,
		Both = 2
	}

	public enum PluginIsolationMode
	{
		None = 1,
		Sandbox = 2,
		External = 3
	}

	/// <summary>
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public interface IPluginContext
	{
		IPlugin Plugin { get; }
		CodeActivity CodeActivity { get; }

		IServiceProvider ServiceProvider { get; }
		CodeActivityContext ExecutionContext { get; }

		IExecutionContext Context { get; }
		IOrganizationServiceFactory ServiceFactory { get; }
		ITracingService TracingService { get; }
		IOrganizationService Service { get; }
		IOrganizationService EscalatedService { get; }

		string Message { get; }
		PluginStage Stage { get; }
		
		Guid UserId { get; }
		Guid EscalationUserId { get; }
		Guid OrgId { get; }

		string Entity { get; }
		Guid Id { get; }

		ILogger Log { get; }

		Entity PreImage { get; }
		Entity Target { get; }
		Entity PostImage { get; }
	}

	/// <summary>
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public abstract class PluginLogic<TPlugin> : IPluginContext
		where TPlugin : IPlugin
	{
		public virtual IPlugin Plugin => plugin;
		public virtual CodeActivity CodeActivity => throw new NotSupportedException("Not supported in IPlugins.");
		public virtual CodeActivityContext ExecutionContext => throw new NotSupportedException("Not supported in IPlugins.");

		public virtual IServiceProvider ServiceProvider
		{
			get
			{
				serviceProvider.Require(nameof(serviceProvider));
				return serviceProvider;
			}
		}

		public virtual IExecutionContext Context =>
			context ??= (IPluginExecutionContext)ServiceProvider.GetService(typeof(IPluginExecutionContext));

		public virtual IOrganizationServiceFactory ServiceFactory =>
				serviceFactory ??= (IOrganizationServiceFactory)ServiceProvider.GetService(typeof(IOrganizationServiceFactory));

		public virtual ITracingService TracingService =>
			tracingService ??= (ITracingService)ServiceProvider.GetService(typeof(ITracingService));

		public virtual IOrganizationService Service =>
			service ??= ServiceFactory.CreateOrganizationService(UserId);
		public virtual IOrganizationService EscalatedService =>
			escalatedService ??= ServiceFactory.CreateOrganizationService(EscalationUserId);

		public virtual string Message => Context.MessageName;
		public virtual PluginStage Stage => (PluginStage)((IPluginExecutionContext)Context).Stage;
		
		public virtual Guid UserId => userId ??= Context.UserId;

		public virtual Guid EscalationUserId => escalationUserId
			??= (escalationUserId = CrmHelpers.GetGenericConfig(Service, Context.OrganizationId)
				.GetAttributeValue<EntityReference>("ys_escalationuserid")?.Id)
				?? throw new ArgumentNullException(nameof(EscalationUserId), "Escalation User is not set in Common Configuration.");

		public virtual Guid OrgId => orgId ??= Context.OrganizationId;

		public virtual string Entity => Context.PrimaryEntityName;
		public virtual Guid Id => Context.PrimaryEntityId;

		public virtual ILogger Log => log;

		public virtual Entity PreImage => preImage ??= GetPreImage<Entity>();
		public virtual Entity Target => target ??= GetTarget<Entity>();
		public virtual Entity PostImage
		{
			get
			{
				try
				{
					return postImage ??= GetPostImage<Entity>();
				}
				catch
				{
					try
					{
						return postImage ??= BuildPostFromPreImage<Entity>();
					}
					catch
					{
						throw new InvalidPluginExecutionException("Missing a post-image for this step.");
					}
				}
			}
		}

		protected readonly string intendedPluginMessage;
		protected readonly PluginStage intendedPluginStage;
		protected readonly string intendedEntity;

		private TPlugin plugin;

		private IServiceProvider serviceProvider;
		private IPluginExecutionContext context;
		private IOrganizationServiceFactory serviceFactory;
		private ITracingService tracingService;
		private IOrganizationService service;
		private IOrganizationService escalatedService;

		private Guid? userId;
		private Guid? escalationUserId;
		private Guid? orgId;

		protected ILogger log;

		private Entity preImage;
		private Entity target;
		private Entity postImage;

		protected PluginLogic(string intendedPluginMessage, PluginStage intendedPluginStage, string intendedEntity = null)
		{
			this.intendedPluginMessage = intendedPluginMessage;
			this.intendedPluginStage = intendedPluginStage;
			this.intendedEntity = intendedEntity;
		}

		public virtual void Execute(TPlugin plugin, IServiceProvider serviceProvider)
		{
			Execute(plugin, serviceProvider, PluginUser.System);
		}

		public virtual void Execute(TPlugin plugin, IServiceProvider serviceProvider, bool isLogEnabled)
		{
			Execute(plugin, serviceProvider, PluginUser.System, null, isLogEnabled);
		}

		public virtual void Execute(TPlugin plugin, IServiceProvider serviceProvider, Guid? userId,
			bool isLogEnabled = true)
		{
			Execute(plugin, serviceProvider, PluginUser.Custom, userId, isLogEnabled);
		}

		public virtual void Execute(TPlugin plugin, IServiceProvider serviceProvider, PluginUser user,
			bool isLogEnabled = true)
		{
			Execute(plugin, serviceProvider, user, null, isLogEnabled);
		}

		public virtual void Execute(TPlugin plugin, IServiceProvider serviceProvider, PluginUser user, Guid? userId,
			bool isLogEnabled = true)
		{
			this.plugin = plugin;
			this.serviceProvider = serviceProvider;
			this.userId = userId;

			InitialisePlugin(user);

			try
			{
				TracingService.Trace("Initialising CRM Log ...");
				log = new PluginLogger(serviceProvider);

				if (isLogEnabled)
				{
					TracingService.Trace("Log is enabled in the code.");

					Log.SetEntryClass(typeof(TPlugin).FullName);

					if (Context.PrimaryEntityName != null && Context.PrimaryEntityName != "none"
						&& Context.PrimaryEntityId != Guid.Empty)
					{
						Log.SetRegarding(Context.PrimaryEntityName, Context.PrimaryEntityId);
					}
				}
				else
				{
					TracingService.Trace("Log is disabled in the code.");
				}
			}
			catch (Exception ex)
			{
				TracingService.Trace("Failed to init log.");
				TracingService.Trace(CrmHelpers.BuildExceptionMessage(ex));
				throw new InvalidPluginExecutionException("Failed to init log => " + ex.Message, ex);
			}

			try
			{
				if (isLogEnabled)
				{
					Log.LogExecutionStart();
				}

				TracingService.Trace("Loading custom messages ...");
				MessageHelpers.LoadCustomMessages(service, OrgId);
				TracingService.Trace("Finished loading custom messages.");

				TracingService.Trace("Executing plugin logic ...");
				ExecuteLogic();
				TracingService.Trace("Finished executing plugin logic.");
			}
			catch (Exception ex)
			{
				TracingService.Trace($"Exception occurred: {ex.Message}.");

				if (isLogEnabled)
				{
					Log.ExecutionFailed();
					Log.Log(ex);
				}
				else
				{
					TracingService.Trace(CrmHelpers.BuildExceptionMessage(ex));
				}

				throw new InvalidPluginExecutionException(ex.Message, ex);
			}
			finally
			{
				if (isLogEnabled)
				{
					TracingService.Trace("Logging execution end ...");

					try
					{
						Log.LogExecutionEnd();
					}
					catch (Exception e)
					{
						TracingService.Trace(CrmHelpers.BuildExceptionMessage(e));
						throw;
					}
				}

				TracingService.Trace("Finished executing plugin.");
			}
		}

		protected abstract void ExecuteLogic();

		protected TEntity GetPreImage<TEntity>() where TEntity : Entity
		{
			var image = Message == "Create" ? Target : Context.PreEntityImages.FirstOrDefault().Value;

			if (image == null)
			{
				throw new InvalidPluginExecutionException("Missing a pre-image for this step.");
			}

			return image.ToEntity<TEntity>();
		}

		protected TEntity GetTarget<TEntity>() where TEntity : Entity
		{
			if (Context.InputParameters.TryGetValue("Target", out var target) && target is Entity targetEntity)
			{
				return targetEntity.ToEntity<TEntity>();
			}

			throw new InvalidPluginExecutionException("Missing Target in the plugin input, or not of type Entity.");
		}

		protected EntityReference GetTargetReference()
		{
			if (Context.InputParameters.TryGetValue("Target", out var target) && target is EntityReference targetEntityRef)
			{
				return targetEntityRef;
			}

			throw new InvalidPluginExecutionException("Missing Target in the plugin input, or not of type EntityReference.");
		}

		protected TEntity BuildPostFromPreImage<TEntity>() where TEntity : Entity
		{
			var preImage = GetPreImage<TEntity>();
			var target = GetTarget<TEntity>();
			var postImage = new Entity(target.LogicalName, target.Id);

			foreach (var pair in preImage.Attributes)
			{
				postImage[pair.Key] = pair.Value;
			}

			foreach (var pair in preImage.FormattedValues)
			{
				postImage.FormattedValues[pair.Key] = pair.Value;
			}

			foreach (var pair in target.Attributes)
			{
				postImage[pair.Key] = pair.Value;
			}

			foreach (var pair in target.FormattedValues)
			{
				postImage.FormattedValues[pair.Key] = pair.Value;
			}

			return postImage.ToEntity<TEntity>();
		}

		protected TEntity GetPostImage<TEntity>() where TEntity : Entity
		{
			var image = Message == "Create"
				? Target
				: Message == "Delete"
					? GetPreImage<TEntity>()
					: context.Stage == (int)PluginStage.PostOperation
						? Context.PostEntityImages.FirstOrDefault().Value
						: BuildPostFromPreImage<TEntity>();

			if (image == null)
			{
				throw new InvalidPluginExecutionException("Missing a post-image for this step.");
			}

			return image.ToEntity<TEntity>();
		}

		protected virtual bool IsContextValid()
		{
			return true;
		}

		protected virtual void ValidateRegistration()
		{
			if (!string.IsNullOrWhiteSpace(intendedEntity) && Context.PrimaryEntityName != intendedEntity)
			{
				throw new InvalidPluginExecutionException(
					$"Step registered on wrong entity: {Context.PrimaryEntityName}, "
						+ $"expected: {intendedEntity}");
			}

			if (!string.IsNullOrWhiteSpace(intendedPluginMessage) && Context.MessageName != intendedPluginMessage)
			{
				throw new InvalidPluginExecutionException(
					$"Step registered on wrong message: {Context.MessageName}, "
						+ $"expected: {intendedPluginMessage}.");
			}

			var pluginContext = (IPluginExecutionContext)Context;

			if (intendedPluginStage != PluginStage.All && pluginContext.Stage != (int)intendedPluginStage)
			{
				throw new InvalidPluginExecutionException(
					$"Step registered on wrong stage: {pluginContext.Stage}, "
						+ $"expected: {intendedPluginStage}");
			}
		}

		protected void InitialisePlugin(PluginUser user = PluginUser.System)
		{
			tracingService = (ITracingService)ServiceProvider.GetService(typeof(ITracingService));

			TracingService.Trace("Getting context ...");
			context = (IPluginExecutionContext)ServiceProvider.GetService(typeof(IPluginExecutionContext));
			ValidateRegistration();

			TracingService.Trace("Getting factory ...");
			serviceFactory = (IOrganizationServiceFactory)ServiceProvider.GetService(typeof(IOrganizationServiceFactory));

			switch (user)
			{
				case PluginUser.ContextUser:
					TracingService.Trace("Running as ContextUser.");
					userId = Context.UserId;
					break;

				case PluginUser.InitiatingUser:
					TracingService.Trace("Running as InitiatingUserId.");
					userId = Context.InitiatingUserId;
					break;

				case PluginUser.System:
					TracingService.Trace("Running as System.");
					userId = null;
					break;

				case PluginUser.Custom:
					TracingService.Trace($"Running as {userId}.");
					break;

				default:
					throw new ArgumentOutOfRangeException("user", user, "Plugin user type is out of range.");
			}

			TracingService.Trace("Getting service ...");
			service = ServiceFactory.CreateOrganizationService(userId);

			if (!IsContextValid())
			{
				throw new InvalidPluginExecutionException("Failed to initialise plugin due to invalid context.");
			}

			TracingService.Trace($"Initialised plugin.");
		}
	}

	/// <summary>
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public abstract class StepLogic<TCodeActivity> : IPluginContext
		where TCodeActivity : CodeActivity
	{
		public virtual IPlugin Plugin => throw new NotSupportedException("Not supported in Code Activities.");
		public virtual CodeActivity CodeActivity => codeActivity;

		public virtual IServiceProvider ServiceProvider => throw new NotSupportedException("Not supported in Code Activities.");

		public virtual CodeActivityContext ExecutionContext
		{
			get
			{
				executionContext.Require(nameof(executionContext));
				return executionContext;
			}
		}

		public virtual IExecutionContext Context => context ??= ExecutionContext.GetExtension<IWorkflowContext>();
		public virtual IOrganizationServiceFactory ServiceFactory => 
			serviceFactory ??= ExecutionContext.GetExtension<IOrganizationServiceFactory>();
		public virtual ITracingService TracingService =>
			tracingService ??= ExecutionContext.GetExtension<ITracingService>();

		public virtual IOrganizationService Service => 
			service ??= ServiceFactory.CreateOrganizationService(UserId);
		public virtual IOrganizationService EscalatedService => 
			escalatedService ??= ServiceFactory.CreateOrganizationService(EscalationUserId);

		public virtual string Message => Context.MessageName;
		public virtual PluginStage Stage => throw new NotSupportedException("Not supported in Code Activities.");
		public virtual Guid UserId => userId ??= Context.UserId;

		public virtual Guid EscalationUserId => escalationUserId
			??= (escalationUserId = CrmHelpers.GetGenericConfig(Service, Context.OrganizationId)
				.GetAttributeValue<EntityReference>("ys_escalationuserid")?.Id)
				?? throw new ArgumentNullException(nameof(EscalationUserId), "Escalation User is not set in Common Configuration.");
		
		public virtual Guid OrgId => orgId ??= Context.OrganizationId;

		public virtual string Entity => Context.PrimaryEntityName;
		public virtual Guid Id => Context.PrimaryEntityId;

		public virtual ILogger Log => log;

		public virtual Entity PreImage => preImage ??= GetPreImage<Entity>();
		public virtual Entity Target => target ??= GetTarget<Entity>();
		public virtual Entity PostImage
		{
			get
			{
				try
				{
					return postImage ??= GetPostImage<Entity>(true);
				}
				catch
				{
					throw new InvalidPluginExecutionException("Missing a post-image for this step.");
				}
			}
		}

		protected TCodeActivity codeActivity;

		private CodeActivityContext executionContext;
		private IWorkflowContext context;
		private IOrganizationServiceFactory serviceFactory;
		private ITracingService tracingService;
		private IOrganizationService service;
		private IOrganizationService escalatedService;

		private Guid? userId;
		private Guid? escalationUserId;
		private Guid? orgId;

		protected ILogger log;

		private Entity preImage;
		private Entity target;
		private Entity postImage;

		public virtual void Execute(TCodeActivity codeActivity, CodeActivityContext executionContext)
		{
			Execute(codeActivity, executionContext, PluginUser.System);
		}

		public virtual void Execute(TCodeActivity codeActivity, CodeActivityContext executionContext,
			bool isLogEnabled)
		{
			Execute(codeActivity, executionContext, PluginUser.System, null, isLogEnabled);
		}

		public virtual void Execute(TCodeActivity codeActivity, CodeActivityContext executionContext,
			Guid? userId, bool isLogEnabled = true)
		{
			Execute(codeActivity, executionContext, PluginUser.Custom, userId, isLogEnabled);
		}

		public virtual void Execute(TCodeActivity codeActivity, CodeActivityContext executionContext,
			PluginUser user, bool isLogEnabled = true)
		{
			Execute(codeActivity, executionContext, user, null, isLogEnabled);
		}

		public virtual void Execute(TCodeActivity codeActivity, CodeActivityContext executionContext,
			PluginUser user, Guid? userId, bool isLogEnabled = true)
		{
			this.codeActivity = codeActivity;
			this.executionContext = executionContext;
			this.userId = userId;

			InitialiseCodeActivity(user);

			try
			{
				TracingService.Trace("Initialising CRM Log ...");
				log = new PluginLogger(ExecutionContext);

				if (isLogEnabled)
				{
					TracingService.Trace("Log enabled.");

					Log.SetEntryClass(typeof(TCodeActivity).FullName);

					if (Context.PrimaryEntityName != null && Context.PrimaryEntityName != "none"
						&& Context.PrimaryEntityId != Guid.Empty)
					{
						Log.SetRegarding(Context.PrimaryEntityName, Context.PrimaryEntityId);
					}
				}
			}
			catch (Exception ex)
			{
				TracingService.Trace("Failed to init log.");
				TracingService.Trace(CrmHelpers.BuildExceptionMessage(ex));
				throw new InvalidPluginExecutionException("Failed to init Log => " + ex.Message, ex);
			}

			try
			{
				if (isLogEnabled)
				{
					Log.LogExecutionStart();
				}

				TracingService.Trace("Loading custom messages ...");
				MessageHelpers.LoadCustomMessages(service, OrgId);
				TracingService.Trace("Finished loading custom messages.");

				TracingService.Trace("Executing step logic ...");
				ExecuteLogic();
				TracingService.Trace("Finished executing step.");
			}
			catch (Exception ex)
			{
				TracingService.Trace($"Exception occurred: {ex.Message}.");

				if (isLogEnabled)
				{
					Log.ExecutionFailed();
					Log.Log(ex);
				}
				else
				{
					TracingService.Trace(CrmHelpers.BuildExceptionMessage(ex));
				}

				throw new InvalidPluginExecutionException(ex.Message, ex);
			}
			finally
			{
				if (isLogEnabled)
				{
					TracingService.Trace("Logging execution end ...");

					try
					{
						Log.LogExecutionEnd();
					}
					catch (Exception e)
					{
						TracingService.Trace(CrmHelpers.BuildExceptionMessage(e));
						throw;
					}
				}

				TracingService.Trace("Finished executing step.");
			}
		}

		protected abstract void ExecuteLogic();

		protected TEntity GetPreImage<TEntity>() where TEntity : Entity
		{
			if (Context.PreEntityImages.TryGetValue("PreBusinessEntity", out var image))
			{
				return image.ToEntity<TEntity>();
			}

			throw new InvalidPluginExecutionException("Missing a pre-image for this step.");
		}

		protected TEntity GetTarget<TEntity>() where TEntity : Entity
		{
			throw new InvalidPluginExecutionException("The Target parameter should not be accessed in a step.");
		}

		protected TEntity GetPostImage<TEntity>(bool retrieveIfMissing = false, ColumnSet columns = null) where TEntity : Entity
		{
			if (Context.PostEntityImages.TryGetValue("PostBusinessEntity", out var image))
			{
				return image.ToEntity<TEntity>();
			}

			if (retrieveIfMissing)
			{
				return service.Retrieve(Context.PrimaryEntityName, Context.PrimaryEntityId, columns == null ? new ColumnSet(true) : columns)
					.ToEntity<TEntity>();
			}

			throw new InvalidPluginExecutionException("Missing a post-image for this step.");
		}

		protected TEntity GetPostPreImage<TEntity>(bool retrieveIfMissing = false, ColumnSet columns = null) where TEntity : Entity
		{
			if (Context.PostEntityImages.TryGetValue("PostBusinessEntity", out var image))
			{
				return image.ToEntity<TEntity>();
			}

			if (Context.PreEntityImages.TryGetValue("PreBusinessEntity", out image))
			{
				return image.ToEntity<TEntity>();
			}

			if (retrieveIfMissing)
			{
				return service.Retrieve(Context.PrimaryEntityName, Context.PrimaryEntityId, columns == null ? new ColumnSet(true) : columns)
					.ToEntity<TEntity>();
			}

			throw new InvalidPluginExecutionException("Missing a post or pre-image for this step.");
		}

		protected virtual bool IsContextValid()
		{
			return true;
		}

		protected void InitialiseCodeActivity(PluginUser user = PluginUser.System)
		{
			tracingService = ExecutionContext.GetExtension<ITracingService>();
			context = ExecutionContext.GetExtension<IWorkflowContext>();
			TracingService.Trace("Got context.");
			serviceFactory = ExecutionContext.GetExtension<IOrganizationServiceFactory>();
			TracingService.Trace("Got factory.");

			switch (user)
			{
				case PluginUser.ContextUser:
					userId = context.UserId;
					TracingService.Trace("Running as ContextUser.");
					break;

				case PluginUser.InitiatingUser:
					userId = context.InitiatingUserId;
					TracingService.Trace("Running as InitiatingUserId.");
					break;

				case PluginUser.System:
					userId = null;
					TracingService.Trace("Running as System.");
					break;

				case PluginUser.Custom:
					TracingService.Trace($"Running as {userId}.");
					break;

				default:
					throw new ArgumentOutOfRangeException("user", user, "Step user type is out of range.");
			}

			service = ServiceFactory.CreateOrganizationService(userId);
			TracingService.Trace("Got service.");

			if (!IsContextValid())
			{
				throw new InvalidPluginExecutionException("Failed to initialise workflow step due to invalid context.");
			}

			TracingService.Trace($"Initialised step.");
		}
	}

	#endregion
}

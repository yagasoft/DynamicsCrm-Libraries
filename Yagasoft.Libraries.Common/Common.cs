// This file isn't generated, but this comment is necessary to exclude it from StyleCop analysis.
// Author: Ahmed Elsawalhy (Yagasoft.com)
// Version: 7.1.3
// <auto-generated />

#region Imports

using System;
using System.Activities;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Data;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Reflection;
using System.Runtime.Caching;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using System.Runtime.Serialization.Json;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Web;
using System.Xml;
using System.Xml.Serialization;
using Microsoft.Crm.Sdk.Messages;
using Microsoft.Xrm.Sdk;
using Microsoft.Xrm.Sdk.Client;
using Microsoft.Xrm.Sdk.Messages;
using Microsoft.Xrm.Sdk.Metadata;
using Microsoft.Xrm.Sdk.Metadata.Query;
using Microsoft.Xrm.Sdk.Query;
using Microsoft.Xrm.Sdk.Workflow;

using Match = System.Text.RegularExpressions.Match;
using RelationshipType = Microsoft.Xrm.Sdk.Metadata.RelationshipType;

#endregion

namespace Yagasoft.Libraries.Common
{

	#region Enums

	/// <summary>
	///     The log levels
	/// </summary>
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public enum LogLevel
	{
		None = 0,
		Error = 10,
		Warning = 20,
		Info = 30,
		Debug = 40
	}

	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public enum PluginUser
	{
		ContextUser,
		InitiatingUser,
		System,
		Custom
	}

	#endregion

	#region Extensions

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static partial class Extensions
	{
		private const string StringExceptionMsg = "String value cannot be empty.";
		private const string DefaultStringFormatExceptionMsg = "String format is invalid.";
		private const string DefaultNullExceptionMessage = "Value cannot be null.";
		private const string DefaultRangeMessage = "Parameter value out of range.";
		private const string DefaultArrayMemberMessage = "Array member can't be null.";
		private const string DefaultParameterName = "Unknown";
		private const string RegexEscapes = @"[\a\b\f\n\r\t\v\\""]";

		/// <summary>
		/// Return the distinct values of the source collection using the key returned by a selector function.<br />
		/// Credit: https://stackoverflow.com/a/24823445/1919456<br />
		/// </summary>
		public static IEnumerable<TSource> DistinctBy<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> selector)
		{
			var set = new HashSet<TResult>();

			foreach (var item in source)
			{
				var selectedValue = selector(item);

				if (set.Add(selectedValue))
				{
					yield return item;
				}
			}
		}

		#region Dates

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static DateTime ConvertToCrmUserTimeZone(this DateTime dateTime, IOrganizationService service, Guid userId)
		{
			var bias = CrmHelpers.GetUserTimeZoneBiasMinutes(service, userId);
			var biasedDate = dateTime.AddMinutes(bias);

			return DateTime.SpecifyKind(biasedDate, DateTimeKind.Local);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static DateTime ConvertToCrmUtcTimeZone(this DateTime dateTime, IOrganizationService service, Guid userId)
		{
			var bias = CrmHelpers.GetUserTimeZoneBiasMinutes(service, userId);
			var biasedDate = dateTime.AddMinutes(-bias);

			return DateTime.SpecifyKind(biasedDate, DateTimeKind.Utc);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static DateTime ConvertBetweenCrmUsersTimeZone(this DateTime dateTime, IOrganizationService service,
			Guid user1Id, Guid user2Id)
		{
			var biases = CrmHelpers.GetUsersTimeZoneBiasMinutes(service, user1Id, user2Id);
			var bias1 = biases[user1Id];
			var bias2 = biases[user2Id];

			var biasedDate = dateTime.AddMinutes(-bias1).AddMinutes(bias2);

			return DateTime.SpecifyKind(biasedDate, DateTimeKind.Local);
		}

		#endregion

		// Credit: http://www.codeproject.com/Articles/290695/Extension-methods-to-simplify-null-argument-check

		#region Param checks

		#region NULL CHECK FOR OBJECT OF ANY CLASS

		/// <summary>
		///     Generic extension method that throws ArgumentNullException if target object is null.
		///     The method is constrained to objects of class type. The method is intended to be used
		///     for null parameter check.
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <typeparam name="T">Type of parameter</typeparam>
		/// <param name="obj">Target object of type T</param>
		/// <param name="paramName">
		///     Name of the parameter.If paramName name is null empty or whitespace default value will be
		///     paramNmae = "Unknown".
		/// </param>
		/// <param name="message">Exception message.If not provided default value is "Value can not be null."</param>
		public static void Require<T>(this T obj, string paramName = DefaultParameterName,
			string message = DefaultNullExceptionMessage)
			where T : class
		{
			if (obj == null)
			{
				ThrowArgumentNullException(ref paramName, ref message);
			}
		}

		#endregion NULL CHECK FOR OBJECT OF ANY CLASS

		#region NULL CHECK FOR OBJECT OF NULLABLE TYPE

		/// <summary>
		///     Generic extension method that throws ArgumentNullException if target object is null.
		///     The method is constrained to objects of class type. The method is intended to be used
		///     for null parameter check.
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <typeparam name="T">Type of parameter</typeparam>
		/// <param name="obj">Target object of type T</param>
		/// <param name="paramName">
		///     Name of the parameter.If paramName name is null empty or whitespace default value will be
		///     paramNmae = "Unknown".
		/// </param>
		/// <param name="message">Exception message.If not provided default value is "Value can not be null."</param>
		public static void Require<T>(this T? obj, string paramName = DefaultParameterName,
			string message = DefaultNullExceptionMessage)
			where T : struct
		{
			if (obj == null)
			{
				ThrowArgumentNullException(ref paramName, ref message);
			}
		}

		/// <summary>
		///     Generic extension method that throws ArgumentNullException if type value is null.
		///     The method is constrained to objects of Nullable struct type. The method is intended to be used
		///     for null parameter check.
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <typeparam name="T">Type of target object</typeparam>
		/// <param name="obj">Target object of type T.</param>
		/// <param name="paramName">
		///     Name of the parameter.if pramName is null empty or whitespace default paramName = "Unknown"
		///     will be used.
		/// </param>
		/// <param name="message">Exception message.If not provoided default value is "Value can not be null."</param>
		public static void RequireValue<T>(this T obj, string paramName = DefaultParameterName,
			string message = DefaultNullExceptionMessage)
			where T : struct
		{
			if (obj.Equals(default(T)))
			{
				ThrowArgumentNullException(ref paramName, ref message);
			}
		}

		#endregion NULL CHECK FOR OBJECT OF NULLABLE TYPE

		#region NULL CHECK FOR OBJECT ARRAY

		/// <summary>
		///     Method throws ArgumentNullException if any of object reference in array is null.
		///     Note : Using value types in array may result in unnecessary boxing.
		///     Use only when you do not care about message , parameter name and empty/whitespace string.
		///     Certainly not enough for production quality code.
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="value">Object array containing target object references.</param>
		/// <param name="paramName"></param>
		/// <param name="message"></param>
		public static void RequireElements<TV>(this IEnumerable<TV> value, string paramName = DefaultParameterName,
			string message = DefaultArrayMemberMessage)
		{
			var valueArray = value as TV[] ?? value?.ToArray();

			valueArray.Require(paramName);

			if (valueArray.Any(param => param == null))
			{
				ThrowArgumentNullException(ref paramName, ref message);
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireCountBelow<T>(this T collection, int max, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : ICollection
		{
			if (collection == null)
			{
				var messageTemp = string.Intern(DefaultNullExceptionMessage);
				ThrowArgumentNullException(ref paramName, ref messageTemp);
				return;
			}

			if (collection.Count >= max)
			{
				message = $@"Collection count must be less than ""{max}"".";
				ThrowArgumentOutOfRangeException(ref paramName, collection, ref message, collection.Count);
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireCountAtMost<T>(this T collection, int max, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : ICollection
		{
			if (collection == null)
			{
				var messageTemp = string.Intern(DefaultNullExceptionMessage);
				ThrowArgumentNullException(ref paramName, ref messageTemp);
				return;
			}

			if (collection.Count > max)
			{
				message = string.Format(@"Collection count must be less than or equal to ""{0}"".", max);
				ThrowArgumentOutOfRangeException(ref paramName, collection, ref message, collection.Count);
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireCountAbove<T>(this T collection, int min, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : ICollection
		{
			if (collection == null)
			{
				var messageTemp = string.Intern(DefaultNullExceptionMessage);
				ThrowArgumentNullException(ref paramName, ref messageTemp);
				return;
			}

			if (collection.Count <= min)
			{
				message = $@"Collection count must be greater than ""{min}"".";
				ThrowArgumentOutOfRangeException(ref paramName, collection, ref message, collection.Count);
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireCountAtLeast<T>(this T collection, int min, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : ICollection
		{
			if (collection == null)
			{
				var messageTemp = string.Intern(DefaultNullExceptionMessage);
				ThrowArgumentNullException(ref paramName, ref messageTemp);
				return;
			}

			if (collection.Count < min)
			{
				message = $@"Collection count must be greater than or equal to ""{min}"".";
				ThrowArgumentOutOfRangeException(ref paramName, collection, ref message, collection.Count);
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireCountInRange<T>(this T collection, int min, int max,
			string paramName = DefaultParameterName, string message = DefaultRangeMessage)
			where T : ICollection
		{
			if (collection == null)
			{
				var messageTemp = string.Intern(DefaultNullExceptionMessage);
				ThrowArgumentNullException(ref paramName, ref messageTemp);
				return;
			}

			if (collection.Count > max && collection.Count < min)
			{
				message = $@"Collection count must be between ""{min}"" and ""{max}"" inclusive.";
				ThrowArgumentOutOfRangeException(ref paramName, collection, ref message, collection.Count);
			}
		}

		#endregion NULL CHECK FOR OBJECT ARRAY

		#region Null, format, and empty check for strings

		/// <summary>
		///     Extension method that throws ArgumentNullException if target string is null , empty or whitespace.
		///     The method is constrained to objects of string type. The method is intended to be used
		///     for null parameter check.
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="value">Target string object</param>
		/// <param name="paramName">
		///     Name of the parameter.if pramName is null empty or whitespace default paramName = "Unknown"
		///     will be used.
		/// </param>
		/// <param name="message">
		///     Exception message.If not provided default value is "String value can not be null , empty of white
		///     space."
		/// </param>
		public static void Require(this string value, string paramName = DefaultParameterName,
			string message = DefaultNullExceptionMessage)
		{
			if (value == null)
			{
				ThrowArgumentNullException(ref paramName, ref message);
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireFilled(this string value, string paramName = DefaultParameterName,
			string message = StringExceptionMsg)
		{
			value.RequireNotEmpty(paramName, message);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireNotEmpty(this string value, string paramName = DefaultParameterName,
			string message = StringExceptionMsg)
		{
			value.Require(paramName);

			if (string.IsNullOrWhiteSpace(value))
			{
				ThrowArgumentNullException(ref paramName, ref message);
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireFormat(this string value, string regex, string paramName = DefaultParameterName,
			string message = DefaultStringFormatExceptionMsg)
		{
			value.Require(paramName);

			if (!Regex.IsMatch(value, regex))
			{
				ThrowArgumentFormatException(ref message, ref paramName, ref regex);
			}
		}

		#endregion

		#region Range check for comparables

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireBelow<T>(this T number, T max, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : IComparable
		{
			if (number.CompareTo(max) >= 0)
			{
				message = $@"Parameter must be less than ""{max}"".";
				ThrowArgumentOutOfRangeException(ref paramName, number, ref message);
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireAtMost<T>(this T number, T max, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : IComparable
		{
			if (number.CompareTo(max) > 0)
			{
				message = $@"Parameter must be less than or equal to ""{max}"".";
				ThrowArgumentOutOfRangeException(ref paramName, number, ref message);
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireAbove<T>(this T number, T min, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : IComparable
		{
			if (number.CompareTo(min) <= 0)
			{
				message = $@"Parameter must be greater than ""{min}"".";
				ThrowArgumentOutOfRangeException(ref paramName, number, ref message);
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireAtLeast<T>(this T number, T min, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : IComparable
		{
			if (number.CompareTo(min) < 0)
			{
				message = $@"Parameter must be greater than or equal to ""{min}"".";
				ThrowArgumentOutOfRangeException(ref paramName, number, ref message);
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireInRange<T>(this T number, T min, T max, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : IComparable
		{
			if (number.CompareTo(min) < 0 || number.CompareTo(max) > 0)
			{
				message = $@"Parameter must be between ""{min}"" and ""{max}"" inclusive.";
				ThrowArgumentOutOfRangeException(ref paramName, number, ref message);
			}
		}

		#endregion

		#endregion

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsEmpty(this IEnumerable e)
		{
			return !e.IsFilled();
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsFilled(this IEnumerable e)
		{
			return e?.Cast<object>().Any() == true;
		}

		#region Strings

		/// <summary>
		///     Credit: http://stackoverflow.com/a/6724896/1919456 <br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string Truncate(this string value, int maxChars, string replacement)
		{
			return value.Length <= maxChars ? value : value.Substring(0, maxChars) + replacement;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsEmpty(this string str)
		{
			return string.IsNullOrWhiteSpace(str);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsAny(this string str)
		{
			return !string.IsNullOrEmpty(str);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsFilled(this string str)
		{
			return !str.IsEmpty();
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsNotEmpty(this string str)
		{
			return str.IsFilled();
		}

		/// <summary>
		///     Credit: http://stackoverflow.com/a/323670/1919456 <br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string StringLiteral(this string value)
		{
			var replaceDict =
				new Dictionary<string, string>
				{
					["\a"] = @"\a",
					["\b"] = @"\b",
					["\f"] = @"\f",
					["\n"] = @"\n",
					["\r"] = @"\r",
					["\t"] = @"\t",
					["\v"] = @"\v",
					["\0"] = @"\0",
					["\""] = @"\""",
					["\\"] = @"\\"
				};

			return replaceDict.Keys.Aggregate(value, (current, key) => current.Replace(key, replaceDict[key]));
		}

		/// <summary>
		///     Credit: http://stackoverflow.com/a/323670/1919456 <br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string StringUnliteral(this string value)
		{
			var replaceDict =
				new Dictionary<string, string>
				{
					[@"\a"] = "\a",
					[@"\b"] = "\b",
					[@"\f"] = "\f",
					[@"\n"] = "\n",
					[@"\r"] = "\r",
					[@"\t"] = "\t",
					[@"\v"] = "\v",
					[@"\0"] = "\0",
					[@"\"""] = "\"",
					[@"\\"] = "\\"
				};

			return replaceDict.Keys.Aggregate(value, (current, key) => current.Replace(key, replaceDict[key]));
		}

		/// <summary>
		///     Compresses a string and returns a deflate compressed, Base64 encoded string.<br />
		///     Credit: https://stackoverflow.com/a/43357353/1919456<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="uncompressedValue">String to compress</param>
		public static string Compress(this string uncompressedValue)
		{
			using (var compressedStream = new MemoryStream())
			{
				using (var uncompressedStream = new MemoryStream(Encoding.UTF8.GetBytes(uncompressedValue)))
				{
					using (var compressorStream = new DeflateStream(compressedStream, CompressionLevel.Optimal, false))
					{
						uncompressedStream.CopyTo(compressorStream);
					}
				}

				return Convert.ToBase64String(compressedStream.ToArray());
			}
		}

		/// <summary>
		///     Decompresses a deflate compressed, Base64 encoded string and returns an uncompressed string.<br />
		///     Credit: https://stackoverflow.com/a/43357353/1919456<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="compressedValue">String to decompress.</param>
		public static string Decompress(this string compressedValue)
		{
			using (var decompressedStream = new MemoryStream())
			{
				using (var compressedStream = new MemoryStream(Convert.FromBase64String(compressedValue)))
				{
					using (var decompressorStream = new DeflateStream(compressedStream, CompressionMode.Decompress))
					{
						decompressorStream.CopyTo(decompressedStream);
						return Encoding.UTF8.GetString(decompressedStream.ToArray());
					}
				}
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string CharLiteral(this char c)
		{
			return c == '\'' ? @"'\''" : string.Format("'{0}'", c);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string XmlEscape(this string unescaped)
		{
			var doc = new XmlDocument();
			XmlNode node = doc.CreateElement("root");
			node.InnerText = unescaped;
			return node.InnerXml;
		}

		#endregion

		#region METHOD THAT ACTUALLY THROWS EXCEPTION

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		private static void ThrowArgumentNullException(ref string paramName, ref string message)
		{
			throw new ArgumentNullException(paramName, message);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		private static void ThrowArgumentOutOfRangeException(ref string paramName, object number, ref string message,
			int currentCount = -1)
		{
			throw new ArgumentOutOfRangeException(paramName, number,
				message + ((currentCount >= 0) ? " Current size is " + currentCount : string.Empty));
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		private static void ThrowArgumentFormatException(ref string paramName, ref string message, ref string regex)
		{
			throw new ArgumentException(message + " Format: " + regex, paramName);
		}

		#endregion METHOD THAT ACTUALLY THROWS EXCEPTION

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsNumeric(this object obj)
		{
			switch (Type.GetTypeCode(obj.GetType()))
			{
				case TypeCode.Byte:
				case TypeCode.SByte:
				case TypeCode.UInt16:
				case TypeCode.UInt32:
				case TypeCode.UInt64:
				case TypeCode.Int16:
				case TypeCode.Int32:
				case TypeCode.Int64:
				case TypeCode.Decimal:
				case TypeCode.Double:
				case TypeCode.Single:
					return true;
				default:
					return false;
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsDateTime(this object obj)
		{
			return Type.GetTypeCode(obj.GetType()) == TypeCode.DateTime;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string StringAggregate<TV>(this IEnumerable<TV> collection, string separator = ",")
		{
			var collectionArray = collection?.ToArray();

			if (collectionArray?.Any() != true)
			{
				return string.Empty;
			}

			return collectionArray?.Select(e => e is string eString ? eString : e.ToString()).Aggregate((e1, e2) => $"{e1}{separator}{e2}");
		}

		/// <summary>
		/// Credit: Microsoft.Xrm.Client assembly
		/// </summary>
		public static TValue FirstNotNullOrDefault<TKey, TValue>(this IDictionary<TKey, TValue> dictionary, params TKey[] keys)
			=> keys
				.Where(dictionary.ContainsKey)
				.Select(key => dictionary[key])
				.FirstOrDefault();

		/// <summary>
		/// Credit: Microsoft.Xrm.Client assembly
		/// </summary>
		public static string FirstNotNullOrEmpty<TKey>(this IDictionary<TKey, string> dictionary, params TKey[] keys)
			=> (keys)
				.Where(key => dictionary.ContainsKey(key) && !string.IsNullOrEmpty(dictionary[key]))
				.Select(key => dictionary[key])
				.FirstOrDefault();
	}

	#endregion

	// -----------------------------------------------------------------------------------------------------------------------------------------------------------------
	//
	// Copyright (c) 2016 Bas van de Sande - JourneyIntoCRM - http://journeyintocrm.com
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
	// to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
	// and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	//
	// -----------------------------------------------------------------------------------------------------------------------------------------------------------------
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class EntitySerializer
	{
		public static string SerializeObject(Entity entity)
		{
			var ds = new DataSet("XmlData");
			var dt = new DataTable(entity.LogicalName);
			ConvertEntityToDataTable(dt, entity);
			ds.Tables.Add(dt);

			return ds.GetXml();
		}

		public static Entity DeserializeObject(string xml)
		{
			var dataSet = new DataSet();

			var xmlBytes = Encoding.UTF8.GetBytes(xml);

			using (var ms = new MemoryStream(xmlBytes))
			{
				dataSet.ReadXml(ms);
			}

			if (dataSet.Tables.Count <= 0)
			{
				return null;
			}

			var dt = dataSet.Tables[0];

			if (dt.Rows.Count <= 0)
			{
				return null;
			}

			var entity = new Entity(dt.TableName);
			var row = dt.Rows[0];

			foreach (DataColumn column in dt.Columns)
			{
				if (column.ColumnName == "Id")
				{
					entity.Id = (Guid?)SetAttributeValue(row[column.ColumnName]) ?? Guid.Empty;
				}
				else
				{
					entity[column.ColumnName] = SetAttributeValue(row[column.ColumnName]);
				}
			}

			return entity;
		}

		private static void ConvertEntityToDataTable(DataTable dataTable, Entity entity)
		{
			var row = dataTable.NewRow();
			dataTable.Columns.Add("Id");
			row["Id"] = GetAttributeValue(entity.Id);

			foreach (var attribute in entity.Attributes.Where(a => a.Value != null))
			{
				if (!dataTable.Columns.Contains(attribute.Key))
				{
					dataTable.Columns.Add(attribute.Key);
				}

				row[attribute.Key] = GetAttributeValue(attribute.Value);
			}

			foreach (var fv in entity.FormattedValues)
			{
				if (!dataTable.Columns.Contains(fv.Key + "name"))
				{
					dataTable.Columns.Add(fv.Key + "name");
				}

				row[fv.Key + "name"] = fv.Value;
			}

			dataTable.Rows.Add(row);
		}

		private static string GetAttributeValue(object entityValue)
		{
			string objectValue;
			var objectReference = "";
			var objectType = entityValue.GetType().FullName;

			if (entityValue is EntityReference)
			{
				objectValue = ((EntityReference)entityValue).Id.ToString();
				objectReference = ((EntityReference)entityValue).LogicalName;
			}
			else if (entityValue is OptionSetValue)
			{
				objectValue = ((OptionSetValue)entityValue).Value.ToString();
			}
			else if (entityValue is Money)
			{
				objectValue = Convert.ToString(((Money)entityValue).Value, CultureInfo.InvariantCulture.NumberFormat);
			}
			else if (entityValue is AliasedValue)
			{
				var av = (AliasedValue)entityValue;
				objectValue = GetAttributeValue(av.Value);
				objectReference = $"{av.EntityLogicalName},{av.AttributeLogicalName}";
			}
			else if (entityValue is Guid)
			{
				objectValue = entityValue.ToString();
			}
			else
			{
				if (entityValue.IsNumeric())
				{
					objectValue = Convert.ToString(entityValue, CultureInfo.InvariantCulture.NumberFormat);
				}
				else if (entityValue.IsDateTime())
				{
					objectValue = ((DateTime)entityValue).ToUniversalTime().ToString("u");
				}
				else
				{
					objectValue = entityValue.ToString();
				}
			}

			if (!string.IsNullOrWhiteSpace(objectReference))
			{
				objectReference += ",";
			}

			return $"{objectType}|{objectReference}{objectValue}";
		}

		private static object SetAttributeValue(object val)
		{
			if (val == null)
			{
				return null;
			}

			var input = val.ToString();
			var tokens = input.Split('|');

			if (tokens.Length != 2)
			{
				return null;
			}

			if (tokens[0].Equals(typeof(EntityReference).FullName))
			{
				var er = tokens[1].Split(',');
				if (er.Length == 2)
				{
					return new EntityReference(er[0], new Guid(er[1]));
				}
			}
			else if (tokens[0].Equals(typeof(OptionSetValue).FullName))
			{
				int i;
				int.TryParse(tokens[1], out i);
				if (i != int.MinValue)
				{
					return new OptionSetValue(i);
				}
			}
			else if (tokens[0].Equals(typeof(Money).FullName))
			{
				decimal d;
				decimal.TryParse(tokens[1], NumberStyles.AllowDecimalPoint, NumberFormatInfo.InvariantInfo, out d);
				if (d != decimal.MinValue)
				{
					return new Money(d);
				}
			}
			else if (tokens[0].Equals(typeof(AliasedValue).FullName))
			{
				var av = tokens[1].Split(',');
				if (av.Length == 3)
				{
					return new AliasedValue(av[0], av[1], SetAttributeValue(av[2]));
				}
			}
			else if (tokens[0].Equals(typeof(Guid).FullName))
			{
				Guid g;
				Guid.TryParse(tokens[1], out g);
				if (g != Guid.Empty)
				{
					return g;
				}
			}
			else if (tokens[0].Equals(typeof(DateTime).FullName))
			{
				DateTime dt;
				DateTime.TryParse(tokens[1], out dt);
				if (dt != DateTime.MinValue)
				{
					return dt.ToUniversalTime();
				}
			}
			else if (tokens[0].Equals(typeof(int).FullName))
			{
				int i32;
				int.TryParse(tokens[1], out i32);
				if (i32 != int.MinValue)
				{
					return i32;
				}
			}
			else if (tokens[0].Equals(typeof(bool).FullName))
			{
				return (tokens[1].ToUpper() == "TRUE");
			}
			else if (tokens[0].Equals(typeof(decimal).FullName))
			{
				decimal sd;
				decimal.TryParse(tokens[1], NumberStyles.AllowDecimalPoint, NumberFormatInfo.InvariantInfo, out sd);
				if (sd != decimal.MinValue)
				{
					return sd;
				}
			}
			else
			{
				// all other values
				return tokens[1];
			}

			return null;
		}
	}

	/// <summary>
	///     Reference Article http://www.codeproject.com/KB/tips/SerializedObjectCloner.aspx
	///     Provides a method for performing a deep copy of an object.
	///     Binary Serialization is used to perform the copy.
	///		Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class ObjectCopier
	{
		/// <summary>
		///     Perform a deep Copy of the object.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <typeparam name="T">The type of object being copied.</typeparam>
		/// <param name="source">The object instance to copy.</param>
		/// <returns>The copied object.</returns>
		public static T Clone<T>(this T source) where T : ISerializable
		{
			if (source == null)
			{
				return default(T);
			}

			IFormatter formatter = new BinaryFormatter();
			Stream stream = new MemoryStream();

			using (stream)
			{
				formatter.Serialize(stream, source);
				stream.Seek(0, SeekOrigin.Begin);
				return (T)formatter.Deserialize(stream);
			}
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class ObjectExtensions
	{
		private static readonly MethodInfo cloneMethod = typeof(object).GetMethod("MemberwiseClone",
			BindingFlags.NonPublic | BindingFlags.Instance);

		public static bool IsPrimitive(this Type type)
		{
			if (type == typeof(string))
			{
				return true;
			}

			return type.IsValueType & type.IsPrimitive;
		}

		public static T Copy<T>(this T original)
		{
			return (T)Copy((object)original);
		}

		private static object Copy(object originalObject)
		{
			return InternalCopy(originalObject, new Dictionary<object, object>(new ReferenceEqualityComparer()));
		}

		private static object InternalCopy(object originalObject, IDictionary<object, object> visited)
		{
			if (originalObject == null)
			{
				return null;
			}

			var typeToReflect = originalObject.GetType();

			if (IsPrimitive(typeToReflect))
			{
				return originalObject;
			}

			if (visited.ContainsKey(originalObject))
			{
				return visited[originalObject];
			}

			if (typeof(Delegate).IsAssignableFrom(typeToReflect))
			{
				return null;
			}

			var cloneObject = cloneMethod.Invoke(originalObject, null);

			if (typeToReflect.IsArray)
			{
				var arrayType = typeToReflect.GetElementType();

				if (IsPrimitive(arrayType) == false)
				{
					var clonedArray = (Array)cloneObject;
					clonedArray.ForEach((array, indices) => array.SetValue(InternalCopy(clonedArray.GetValue(indices), visited), indices));
				}
			}

			visited.Add(originalObject, cloneObject);
			CopyFields(originalObject, visited, cloneObject, typeToReflect);
			RecursiveCopyBaseTypePrivateFields(originalObject, visited, cloneObject, typeToReflect);

			return cloneObject;
		}

		private static void RecursiveCopyBaseTypePrivateFields(object originalObject, IDictionary<object, object> visited,
			object cloneObject, Type typeToReflect)
		{
			if (typeToReflect.BaseType == null)
			{
				return;
			}

			RecursiveCopyBaseTypePrivateFields(originalObject, visited, cloneObject, typeToReflect.BaseType);
			CopyFields(originalObject, visited, cloneObject, typeToReflect.BaseType,
				BindingFlags.Instance | BindingFlags.NonPublic, info => info.IsPrivate);
		}

		private static void CopyFields(object originalObject, IDictionary<object, object> visited, object cloneObject,
			IReflect typeToReflect,
			BindingFlags bindingFlags =
				BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.FlattenHierarchy,
			Func<FieldInfo, bool> filter = null)
		{
			foreach (var fieldInfo in typeToReflect.GetFields(bindingFlags))
			{
				if (filter != null && filter(fieldInfo) == false)
				{
					continue;
				}

				if (IsPrimitive(fieldInfo.FieldType))
				{
					continue;
				}

				var originalFieldValue = fieldInfo.GetValue(originalObject);
				var clonedFieldValue = InternalCopy(originalFieldValue, visited);
				fieldInfo.SetValue(cloneObject, clonedFieldValue);
			}
		}

		public static void CopyValuesFrom(this object self, object parent, bool isDeepCopy = false)
		{
			var bindingFlags = BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.FlattenHierarchy;
			var fromFields = parent.GetType().GetFields(bindingFlags);
			var toFields = self.GetType().GetFields(bindingFlags);

			foreach (var fromField in fromFields)
			{
				var toField = toFields.FirstOrDefault(f => fromField.Name == f.Name && fromField.FieldType == f.FieldType);
				var value = fromField.GetValue(parent);
				toField?.SetValue(self, isDeepCopy ? value.Copy() : value);
			}
		}
	}

	#region Helpers

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public class GenericEqualityComparer<T> : EqualityComparer<T>
	{
		private readonly Func<T, T, bool> equator;
		private readonly Func<T, int> hasher;

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public GenericEqualityComparer(Func<T, T,bool> equator, Func<T, int> hasher = null)
		{
			equator.Require(nameof(equator));
			this.equator = equator;
			this.hasher = hasher;
		}

		public override bool Equals(T x, T y)
		{
			return equator(x, y);
		}

		public override int GetHashCode(T obj)
		{
			return hasher == null ? obj.GetHashCode() : hasher(obj);
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public class ReferenceEqualityComparer : EqualityComparer<object>
	{
		public override bool Equals(object x, object y)
		{
			return ReferenceEquals(x, y);
		}

		public override int GetHashCode(object obj)
		{
			return obj.GetHashCode();
		}
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class ArrayExtensions
	{
		public static void ForEach(this Array array, Action<Array, int[]> action)
		{
			if (array.LongLength == 0)
			{
				return;
			}

			var walker = new ArrayTraverse(array);

			do
			{
				action(array, walker.Position);
			}
			while (walker.Step());
		}

		private class ArrayTraverse
		{
			public int[] Position;
			private readonly int[] maxLengths;

			public ArrayTraverse(Array array)
			{
				maxLengths = new int[array.Rank];

				for (var i = 0; i < array.Rank; ++i)
				{
					maxLengths[i] = array.GetLength(i) - 1;
				}

				Position = new int[array.Rank];
			}

			public bool Step()
			{
				for (var i = 0; i < Position.Length; ++i)
				{
					if (Position[i] >= maxLengths[i])
					{
						continue;
					}

					Position[i]++;

					for (var j = 0; j < i; j++)
					{
						Position[j] = 0;
					}

					return true;
				}
				return false;
			}
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class StringHelpers
	{
		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string ToSentenceCase(this string input)
		{
			return Regex.Replace(
				input,
				@"(?<=(^|\.\s+))[a-z](?=[^A-Z]*(\.$|$|\.\s+|\s))",
				m => m.Value.ToUpper());
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string ToTitleCase(this string input)
		{
			return Regex.Replace(
				input,
				@"(?:^[a-z]|\.\s*[a-z]|\b(?!a|aboard|about|above|across|after|against|along|although|amid|among|an|and|anti|around|as|at|because|before|behind|below|beneath|beside|besides|between|beyond|both|but|by|concerning|consequently|considering|despite|down|during|either|even|except|excepting|excluding|finally|following|for|from|furthermore|hardly|hence|however|if|in|incidentally|indeed|inside|instead|into|lest|like|likewise|meanwhile|minus|near|neither|nor|now|of|off|on|once|onto|opposite|or|outside|over|past|per|plus|provided|rather|regarding|round|save|since|so|such|supposing|than|that|the|though|through|till|to|toward|towards|under|underneath|unless|unlike|until|up|upon|versus|via|when|whenever|where|whereas|wherever|whether|which|while|who|whoever|why|with|within|without|yet)[a-z])",
				m => m.Value.ToUpper());
		}

		/// <summary>
		/// Credit: https://stackoverflow.com/a/25513964/1919456
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string ReplaceGroup(this string input, string pattern, string replacement, RegexOptions? options = null)
		{
			return input.ReplaceGroups(pattern, _ => replacement, options);
		}

		/// <summary>
		/// Credit: https://stackoverflow.com/a/25513964/1919456
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string ReplaceGroup(this string input, string pattern, string groupName, string replacement, RegexOptions? options = null)
		{
			return input.ReplaceGroups(pattern, new Dictionary<string, string> { { groupName, replacement } }, options);
		}

		/// <summary>
		/// Credit: https://stackoverflow.com/a/25513964/1919456
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="replacementMap">Key-value pairs of group name and replacement</param>
		public static string ReplaceGroups(this string input, string pattern, IDictionary<string, string> replacementMap,
			RegexOptions? options = null)
		{
			return input.ReplaceGroups(pattern, replacementMap.ToDictionary(p => p.Key, p => new Func<string, string>(s => p.Value)));
		}

		/// <summary>
		/// Credit: https://stackoverflow.com/a/25513964/1919456
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string ReplaceGroups(this string input, string pattern, Func<string, string> replacementAction, RegexOptions? options = null)
		{
			var match = Regex.Match(input, pattern, options ?? RegexOptions.None);

			if (!match.Success)
			{
				return input;
			}

			var replacementMap = Enumerable.Range(match.Groups.Count > 1 ? 1 : 0, match.Groups.Count)
				.ToDictionary(i => i.ToString(), _ => replacementAction);

			return input.ReplaceGroups(pattern, replacementMap, options);
		}

		/// <summary>
		/// Credit: https://stackoverflow.com/a/25513964/1919456
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="replacementMap">Key-value pairs of group name and replacement</param>
		public static string ReplaceGroups(this string input, string pattern, IDictionary<string, Func<string, string>> replacementMap,
			RegexOptions? options = null)
		{
			return Regex
				.Replace(
					input,
					pattern,
					m =>
					{
						var sb = new StringBuilder();

						var groupMap = replacementMap
							.Select(g =>
								new
								{
									group = g.Key == "-1" ? m.Groups[0] : (int.TryParse(g.Key, out var index) ? m.Groups[index] : m.Groups[g.Key]),
									replacement = g.Value
								})
							.Where(g => g.group != null)
							.OrderBy(g => g.group.Index);

						var previousCaptureEnd = 0;

						foreach (var groupMapping in groupMap)
						{
							var group = groupMapping.group;
							var replacement = groupMapping.replacement;

							foreach (var capture in group.Captures.Cast<Capture>())
							{
								var currentCaptureEnd = capture.Index + capture.Length - m.Index;
								var currentCaptureLength = capture.Index - m.Index - previousCaptureEnd;
								sb.Append(m.Value.Substring(previousCaptureEnd, currentCaptureLength));
								sb.Append(replacement(capture.Value));
								previousCaptureEnd = currentCaptureEnd;
							}
						}

						sb.Append(m.Value.Substring(previousCaptureEnd));

						return sb.ToString();
					}, options ?? RegexOptions.None);
		}

		public static string EscapeCsv(this string input)
		{
			if (string.IsNullOrWhiteSpace(input))
			{
				return input;
			}
			
			return "\"" + input.Replace("\"", "\"\"") + "\"";
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class RegexHelpers
	{
		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IEnumerable<string> ExtractCaptures(this Group group)
		{
			return group.Captures.OfType<Capture>().Select(c => c.Value);
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class CollectionHelpers
	{
		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IEnumerable<TV> FilterNull<TV>(this IEnumerable<TV> collection)
		{
			return collection?.Where(e => e != null);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IEnumerable<TV> FilterEmpty<TV>(this IEnumerable<TV> collection)
		{
			return collection?
				.FilterNull()
				.Where(e => (!(e is string stringValue) || stringValue.IsFilled())
					&& (!(e is IEnumerable ee) || ee.IsFilled()));
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IDictionary<TU, TV> FilterNull<TU, TV>(this IDictionary<TU, TV> dictionary)
		{
			return dictionary?.Where(e => e.Value != null).ToDictionary(p => p.Key, p => p.Value);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IDictionary<TU, TV> FilterEmpty<TU, TV>(this IDictionary<TU, TV> dictionary)
		{
			return dictionary?
				.Where(e => (!(e.Value is string stringValue) || stringValue.IsFilled())
					&& (!(e.Value is IEnumerable ee) || ee.IsFilled()))
				.ToDictionary(p => p.Key, p => p.Value);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool In<TObject>(this TObject obj, IEnumerable<TObject> collection)
			where TObject : class
		{
			return collection != null && collection.Contains(obj);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool ValueIn<TObject>(this TObject obj, IEnumerable<TObject> collection)
			where TObject : struct
		{
			return collection != null && collection.Contains(obj);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool In<TObject, TKey>(this TObject obj, IDictionary<TKey, TObject> dictionary)
			where TObject : class
		{
			return obj.In(dictionary.Values);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool ValueIn<TObject, TKey>(this TObject obj, IDictionary<TKey, TObject> dictionary)
			where TObject : struct
		{
			return obj.ValueIn(dictionary.Values);
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class TypeHelpers
	{
		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static Type[] GetHierarchyTree(this Type type)
		{
			return
				CacheHelpers
					.GetFromMemCacheAdd(
						$"Yagasoft.Common.TypeHelpers.GetHierarchyTree|{type?.FullName}",
						() => AppDomain.CurrentDomain.GetAssemblies().SelectMany(e => e.GetTypes())
							.Where(t => type.IsAssignableFrom(t) && !t.IsGenericTypeDefinition).Distinct().ToArray());
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static Type GetType(string name, Type assemblyScope = null)
		{
			return
				CacheHelpers
					.GetFromMemCacheAdd(
						$"Yagasoft.Common.TypeHelpers.GetType|{name}|{assemblyScope?.FullName}",
						() => assemblyScope == null
							? AppDomain.CurrentDomain.GetAssemblies().SelectMany(a => a.GetTypes())
								.FirstOrDefault(e => e.AssemblyQualifiedName == name || e.FullName == name || e.Name == name)
							: assemblyScope.Assembly.GetTypes()
								.FirstOrDefault(e => e.AssemblyQualifiedName == name || e.FullName == name || e.Name == name));
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static Type GetType(string name, params Assembly[] assembliesScope)
		{
			return
				CacheHelpers
					.GetFromMemCacheAdd(
						$"Yagasoft.Common.TypeHelpers.GetType|{name}|{assembliesScope?.Select(e => e?.FullName).StringAggregate()}",
						() => assembliesScope == null
							? AppDomain.CurrentDomain.GetAssemblies().SelectMany(a => a.GetTypes())
								.FirstOrDefault(e => e.AssemblyQualifiedName == name || e.FullName == name || e.Name == name)
							: assembliesScope.SelectMany(a => a.GetTypes())
								.FirstOrDefault(e => e.AssemblyQualifiedName == name || e.FullName == name || e.Name == name));
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static Type[] GetTypes<TAttribute>(params Type[] assemblyScope) where TAttribute : Attribute
		{
			return 
				CacheHelpers
				.GetFromMemCacheAdd(
					$"Yagasoft.Common.TypeHelpers.GetTypes<{typeof(TAttribute).FullName}>|{assemblyScope?.Select(a => a.FullName).StringAggregate()}",
					() => CacheHelpers
						.GetFromMemCacheAdd(
							$"Yagasoft.Common.TypeHelpers.GetTypes<TAttribute>|{assemblyScope?.Select(a => a.FullName).StringAggregate()}",
							() => (assemblyScope?.SelectMany(a => a.Assembly.GetTypes())
								?? AppDomain.CurrentDomain.GetAssemblies().SelectMany(a => a.GetTypes()).ToArray()).Distinct())
						.Where(e => e.GetCustomAttribute<TAttribute>() != null).ToArray());
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static Type GetType<TAttribute>(Func<TAttribute, bool> predicate, Type assemblyScope = null) where TAttribute : Attribute
		{
			return CacheHelpers
				.GetFromMemCacheAdd(
					$"Yagasoft.Common.TypeHelpers.GetType<{typeof(TAttribute).FullName}>|{assemblyScope?.FullName}",
					() => assemblyScope?.Assembly.GetTypes()
						?? AppDomain.CurrentDomain.GetAssemblies().SelectMany(a => a.GetTypes()).ToArray())
				.FirstOrDefault(e => predicate(e.GetCustomAttribute<TAttribute>()));
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static TAttribute GetAttribute<TAttribute>(this Type type) where TAttribute : Attribute
		{
			return CacheHelpers
				.GetFromMemCacheAdd(
					$"Yagasoft.Common.TypeHelpers.GetAttribute<{typeof(TAttribute).FullName}>|{type.FullName}",
					type.GetCustomAttribute<TAttribute>);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static TAttribute GetAttribute<TAttribute>(this object obj) where TAttribute : Attribute
		{
			return obj.GetType().GetAttribute<TAttribute>();
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsTypeMarked<TAttribute>(this Type type, Func<TAttribute, bool> predicate = null)
			where TAttribute : Attribute
		{
			var attribute = type.GetAttribute<TAttribute>();
			return attribute != null && (predicate == null || predicate(type.GetCustomAttribute<TAttribute>()));
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsTypeMarked<TAttribute>(this object obj, Func<TAttribute, bool> predicate = null)
			where TAttribute : Attribute
		{
			return obj.GetType().IsTypeMarked(predicate);
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static partial class Helpers
	{
		private static readonly IDictionary<Type, Func<object, string>> StringRepresentationsMap =
			new ConcurrentDictionary<Type, Func<object, string>>();

		/// <summary>
		///     Gets the name of the assembly by going back frames in the stack trace.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="skipFrames">
		///     [Optional] The number of frames to go back.<br />
		///     If not specified, it will get the first assembly in the stack that does not equal this one.
		/// </param>
		/// <param name="skipAssemblyName">[Optional] The name of the assembly to skip if frames are set to '-1'.</param>
		/// <returns>The name of the assembly</returns>
		public static string GetAssemblyName(int skipFrames = -1, string skipAssemblyName = null)
		{
			var currentAssembly = new StackFrame().GetMethod().ReflectedType?.AssemblyQualifiedName;
			skipAssemblyName = string.IsNullOrWhiteSpace(skipAssemblyName) ? currentAssembly : skipAssemblyName;

			if (skipFrames < 0 && !string.IsNullOrWhiteSpace(skipAssemblyName))
			{
				for (var i = 1; i < 100; i++)
				{
					var method = new StackFrame(i).GetMethod();

					if (method == null)
					{
						break;
					}

					currentAssembly = method.ReflectedType?.AssemblyQualifiedName;

					if (currentAssembly?.Contains(skipAssemblyName) == true)
					{
						continue;
					}

					break;
				}
			}
			else if (skipFrames >= 0)
			{
				currentAssembly = new StackFrame(skipFrames + 1).GetMethod().ReflectedType?.AssemblyQualifiedName;
			}

			return currentAssembly;
		}

		/// <summary>
		///     Gets the name of the class by going back frames in the stack trace.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="skipFrames">
		///     [Optional] The number of frames to go back.<br />
		///     If not specified, it will get the first class in the stack that does not equal this one.
		/// </param>
		/// <param name="skipClassNamesParams">
		///     [Optional] The name of the classes to skip if frames are set to '-1'. Must be full
		///     name.
		/// </param>
		/// <returns>The name of the class</returns>
		public static string GetClassName(int skipFrames = -1, params string[] skipClassNamesParams)
		{
			Type declaringType = null;
			var currentClass = new StackFrame().GetMethod().ReflectedType;

			var skipClasses = skipClassNamesParams.ToList();
			skipClasses.Add(currentClass?.FullName);

			if (skipFrames < 0)
			{
				for (var i = 1; i < 100; i++)
				{
					var method = new StackFrame(i).GetMethod();

					if (method == null)
					{
						break;
					}

					declaringType = method.ReflectedType;
					var className = declaringType?.FullName ?? string.Empty;

					if (skipClasses.Contains(className))
					{
						continue;
					}

					break;
				}
			}
			else
			{
				declaringType = new StackFrame(skipFrames + 1).GetMethod().ReflectedType;
			}

			return declaringType?.FullName ?? string.Empty;
		}

		/// <summary>
		///     Gets the stack trace of the current execution path.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="skipFrames">
		///     [Optional] The number of frames to go back.<br />
		///     If not specified, it will get the first class in the stack that does not equal this one.
		/// </param>
		/// <param name="skipClassName">
		///     [Optional] The name of the class to skip if frame are set to '-1'. Must be full
		///     name.
		/// </param>
		/// <returns>The stack trace</returns>
		public static string GetStackTrace(int skipFrames = -1, string skipClassName = null)
		{
			var currentClass = new StackFrame().GetMethod().DeclaringType;
			skipClassName = string.IsNullOrWhiteSpace(skipClassName) ? currentClass?.FullName : skipClassName;

			if (skipFrames < 0 && !string.IsNullOrWhiteSpace(skipClassName))
			{
				for (var i = 1; i < 100; i++)
				{
					var method = new StackFrame(i).GetMethod();

					if (method == null)
					{
						break;
					}

					var declaringType = method.DeclaringType;
					var className = declaringType == null ? string.Empty : declaringType.FullName;

					if (className?.Contains(skipClassName) == true)
					{
						continue;
					}

					skipFrames = i - 1;
					break;
				}
			}
			else if (skipFrames < 0)
			{
				skipFrames = 0;
			}

			return new StackTrace(skipFrames + 1).ToString();
		}

		/// <summary>
		///     Add a function that returns a string representing the given type's values to the pool in memory.<br />
		///     This function will be searched for when 'GetStringRepresentation' is called.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="evaluator">
		///     A function that takes an object of the given type
		///     and returns a string representation of the values of that type.
		/// </param>
		public static void AddStringRepresentationFunction<T>(Func<T, string> evaluator)
		{
			evaluator.Require();
			StringRepresentationsMap[typeof(T)] = obj => obj is T ? evaluator((T)obj) : null;
		}

		/// <summary>
		///     Gets the function that returns a string representing the given type's values from the pool in memory.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static Func<object, string> GetStringRepresentationFunction(Type objectType)
		{
			if (objectType == null)
			{
				return null;
			}

			Func<object, string> evaluator;
			StringRepresentationsMap.TryGetValue(objectType, out evaluator);
			return evaluator ?? GetStringRepresentationFunction(objectType.BaseType);
		}

		public static bool IsAlwaysUseDefaultEvaluator;
		public static Func<object, string> DefaultEvaluator;

		/// <summary>
		///     Returns a string representing the given object's value.<br />
		///     This can be used in place of 'ToString'.<br />
		///     Custom functions can be defined and added to the pool using 'AddTypeStringRepresentation'.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetStringRepresentation(object value)
		{
			if (value == null)
			{
				return "null";
			}

			if (IsAlwaysUseDefaultEvaluator && DefaultEvaluator != null)
			{
				return DefaultEvaluator(value);
			}

			StringBuilder builder;

			if (value.GetType().Name == "KeyValuePair`2")
			{
				var valTyped = (dynamic)value;
				return $"({valTyped.Key},{GetStringRepresentation(valTyped.Value)})";
			}

			if (value is ICollection)
			{
				var collection = (ICollection)value;
				var enumerator = collection.GetEnumerator();
				builder = new StringBuilder();

				var jumpSize = (int)Math.Ceiling(collection.Count / 5.0);
				var index = 0;
				var skipped = false;

				builder.Append("[");

				while (enumerator.MoveNext())
				{
					if (index % jumpSize == 0 || index == 0)
					{
						if (index > 0)
						{
							builder.Append(",");

							if (skipped)
							{
								builder.Append("..,");
							}
						}

						builder.Append(GetStringRepresentation(enumerator.Current));
					}
					else
					{
						skipped = true;
					}

					index++;
				}

				builder.Append("]");

				return builder.ToString();
			}

			if (value is EntityReference)
			{
				var reference = (EntityReference)value;
				builder = new StringBuilder();

				builder.Append("{");
				builder.Append($"Logical name = {reference.LogicalName}, ID = {reference.Id}");

				if (!string.IsNullOrWhiteSpace(reference.Name))
				{
					builder.Append($", Name = {reference.Name}");
				}

				builder.Append("}");

				return builder.ToString();
			}

			if (value is Entity)
			{
				var reference = (Entity)value;
				return $"{{Logical name = {reference.LogicalName}, ID = {reference.Id}}}";
			}

			var label = CrmHelpers.GetAttributeName(value);

			if (label != value.GetType().ToString())
			{
				return label;
			}

			var function = GetStringRepresentationFunction(value.GetType());
			return function == null ? (DefaultEvaluator == null ? value.ToString() : DefaultEvaluator(value)) : function(value);
		}

		/// <summary>
		/// Credit: https://stackoverflow.com/a/1641173/1919456
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static Guid? Merge(this Guid? guid1, Guid? guid2)
		{
			if (guid1 == null)
			{
				return guid2;
			}

			if (guid2 == null)
			{
				return guid1;
			}

			const int bytecount = 16;
			var destByte = new byte[bytecount];
			var guid1Byte = guid1.Value.ToByteArray();
			var guid2Byte = guid2.Value.ToByteArray();
     
			for (var i = 0; i < bytecount; i++)
			{
				destByte[i] = (byte) (guid1Byte[i] ^ guid2Byte[i]);
			}

			return new Guid(destByte);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static Guid? Merge(this Guid guid1, Guid? guid2)
		{
			return ((Guid?)guid1).Merge(guid2);
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static partial class CacheHelpers
	{
		/// <summary>
		/// Build an object containing parameters used by the caching methods. The org ID can be provided in order to 
		/// differentiate the cache of different organisations on the same machine.<br />
		/// If no config is found and fallback is not given, no caching is used.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="service">CRM service.</param>
		/// <param name="isAddAssemblyTosuffix">Append assembly name to the suffix.</param>
		/// <param name="suffix">Extra text to append on key.</param>
		/// <param name="fallbackCacheDuration">Duration to use for caching if no config was found in CRM.</param>
		public static CacheParams BuildCacheParams(IOrganizationService service,
			bool isAddAssemblyTosuffix = false, string suffix = null, TimeSpan? fallbackCacheDuration = null, Guid? orgId = null)
		{
			var cacheDuration = CrmHelpers.GetGenericConfig(service, orgId)?.GetAttributeValue<int?>("ldv_configurationcacheduration");

			return
				new CacheParams
				{
					CacheSuffix = isAddAssemblyTosuffix
						? $"{Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common")}|{suffix}"
						: suffix,
					CacheExpiryTarget = cacheDuration == null && fallbackCacheDuration.HasValue
						? DateTime.Now + fallbackCacheDuration
						: DateTime.Now.AddMinutes(cacheDuration ?? 0),
					OrgId = orgId
				};
		}

		private const string NullPlaceholder = "YsMemCache|null";

		/// <summary>
		///     Adds the given object to the MemCache.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="key">The string key to add this object under.</param>
		/// <param name="item">The object to add.</param>
		/// <param name="offset">
		///     [OPTIONAL] The time after which to remove the object from the cache.
		/// </param>
		/// <param name="cacheKeysuffix">A string to append to all keys. Usually the assembly name.</param>
		public static T AddToMemCache<T>(string key, T item, DateTimeOffset? offset, string cacheKeysuffix = null,
			Guid? orgId = null)
		{
			key.RequireFilled(nameof(key));

			ObjectCache cache = MemoryCache.Default;

			if (!string.IsNullOrWhiteSpace(cacheKeysuffix))
			{
				key += $"|{cacheKeysuffix}";
			}

			if (orgId.HasValue)
			{
				key += $"|{orgId}";
			}

			RemoveFromMemCache(key);

			if (item == null)
			{
				cache.Add(key, NullPlaceholder, offset ?? ObjectCache.InfiniteAbsoluteExpiration);
			}
			else
			{
				cache.Add(key, item, offset ?? ObjectCache.InfiniteAbsoluteExpiration);
			}

			return item;
		}

		/// <summary>
		///     Adds the given object to the MemCache.<br />
		///     Uses provided cache expiry params.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static T AddToMemCache<T>(string key, T item, string cacheKeysuffix = null, TimeSpan? fallbackCacheDuration = null,
			Guid? orgId = null)
		{
			return AddToMemCache(key, item, null, cacheKeysuffix, fallbackCacheDuration, orgId);
		}

		/// <summary>
		///     Adds the given object to the MemCache.<br />
		///     Uses provided cache expiry params.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static T AddToMemCache<T>(string key, T item, CacheParams cacheParams)
		{
			return AddToMemCache(key, item, cacheParams.CacheExpiryTarget, cacheParams.CacheSuffix, cacheParams.OrgId);
		}

		/// <summary>
		///     Adds the given object to the MemCache.<br />
		///     Automatically retrieves the cache expiry params.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static T AddToMemCache<T>(string key, T item, IOrganizationService service,
			string cacheKeysuffix = null, TimeSpan? fallbackCacheDuration = null, Guid? orgId = null)
		{
			return AddToMemCache(key, item, BuildCacheParams(service, false, cacheKeysuffix, fallbackCacheDuration, orgId));
		}

		/// <summary>
		///     Adds the given object to the MemCache.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="key">The string key to add this object under.</param>
		/// <param name="item">The object to add.</param>
		/// <param name="slidingExpiration">
		///     The duration after which to remove the object from cache, if it was not accessed for that duration.
		/// </param>
		/// <param name="cacheKeysuffix">A string to append to all keys. Usually the assembly name.</param>
		public static T AddToMemCache<T>(string key, T item, TimeSpan slidingExpiration, string cacheKeysuffix = null,
			Guid? orgId = null)
		{
			key.RequireFilled(nameof(key));

			ObjectCache cache = MemoryCache.Default;

			if (!string.IsNullOrWhiteSpace(cacheKeysuffix))
			{
				key += $"|{cacheKeysuffix}";
			}

			if (orgId.HasValue)
			{
				key += $"|{orgId}";
			}

			RemoveFromMemCache(key);

			slidingExpiration = slidingExpiration > TimeSpan.FromDays(365) ? TimeSpan.FromDays(365) : slidingExpiration;

			if (item == null)
			{
				cache.Add(key, NullPlaceholder, new CacheItemPolicy { SlidingExpiration = slidingExpiration });
			}
			else
			{
				cache.Add(key, item, new CacheItemPolicy { SlidingExpiration = slidingExpiration });
			}

			return item;
		}

		/// <summary>
		///     Gets the object from the MemCache.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="key">The string key for the object to get.</param>
		/// <param name="cacheKeySuffix">A string to append to all keys. Usually the assembly name.</param>
		/// <param name="defaultValue">The value to return if the key can't be found in the cache.</param>
		public static TItemType GetFromMemCache<TItemType>(string key, string cacheKeySuffix = null,
			TItemType defaultValue = default(TItemType), Guid? orgId = null)
		{
			key.RequireFilled(nameof(key));

			ObjectCache cache = MemoryCache.Default;

			if (!string.IsNullOrWhiteSpace(cacheKeySuffix))
			{
				key += $"|{cacheKeySuffix}";
			}

			if (orgId.HasValue)
			{
				key += $"|{orgId}";
			}

			if (IsInMemCache(key))
			{
				var value = cache.Get(key);
				return (TItemType)((value as string) == NullPlaceholder ? default(TItemType) : value);
			}

			return defaultValue;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsInMemCache(string key, string cacheKeySuffix = null, Guid? orgId = null)
		{
			key.RequireFilled(nameof(key));

			ObjectCache cache = MemoryCache.Default;

			if (!string.IsNullOrWhiteSpace(cacheKeySuffix))
			{
				key += $"|{cacheKeySuffix}";
			}

			if (orgId.HasValue)
			{
				key += $"|{orgId}";
			}

			return cache.Contains(key);
		}

		/// <summary>
		///     Removes the object from the MemCache.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="key">The string key for the object to remove.</param>
		/// <param name="cacheKeysuffix">A string to append to all keys. Usually the assembly name.</param>
		public static void RemoveFromMemCache(string key, string cacheKeysuffix = null, Guid? orgId = null)
		{
			key.RequireFilled(nameof(key));

			ObjectCache cache = MemoryCache.Default;

			if (!string.IsNullOrWhiteSpace(cacheKeysuffix))
			{
				key += $"|{cacheKeysuffix}";
			}

			if (orgId.HasValue)
			{
				key += $"|{orgId}";
			}

			if (cache.Contains(key))
			{
				cache.Remove(key);
			}
		}

		/// <summary>
		///     Gets the object from the MemCache and add if it doesn't exist.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="key">The string key for the object to get.</param>
		/// <param name="cacheFiller">The function to execute to fill the cache if the key can't be found in the cache.</param>
		/// <param name="cacheParams">Expiry and other params to use.</param>
		/// <param name="defaultValue">The value that if returned by the cache would cause the 'filler' to run anyway.</param>
		public static T GetFromMemCacheAdd<T>(string key, Func<T> cacheFiller, CacheParams cacheParams,
			T defaultValue = default(T))
		{
			cacheParams = cacheParams ?? new CacheParams();

			return IsInMemCache(key, cacheParams.CacheSuffix, cacheParams.OrgId)
				? GetFromMemCache(key, cacheParams.CacheSuffix, defaultValue, cacheParams.OrgId)
				: AddToMemCache(key, cacheFiller(),
					cacheParams.CacheExpiryTarget, cacheParams.CacheSuffix, cacheParams.OrgId);
		}

		/// <summary>
		///     Gets the object from the MemCache and add if it doesn't exist.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static T GetFromMemCacheAdd<T>(string key, Func<T> cacheFiller, DateTimeOffset? offset,
			string cacheKeysuffix = null, T defaultValue = default(T), Guid? orgId = null)
		{
			return IsInMemCache(key, cacheKeysuffix, orgId)
				? GetFromMemCache(key, cacheKeysuffix, defaultValue, orgId)
				: AddToMemCache(key, cacheFiller(), offset, cacheKeysuffix, orgId);
		}

		/// <summary>
		///     Gets the object from the MemCache and add if it doesn't exist.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static T GetFromMemCacheAdd<T>(string key, Func<T> cacheFiller,
			string cacheKeysuffix = null, T defaultValue = default(T), TimeSpan? fallbackCacheDuration = null, Guid? orgId = null)
		{
			return GetFromMemCacheAdd(key, cacheFiller, null, cacheKeysuffix, defaultValue, fallbackCacheDuration, orgId);
		}

		/// <summary>
		///     Gets the object from the MemCache and add if it doesn't exist.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static T GetFromMemCacheAdd<T>(string key, Func<T> cacheFiller, TimeSpan slidingExpiration,
			string cacheKeysuffix = null, T defaultValue = default(T), Guid? orgId = null)
		{
			return IsInMemCache(key, cacheKeysuffix, orgId)
				? GetFromMemCache(key, cacheKeysuffix, defaultValue, orgId)
				: AddToMemCache(key, cacheFiller(), slidingExpiration, cacheKeysuffix, orgId);
		}

		/// <summary>
		///     Gets the object from the MemCache and add if it doesn't exist.<br />
		///     Automatically retrieves the cache expiry params.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="key">The string key for the object to get.</param>
		/// <param name="cacheFiller">The function to execute to fill the cache if the key can't be found in the cache.</param>
		/// <param name="defaultValue">The value that if returned by the cache would cause the 'filler' to run anyway.</param>
		public static T GetFromMemCacheAdd<T>(string key, Func<T> cacheFiller, IOrganizationService service,
			string cacheKeysuffix = null, T defaultValue = default(T), TimeSpan? fallbackCacheDuration = null, Guid? orgId = null)
		{
			return GetFromMemCacheAdd(key, cacheFiller,
				BuildCacheParams(service, false, cacheKeysuffix, fallbackCacheDuration, orgId), defaultValue);
		}
	}

	/// <summary>
	///     credit: http://blog.codeeffects.com/Article/Generate-Random-Numbers-And-Strings-C-Sharp <br />
	///		Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class RandomGenerator
	{
		public enum SymbolFlag
		{
			Custom = 0,
			Uppers = 1,
			Lowers = 2,
			Numbers = 3
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetRandomString(int length, bool isLetterStart, int numberLetterRatio,
			params string[] symbols)
		{
			var sb = new StringBuilder();

			var digits = symbols.Where(symbol => char.IsDigit(symbol[0])).ToArray();
			var letters = symbols.Where(symbol => !char.IsDigit(symbol[0])).ToArray();

			var digitsCount = 0;
			var lettersCount = 0;
			var floatRatio = numberLetterRatio / 100.0;

			for (var i = 0; i < length; i++)
			{
				var filteredSymbols = symbols;

				if (isLetterStart && i == 0)
				{
					lettersCount++;
					filteredSymbols = letters;
				}
				else if (numberLetterRatio > -1)
				{
					if ((lettersCount / (float)length) >= (1 - floatRatio)
						|| (GetRandomNumber(0, 100) <= numberLetterRatio
							&& (digitsCount / (float)length) < floatRatio))
					{
						digitsCount++;
						filteredSymbols = digits;
					}
					else
					{
						lettersCount++;
						filteredSymbols = letters;
					}
				}

				sb.Append(filteredSymbols[GetRandomNumber(0, filteredSymbols.Length)]);
			}

			return sb.ToString();
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetRandomString(int length, bool isLetterStart, params string[] symbols)
		{
			return GetRandomString(length, isLetterStart, -1, symbols);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetRandomString(int length, params string[] symbols)
		{
			return GetRandomString(length, false, -1, symbols);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetRandomString(int length, bool isLetterStart, int numberLetterRatio,
			params SymbolFlag[] symbolFlags)
		{
			symbolFlags.Require(nameof(symbolFlags));

			var array = new List<string>();

			var arraySymbolUppers = new[]
									{
										"A", "B", "C", "D", "E", "F", "G", "H", "J", "K", "L", "M", "N", "P", "R", "S", "T", "U",
										"V", "W", "X", "Y",
										"Z"
									};

			var arraySymbolLowers = new[]
									{
										"a", "b", "c", "d", "e", "f", "g", "h", "j", "k", "m", "n", "p", "q", "r", "s", "t", "u",
										"v", "w", "x", "y",
										"z"
									};

			var arrayNumbers = new[]
							   {
								   "0", "2", "3", "4", "5", "6", "8", "9"
							   };

			if (symbolFlags.Length <= 0)
			{
				symbolFlags = new[] { SymbolFlag.Uppers, SymbolFlag.Lowers, SymbolFlag.Numbers };
			}

			if (symbolFlags.Contains(SymbolFlag.Uppers))
			{
				array.AddRange(arraySymbolUppers);
			}

			if (symbolFlags.Contains(SymbolFlag.Lowers))
			{
				array.AddRange(arraySymbolLowers);
			}

			if (symbolFlags.Contains(SymbolFlag.Numbers))
			{
				array.AddRange(arrayNumbers);
			}

			return GetRandomString(length, isLetterStart, numberLetterRatio, array.ToArray());
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetRandomString(int length, bool isLetterStart, params SymbolFlag[] symbolFlags)
		{
			return GetRandomString(length, isLetterStart, -1, symbolFlags);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetRandomString(int length, params SymbolFlag[] symbolFlags)
		{
			return GetRandomString(length, false, -1, symbolFlags);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static int GetRandomNumber(int maxNumber = 100)
		{
			return GetRandomNumber(0, maxNumber);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static int GetRandomNumber(int minNumber, int maxNumber)
		{
			using (var rngGenerator = new RNGCryptoServiceProvider())
			{
				var b = new byte[4];
				rngGenerator.GetBytes(b);
				var seed = (b[0] & 0x7f) << 24 | b[1] << 16 | b[2] << 8 | b[3];
				var r = new Random(seed);

				return r.Next(minNumber, maxNumber);
			}
		}
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static partial class DateTimeHelpers
	{
		/// <summary>
		///     Gets the number of seconds that has passed since 1/1/1970 12AM.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="endDate">[OPTIONAL=UtcNow] The date to count to.</param>
		/// <returns>Number of seconds.</returns>
		public static long GetSecondsSinceEpoch(DateTime? endDate = null)
		{
			return (long)(endDate ?? DateTime.UtcNow).Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;
		}

		/// <summary>
		///     Gets the day occurence of month.<br />
		///     Credit: http://stackoverflow.com/a/18621645/1919456
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static DateTime? GetDayOccurrenceOfMonth(DateTime dateOfMonth, DayOfWeek dayOfWeek, bool isLastOccurrence)
		{
			return GetDayOccurrenceOfMonth(dateOfMonth, dayOfWeek, 5, isLastOccurrence);
		}

		/// <summary>
		///     Gets the day occurence of month.<br />
		///     Credit: http://stackoverflow.com/a/18621645/1919456
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static DateTime? GetDayOccurrenceOfMonth(DateTime dateOfMonth, DayOfWeek dayOfWeek, int occurrence,
			bool isLastOccurrence)
		{
			occurrence.RequireInRange(1, 5, "occurrence", "Occurrence must be greater than zero and less than 6.");

			if (isLastOccurrence)
			{
				occurrence = 5;
			}

			// Change to first day of the month
			var dayOfMonth = dateOfMonth.AddDays(1 - dateOfMonth.Day);

			// Find first dayOfWeek of this month;
			if (dayOfMonth.DayOfWeek > dayOfWeek)
			{
				dayOfMonth = dayOfMonth.AddDays(7 - (int)dayOfMonth.DayOfWeek + (int)dayOfWeek);
			}
			else
			{
				dayOfMonth = dayOfMonth.AddDays((int)dayOfWeek - (int)dayOfMonth.DayOfWeek);
			}

			// add 7 days per occurrence
			dayOfMonth = dayOfMonth.AddDays(7 * (occurrence - 1));

			// make sure this occurrence is within the original month
			if (dayOfMonth.Month == dateOfMonth.Month)
			{
				return dayOfMonth;
			}
			else
			{
				if (isLastOccurrence)
				{
					return dayOfMonth.AddDays(-7);
				}

				return null;
			}
		}
	}

	/// <summary>
	///     credit: http://pietschsoft.com/post/2008/02/net-35-json-serialization-using-the-datacontractjsonserializer <br />
	///		Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static partial class SerialiserHelpers
	{
		// credit: http://stackoverflow.com/a/12845153/1919456
		public static string SerialiseBase64<T>(this T value) where T : class
		{
			using (var stream = new MemoryStream())
			{
				using (var writer = XmlDictionaryWriter.CreateBinaryWriter(stream))
				{
					var serialiser = new DataContractSerializer(value.GetType());
					serialiser.WriteObject(writer, value);
					return Convert.ToBase64String(stream.ToArray());
				}
			}
		}

		public static T DeserialiseBase64<T>(this string base64) where T : class
		{
			using (var stream = new MemoryStream(Convert.FromBase64String(base64)))
			{
				using (var reader = XmlDictionaryReader
					.CreateBinaryReader(stream, XmlDictionaryReaderQuotas.Max))
				{
					var serialiser = new DataContractSerializer(typeof(T));
					return (T)serialiser.ReadObject(reader);
				}
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string SerialiseStrictXml<T>(T obj) where T : class
		{
			using (var stream = new MemoryStream())
			{
				var serialiser = new DataContractSerializer(obj.GetType());
				serialiser.WriteObject(stream, obj);
				return Encoding.UTF8.GetString(stream.ToArray());
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static T DeserialiseStrictXml<T>(string xml) where T : class
		{
			using (var stream = new MemoryStream(Encoding.UTF8.GetBytes(xml)))
			{
				var serialiser = new DataContractSerializer(typeof(T));
				return (T)serialiser.ReadObject(stream);
			}
		}

		/// <summary>
		///     Author: Ramy Victor
		/// </summary>
		public static string SerialiseContractXml<T>(this T obj) where T : class
		{
			using (var stream = new MemoryStream())
			{
				var serialiser = new XmlSerializer(typeof(T));
				serialiser.Serialize(stream, obj);
				stream.Position = 0;
				return Encoding.UTF8.GetString(stream.ToArray());
			}
		}

		/// <summary>
		///     Author: Ramy Victor
		/// </summary>
		public static T DeserialiseContractXml<T>(this string xml) where T : class
		{
			using (var read = new StringReader(xml))
			{
				using (XmlReader reader = new XmlTextReader(read))
				{
					var serialiser = new XmlSerializer(typeof(T));
					return (T)serialiser.Deserialize(reader);
				}
			}
		}

		public static string SerialiseSimpleDictionary<T>(T obj)
		{
			using (var stream = new MemoryStream())
			{
				GetDictSerializer<T>().WriteObject(stream, obj);
				return Encoding.UTF8.GetString(stream.ToArray());
			}
		}

		public static T DeserialiseSimpleDictionary<T>(string json)
		{
			using (var stream = new MemoryStream())
			{
				using (var writer = new StreamWriter(stream))
				{
					writer.Write(json);
					writer.Flush();
					stream.Position = 0;
					return (T)GetDictSerializer<T>().ReadObject(stream);
				}
			}
		}

		private static DataContractJsonSerializer GetDictSerializer<T>()
		{
			var settings =
				new DataContractJsonSerializerSettings
				{
					UseSimpleDictionaryFormat = true
				};

			return new DataContractJsonSerializer(typeof(T), settings);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string SerialiseSimpleJson(IDictionary<string, string> dictionary, bool isUnformatted = false)
		{
			var pairs = dictionary.Select(pair =>
				string.Format((isUnformatted ? string.Empty : "\t") + "\"{0}\":\"{1}\"", pair.Key, pair.Value?.StringLiteral()))
				.ToArray();
			return "{" + (isUnformatted ? string.Empty : "\r\n") + (pairs.Any() ?
				pairs.Aggregate((e1, e2) => e1 + "," + (isUnformatted ? string.Empty : "\r\n") + e2) : string.Empty)
				+ (isUnformatted ? string.Empty : "\r\n") + "}";
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IDictionary<string, string> DeserialiseSimpleJson(string json)
		{
			if (json.IsEmpty())
			{
				return new Dictionary<string, string>();
			}

			var matches = Regex.Matches(json,
				@"\s*,?\s*['""]?([^{}""'\s]*?)['""]?(?:\s*:\s*)(true|false|\d+|[^\\]?['""](?:\\""|\\'|[^{}'""])*?[^\\]?['""])");

			if (matches.Count <= 0)
			{
				throw new FormatException("JSON is empty or poorly formatted.");
			}

			var dictionary = new Dictionary<string, string>();

			foreach (Match match in matches)
			{
				var groups = match.Groups;

				// the whole string is a match and the rest are pairs
				if ((groups.Count - 1) % 2 != 0)
				{
					throw new FormatException("JSON is poorly formatted.");
				}

				if (string.IsNullOrEmpty(groups[2].Value))
				{
					continue;
				}

				dictionary.Add(groups[1].Value, groups[2].Value.Trim('\'', '\"').StringUnliteral());
			}

			return dictionary;
		}

		/// <summary>
		/// Serialises the object into JSON using the .NET <see cref="DataContractJsonSerializer" />.<br />
		/// Classes must be decorated with <see cref="DataContract" /> and member with <see cref="DataMember" />.<br />
		/// To aid in serialisation, known types can be passed, or pass null and the method will automatically
		/// attempt to find the types. You can optionally limit the scope of the search to the provided type's assembly.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <typeparam name="T">Return type.</typeparam>
		/// <param name="obj">The object to serialise.</param>
		/// <param name="isSerializeReadOnlyTypes">If set to <c>true</c> will serialise <c>readonly</c>
		/// and properties with a <c>get</c> only.</param>
		/// <param name="knownTypes">The known types to consider when serialising.</param>
		/// <param name="assembliesScope">The assemblies scope.</param>
		/// <param name="surrogate">The surrogate.</param>
		/// <param name="latestError">The latest error.</param>
		public static string SerialiseContractJson<T>(this T obj, bool isSerializeReadOnlyTypes = false, IEnumerable<Type> knownTypes = null,
			Assembly[] assembliesScope = null, IDataContractSurrogate surrogate = null, string latestError = null)
			where T : class
		{
			IReadOnlyList<Type> knownTypesArray = knownTypes?.ToArray() ?? Type.EmptyTypes;

			try
			{
				using (var memoryStream = new MemoryStream())
				{
					var serialiser = new DataContractJsonSerializer(typeof(T),
						BuildSerialisationSettings(isSerializeReadOnlyTypes, knownTypesArray, surrogate));
					serialiser.WriteObject(memoryStream, obj);
					return Encoding.Default.GetString(memoryStream.ToArray());
				}
			}
			catch (SerializationException ex)
			{
				var serialised = HandleSerialisationException(ref knownTypesArray, assembliesScope, ref latestError, ex);

				if (serialised)
				{
					return obj.SerialiseContractJson(isSerializeReadOnlyTypes, knownTypesArray, assembliesScope, surrogate, latestError);
				}

				return null;
			}
		}

		/// <summary>
		/// Deserialises the object into JSON using the .NET <see cref="DataContractJsonSerializer" />.<br />
		/// Classes must be decorated with <see cref="DataContract" /> and member with <see cref="DataMember" />.<br />
		/// To aid in deserialisation, known types can be passed, or pass null and the method will automatically
		/// attempt to find the types. You can optionally limit the scope of the search to the provided type's assembly.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <typeparam name="T">Return type.</typeparam>
		/// <param name="json">The json.</param>
		/// <param name="isSerializeReadOnlyTypes">If set to <c>true</c> will deserialise <c>readonly</c>
		/// and properties with a <c>get</c> only.</param>
		/// <param name="knownTypes">The known types to consider when deserialising.</param>
		/// <param name="assembliesScope">The assemblies scope.</param>
		/// <param name="surrogate">The surrogate.</param>
		/// <param name="latestError">The latest error.</param>
		public static T DeserialiseContractJson<T>(this string json, bool isSerializeReadOnlyTypes = false, IEnumerable<Type> knownTypes = null,
			Assembly[] assembliesScope = null, IDataContractSurrogate surrogate = null, string latestError = null)
			where T : class
		{
			IReadOnlyList<Type> knownTypesArray = knownTypes?.ToArray() ?? Type.EmptyTypes;

			try
			{
				using (var memoryStream = new MemoryStream(Encoding.UTF8.GetBytes(json)))
				{
					var serialiser = new DataContractJsonSerializer(typeof(T),
						BuildSerialisationSettings(isSerializeReadOnlyTypes, knownTypesArray, surrogate));
					return (T)serialiser.ReadObject(memoryStream);
				}
			}
			catch (SerializationException ex)
			{
				var serialised = HandleSerialisationException(ref knownTypesArray, assembliesScope, ref latestError, ex);

				if (serialised)
				{
					return json.DeserialiseContractJson<T>(isSerializeReadOnlyTypes, knownTypesArray, assembliesScope,
						surrogate, latestError);
				}

				return null;
			}
		}

		private static bool HandleSerialisationException(ref IReadOnlyList<Type> knownTypes, Assembly[] assembliesScope,
			ref string latestError, SerializationException ex)
		{
			if (latestError == ex.Message)
			{
				throw new SerializationException($"Type is unsupported by [de]serialisation => '{latestError}'.");
			}

			latestError = ex.Message;

			var match = Regex.Match(ex.Message, @"Type '(.+?)'");

			if (match.Groups.Count <= 1)
			{
				match = Regex.Match(ex.Message, @"'https?://.*?/([\w\.]+:(\w+))'");
			}

			if (match.Groups.Count > 1)
			{
				knownTypes = knownTypes.Union(
					new[]
					{
						TypeHelpers.GetType(match.Groups[1].ToString().Replace(':', '.'), assembliesScope)
							?? TypeHelpers.GetType(match.Groups[2].ToString(), assembliesScope)
					}).Where(e => e != null).ToArray();
				return true;
			}

			throw new SerializationException($"Type is unsupported by [de]serialisation => '{latestError}'.");
		}

		private static DataContractJsonSerializerSettings BuildSerialisationSettings(bool isSerializeReadOnlyTypes,
			IEnumerable<Type> knownTypes, IDataContractSurrogate surrogate)
		{
			return new DataContractJsonSerializerSettings
				   {
					   UseSimpleDictionaryFormat = true,
					   SerializeReadOnlyTypes = isSerializeReadOnlyTypes,
					   KnownTypes = knownTypes,
					   DataContractSurrogate = surrogate
				   };
		}

		/// <summary>
		/// Credit: https://stackoverflow.com/a/9347678/1919456
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <seealso cref="System.Runtime.Serialization.IDataContractSurrogate" />
		public class DateTimeCrmContractSurrogate : IDataContractSurrogate
		{
	        private static readonly Regex dateRegex = new Regex(@"/Date\((\d+)([-+])?(\d+)?\)/");
	        private static readonly DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);

	        public object GetCustomDataToExport(Type clrType, Type dataContractType)
	        {
	            // not used
	            return null;
	        }

	        public object GetCustomDataToExport(System.Reflection.MemberInfo memberInfo, Type dataContractType)
	        {
	            // not used
	            return null;
	        }

	        public Type GetDataContractType(Type type)
	        {
	            // not used
	            return type;
	        }

	        public object GetDeserializedObject(object obj, Type targetType)
	        {
	            // for debugging
	            //Console.WriteLine("GetDeserializedObject: obj = {0} ({1}), targetType = {2}", obj, obj.GetType(), targetType);

	            if (obj is DataCollection<string, object> dataCollection)
	            {
		            foreach (var item in dataCollection.ToArray())
		            {
			            dataCollection[item.Key] = ConvertDate(item.Value as string) ?? item.Value;
		            }
	            }

	            if (obj is IDictionary<string, object> dictionary)
	            {
		            foreach (var item in dictionary.ToArray())
		            {
			            dictionary[item.Key] = ConvertDate(item.Value as string) ?? item.Value;
		            }
	            }

		        return CustomIterator(obj);
	        }

			protected virtual object CustomIterator(object obj)
			{
				return obj;
			}

			protected static DateTime? ConvertDate(string unparsedDate)
			{
				if (unparsedDate != null)
				{
					// check if we match the DateTime format
					Match match = dateRegex.Match(unparsedDate);

					if (match.Success)
					{
						// try to parse the string into a long. then create a datetime and convert to local time.
						long msFromEpoch;

						if (long.TryParse(match.Groups[1].Value, out msFromEpoch))
						{
							TimeSpan fromEpoch = TimeSpan.FromMilliseconds(msFromEpoch);
							return TimeZoneInfo.ConvertTimeFromUtc(epoch.Add(fromEpoch), TimeZoneInfo.Local);
						}
					}
				}

				return null;
			}

			public void GetKnownCustomDataTypes(System.Collections.ObjectModel.Collection<Type> customDataTypes)
	        {
	            // not used   
	        }

	        public object GetObjectToSerialize(object obj, Type targetType)
	        {
	            // for debugging
	            //Console.WriteLine("GetObjectToSerialize: obj = {0} ({1}), targetType = {2}", obj, obj.GetType(), targetType);
	            return obj;
	        }

	        public Type GetReferencedTypeOnImport(string typeName, string typeNamespace, object customData)
	        {
	            // not used
	            return null;
	        }

	        public System.CodeDom.CodeTypeDeclaration ProcessImportedType(System.CodeDom.CodeTypeDeclaration typeDeclaration, System.CodeDom.CodeCompileUnit compileUnit)
	        {
	            // not used
	            return typeDeclaration;
	        }
	    }
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class CrmParser
	{
		private enum OpType
		{
			Pre,
			Binary,
			Ternary,
			Post
		}

		private const string Operators = @"^(?:[!+\-*/?:<>~]|\|\||&&|\?\?|>=|<=|!=|==)$";

		private static readonly Dictionary<string, OpType> operatorType =
			new()
			{
				{ "!", OpType.Pre },
				{ "~", OpType.Pre },
				{ "*", OpType.Binary },
				{ "/", OpType.Binary },
				{ "+", OpType.Binary },
				{ "-", OpType.Binary },
				{ ">", OpType.Binary },
				{ "<", OpType.Binary },
				{ ">=", OpType.Binary },
				{ "<=", OpType.Binary },
				{ "!=", OpType.Binary },
				{ "==", OpType.Binary },
				{ "||", OpType.Binary },
				{ "&&", OpType.Binary },
				{ "??", OpType.Binary },
				{ "?", OpType.Ternary },
				{ ":", OpType.Ternary }
			};

		private static readonly Dictionary<string, int> operatorPrecedence =
			new()
			{
				{ "!", 200 },
				{ "~", 200 },
				{ "*", 100 },
				{ "/", 100 },
				{ "+", 99 },
				{ "-", 99 },
				{ ">", 75 },
				{ "<", 75 },
				{ ">=", 75 },
				{ "<=", 75 },
				{ "!=", 74 },
				{ "==", 74 },
				{ "&&", 65 },
				{ "||", 64 },
				{ "??", 57 },
				{ "?", 50 },
				{ ":", 50 }
			};

		private static TimeSpan fallbackCacheDuration = TimeSpan.FromMinutes(1);

		#region Entry point

		public static string Parse(string input, params Type[] constructTypes)
		{
			var state = new GlobalState(null, constructTypes);
			return Parse(input, state);
		}

		public static string Parse(string input, IOrganizationService service,
			Guid? orgId = null, params Type[] constructTypes)
		{
			return Parse(input, service, null, orgId, constructTypes);
		}

		public static string Parse(string input, Entity context, IOrganizationService service,
			Guid? orgId = null, params Type[] constructTypes)
		{
			return Parse(input, context, service, null, orgId, constructTypes);
		}

		public static string Parse(string input, EntityReference contextRef, IOrganizationService service,
			Guid? orgId = null, params Type[] constructTypes)
		{
			return Parse(input, contextRef, service, null, orgId, constructTypes);
		}

		public static string Parse(string input, IOrganizationService service, object contextObject,
			Guid? orgId = null, params Type[] constructTypes)
		{
			var state = new GlobalState(service, constructTypes, contextObject, orgId);
			return Parse(input, state);
		}

		public static string Parse(string input, Entity context, IOrganizationService service, object contextObject,
			Guid? orgId = null, params Type[] constructTypes)
		{
			service.Require(nameof(service));
			var state = new GlobalState(context, service, constructTypes, contextObject, orgId);
			return Parse(input, state);
		}

		public static string Parse(string input, EntityReference contextRef, IOrganizationService service, object contextObject,
			Guid? orgId = null, params Type[] constructTypes)
		{
			service.Require(nameof(service));
			var state = new GlobalState(contextRef, service, constructTypes, contextObject, orgId);
			return Parse(input, state);
		}

		#endregion

		private static string Parse(string input, GlobalState state)
		{
			input.Require(nameof(input));
			state.Require(nameof(state));

			var token = new TokenGlobal(input);
			token.ProcessInput();
			return ProcessToken(token, state).FirstOrDefault();
		}

		private static IReadOnlyList<string> ProcessToken(Token token, GlobalState state)
		{
			var result = new List<string>();

			switch (token)
			{
				// starting point
				case TokenGlobal global:
					result.Add(global.Queue.SelectMany(e => ProcessToken(e, state)).StringAggregate(""));
					return result;

				case TokenText:
					result.Add(token.Value);
					return result;

				case TokenParameters tokenParameters:
					result.AddRange(tokenParameters.Queue.Select(e => ProcessToken(e, state)).Select(s => s.StringAggregate("")));
					return result;

				case TokenScope scope:
					result.Add(ProcessScope(scope, state));
					return result;

				case TokenKeyword { Parameters: not null } keyword:
					keyword.ProcessedParams = ProcessToken(keyword.Parameters, state);
					break;
			}

			if (token is TokenConstruct tokenConstruct)
			{
				foreach (var preprocessor in tokenConstruct.Preprocessors)
				{
					ProcessToken(preprocessor, state);
				}

				foreach (var postProcessor in tokenConstruct.PostProcessors)
				{
					ProcessToken(postProcessor, state);
				}

				var construct =
					ConstructFactory
						.GetConstruct(tokenConstruct, state,
							tokenConstruct.Preprocessors.Select(p => ProcessorFactory.GetProcessor<PreprocessorAttribute>(p, state))
								.OfType<Preprocessor>().ToArray(),
							tokenConstruct.PostProcessors.Select(p => ProcessorFactory.GetProcessor<PostProcessorAttribute>(p, state))
								.OfType<PostProcessor>().ToArray());

				if (tokenConstruct.Body != null && construct is not IScoped)
				{
					tokenConstruct.ProcessedBody = ProcessToken(tokenConstruct.Body, state).StringAggregate("");
				}

				result.Add(construct
					.Execute(tokenConstruct.ProcessedBody)
					.StringAggregate(""));

				return result;
			}

			result.Add(token.Value);

			return result;
		}

		#region Tokeniser

		private static string ProcessScope(TokenScope scope, GlobalState state)
		{
			var stack = new Stack<Token>(scope.Stack);

			var opStack = new Stack<Token>();
			var operandStack = new Stack<Token>();

			Token previousToken = null;

			while (true)
			{
				if (!stack.Any())
				{
					var currentStack = operandStack;

					while (opStack.Any() || operandStack.Any())
					{
						if (currentStack.Any())
						{
							stack.Push(currentStack.Pop());
						}

						currentStack = currentStack == operandStack ? opStack : operandStack;
					}
				}

				if (!stack.Any())
				{
					return string.Empty;
				}

				if (stack.All(t => t is TokenText || t is TokenOperand) && !opStack.Any() && !operandStack.Any())
				{
					return stack.Select(t => t.Value).StringAggregate("");
				}

				var token = stack.Pop();

				if (token is TokenOperator && token.Value == "-" && previousToken is null or TokenOperator)
				{
					token.Value = "~";
				}

				previousToken = token;

				switch (token)
				{
					case TokenOperator:
						ProcessOperator(stack, token, opStack, operandStack, scope.ErrorLocationContext);
						break;

					case TokenOperand operandToken:
						while (opStack.Any() && operatorType[opStack.Peek().Value] == OpType.Pre)
						{
							operandToken.Value = ProcessOperation(opStack.Pop().Value, token, token.Value);
						}

						operandStack.Push(token);
						break;

					default:
						operandStack.Push(new TokenOperand(ProcessToken(token, state).StringAggregate("")));
						break;
				}
			}
		}

		private static void ProcessOperator(Stack<Token> stack, Token token, Stack<Token> opStack,
			Stack<Token> operandStack, string errorLocationContext)
		{
			var op = (TokenOperator)token;

			if (!operatorType.TryGetValue(op.Value, out var opType))
			{
				throw new InvalidOperationException($"Unknown operator '{op.Value}' at {errorLocationContext}");
			}

			switch (opType)
			{
				case OpType.Pre:
					opStack.Push(token);
					break;

				case OpType.Binary:
				{
					if (operandStack.IsEmpty() || stack.IsEmpty())
					{
						throw new InvalidOperationException($"Operator '{op.Value}' missing an operand: {errorLocationContext}");
					}

					Token nextOp = null;

					if (stack.Count >= 2)
					{
						var temp1 = stack.Pop();
						nextOp = stack.Peek();
						stack.Push(temp1);
					}

					if (stack.Peek() is TokenOperand &&
						(!opStack.Any()
							|| (opStack.Any() && opStack.Peek() is TokenOperator
								&& operatorPrecedence[opStack.Peek().Value.Trim()] < operatorPrecedence[token.Value.Trim()]))
						&& (nextOp is not TokenOperator || operatorPrecedence[nextOp.Value.Trim()] <= operatorPrecedence[token.Value.Trim()]))
					{
						var operand1 = operandStack.Pop();
						var operand2 = stack.Pop();
						operand1.Value = ProcessOperation(token.Value, token, operand1.Value, operand2.Value);
						operandStack.Push(operand1);
					}
					else
					{
						opStack.Push(token);
					}

					break;
				}

				case OpType.Ternary:
				{
					opStack.Push(token);

					if (opStack.Union(stack).OfType<TokenOperator>().Any(o => operatorType[o.Value] != OpType.Ternary))
					{
						break;
					}

					var currentStack = opStack;

					while (opStack.Any() || operandStack.Any())
					{
						if (currentStack.Any())
						{
							stack.Push(currentStack.Pop());
						}

						currentStack = currentStack == operandStack ? opStack : operandStack;
					}

					var ternaryStack = new Stack<Token>(stack);
					stack.Clear();

					while (ternaryStack.Count >= 5)
					{
						var operand2 = ternaryStack.Pop();
						ternaryStack.Pop(); // :
						var operand1 = ternaryStack.Pop();
						ternaryStack.Pop(); // ?
						var condition = ternaryStack.Pop();

						ternaryStack.Push(bool.Parse(ProcessOperation("!", condition, condition.Value)) ? operand2 : operand1);
					}

					if (ternaryStack.Count != 1)
					{
						throw new InvalidOperationException(
							$"Ternary operation failed: {ternaryStack.Reverse().Select(e => e.Value).StringAggregate("")}"
								+ $" at {errorLocationContext}");
					}

					stack.Push(ternaryStack.Pop());

					break;
				}

				case OpType.Post:
				{
					if (operandStack.IsEmpty())
					{
						throw new InvalidOperationException($"PostOperator '{op.Value}' missing an operand: {errorLocationContext}");
					}

					var operand = operandStack.Pop();
					operand.Value = ProcessOperation(token.Value, token, operand.Value);
					operandStack.Push(operand);

					break;
				}

				default:
					throw new ArgumentOutOfRangeException(nameof(opType), opType, $"OpType is unsupported: {token.ErrorLocationContext}");
			}
		}

		private static string ProcessOperation(string op, Token token, params string[] operands)
		{
			var opType = operatorType[op];

			switch (opType)
			{
				case OpType.Ternary:
					{
						//var t3 = tokenStack.Pop();
						//var t2 = tokenStack.Pop();
						//var t1 = tokenStack.Pop();
						break;
					}

				case OpType.Binary:
					{
						if (Regex.IsMatch(op, @"^(?:[+\-*/])$"))
						{
							var isT1Num = double.TryParse(operands[0], out var doubleT1);
							var isT2Num = double.TryParse(operands[1], out var doubleT2);

							if (isT1Num && isT2Num)
							{
								return (op switch
								{
									"+" => (doubleT1 + doubleT2),
									"-" => (doubleT1 - doubleT2),
									"*" => (doubleT1 * doubleT2),
									"/" => (doubleT1 / doubleT2)
								}).ToString();
							}

							var isT1Date = DateTime.TryParse(operands[0], out var dateT1);
							var isT2Date = DateTime.TryParse(operands[1], out var dateT2);

							if (Regex.IsMatch(op, @"^(?:[+\-])$") && (isT1Date || isT2Date))
							{
								return ApplyDateOp(isT1Date ? dateT1 : dateT2, op,
									isT1Date ? operands[1] : operands[0], token).ToString("s");
							}

							throw new FormatException($"Invalid operation on operands: {operands[0]}{op}{operands[1]} at {token.ErrorLocationContext}");
						}

						switch (op)
						{
							case "||":
								{
									var t1Bool = bool.TryParse(operands[0], out var t1);
									var t2Bool = bool.TryParse(operands[0], out var t2);

									if (t1Bool && t2Bool)
									{
										return (t1 || t2).ToString();
									}

									throw new FormatException($"Invalid operand types: {operands[0]}{op}{operands[1]} at {token.ErrorLocationContext}");
								}

							case "&&":
								{
									var t1Bool = bool.TryParse(operands[0], out var t1);
									var t2Bool = bool.TryParse(operands[0], out var t2);

									if (t1Bool && t2Bool)
									{
										return (t1 && t2).ToString();
									}

									throw new FormatException($"Invalid operand types: {operands[0]}{op}{operands[1]} at {token.ErrorLocationContext}");
								}

							case "??":
								{
									var t1 = ParseValue(operands[0]);
									var t2 = ParseValue(operands[1]);
									return (t1 ?? t2)?.ToString() ?? string.Empty;
								}

							case "<":
								{
									var t1 = ParseValue(operands[0]);
									var t2 = ParseValue(operands[1]);
									return (t1?.CompareTo(t2) < 0).ToString();
								}

							case ">":
								{
									var t1 = ParseValue(operands[0]);
									var t2 = ParseValue(operands[1]);
									return (t1?.CompareTo(t2) > 0).ToString();
								}

							case ">=":
								{
									var t1 = ParseValue(operands[0]);
									var t2 = ParseValue(operands[1]);
									return (t1?.CompareTo(t2) >= 0).ToString();
								}

							case "<=":
								{
									var t1 = ParseValue(operands[0]);
									var t2 = ParseValue(operands[1]);
									return (t1?.CompareTo(t2) <= 0).ToString();
								}

							case "==":
								{
									var t1 = ParseValue(operands[0]);
									var t2 = ParseValue(operands[1]);
									return ((t1 == null && t2 == null) || t1?.Equals(t2) == true || t2?.Equals(t1) == true).ToString();
								}

							case "!=":
								{
									var t1 = ParseValue(operands[0]);
									var t2 = ParseValue(operands[1]);
									return (!((t1 == null && t2 == null) || t1?.Equals(t2) == true || t2?.Equals(t1) == true)).ToString();
								}
						}

						break;
					}

				case OpType.Pre:
					{
						switch (op)
						{
							case "!":
								{
									var t1Bool = bool.TryParse(operands[0], out var t1);

									if (t1Bool)
									{
										return (!t1).ToString();
									}

									throw new FormatException($"Invalid operand types: {operands[0]} at {token.ErrorLocationContext}");
								}

							case "~":
								{
									var t1Double = double.TryParse(operands[0], out var t1);

									if (t1Double)
									{
										return (-t1).ToString();
									}

									throw new FormatException($"Invalid operand types: {operands[0]} at {token.ErrorLocationContext}");
								}
						}

						break;
					}

				case OpType.Post:
					{
						break;
					}

				default:
					throw new ArgumentOutOfRangeException(nameof(opType), opType, $"OpType is unsupported: {token.ErrorLocationContext}");
			}

			return string.Empty;
		}

		private static IComparable ParseValue(string value)
		{
			if (value.IsEmpty() || value == "null")
			{
				return null;
			}

			if (int.TryParse(value, out int intValue))
			{
				return intValue;
			}

			if (double.TryParse(value, out var doubleValue))
			{
				return doubleValue;
			}

			if (DateTime.TryParse(value, out var dateValue))
			{
				return dateValue;
			}

			if (bool.TryParse(value, out var boolValue))
			{
				return boolValue;
			}

			return value;
		}

		private static DateTime ApplyDateOp(DateTime date, string op, string value, Token token)
		{
			op.RequireFormat(@"^[+\-]$", nameof(op), $"Date operator is invalid: {date}{op}");

			if (value.IsEmpty())
			{
				throw new FormatException($"Date operand is empty: {date}{op}x at {token.ErrorLocationContext}");
			}

			var isSpan = TimeSpan.TryParse(value, out var span);

			if (isSpan)
			{
				return op switch
				{
					"+" => date + span,
					"-" => date - span
				};
			}

			foreach (var s in Regex.Match(value, @"^(\d+[yMdhmsf])+$").Groups[1].ExtractCaptures())
			{
				var amount = (int)double.Parse(Regex.Match(s, @"^(\d+)(.+)$").Groups[1].ExtractCaptures().FirstOrDefault() ?? "0")
					* (op == "+" ? 1 : -1);
				var unit = Regex.Match(s, @"^(\d+)(.+)$").Groups[2].ExtractCaptures().FirstOrDefault();

				date = unit switch
				{
					"y" => date.AddYears(amount),
					"M" => date.AddMonths(amount),
					"d" => date.AddDays(amount),
					"h" => date.AddHours(amount),
					"m" => date.AddMinutes(amount),
					"s" => date.AddSeconds(amount),
					"f" => date.AddMilliseconds(amount),
				};
			}

			return date;
		}

		#endregion
		
		private static IEnumerable<Entity> BuildTraversalContext(Entity context, IReadOnlyList<string> traversal,
			GlobalState state, IReadOnlyList<string> distinctFields,
			IReadOnlyList<string> orderFields, bool isCacheResult, bool isCacheGlobal)
		{
			IEnumerable<Entity> contextBuffer = new[] { context };

			foreach (var n in traversal)
			{
				var isRelation = n.StartsWith("#");
				var node = n.TrimStart('.', '#');

				contextBuffer = contextBuffer.SelectMany(
					c =>
					{
						if (isRelation)
						{
							var attributes = distinctFields?.Union(orderFields?.Select(o => o.Trim('#')) ?? Array.Empty<string>()).Distinct().ToArray();
							attributes = attributes?.Any() == true ? attributes : Array.Empty<string>();
							var key = $"CrmParser.BuildContextBuffer|{c.LogicalName}|{c.Id}|{node}|{attributes.StringAggregate()}";

							var related = c
								.RelatedEntities
								.Where(r => r.Key.SchemaName == node && r.Value != null)
								.SelectMany(r => r.Value?.Entities).ToArray();

							related =
								related.Any()
									? related
									: state.GetCachedAdd(key, () =>
									CrmHelpers.GetRelatedRecords(state.Service, c.ToEntityReference(), node, null, state.OrgId, attributes)
										.ToArray(),
									isCacheGlobal);

							if (related.Any())
							{
								c.RelatedEntities[new Relationship(node)] = new EntityCollection(related);
							}

							var q = related.AsEnumerable();

							if (distinctFields.IsFilled())
							{
								q = q.DistinctBy(
									e => distinctFields
										.Select(s => CrmHelpers.GetAttributeName(s, e))
										.StringAggregate());
							}

							if (orderFields.IsFilled())
							{
								var ordered = q.OrderBy(e => e.Id);

								for (var i = 0; i < orderFields.Count; i++)
								{
									var orderRaw = orderFields[i];
									var order = orderRaw.Trim('#');
									var isDesc = orderRaw.StartsWith("#");

									if (i == 0)
									{
										if (isDesc)
										{
											ordered = ordered.OrderByDescending(e =>
												CrmHelpers.GetAttributeName(order, e));
										}
										else
										{
											ordered = ordered.OrderBy(e =>
												CrmHelpers.GetAttributeName(order, e));
										}
									}
									else
									{
										if (isDesc)
										{
											ordered = ordered.ThenByDescending(e =>
												CrmHelpers.GetAttributeName(order, e));
										}
										else
										{
											ordered = ordered.ThenBy(e =>
												CrmHelpers.GetAttributeName(order, e));
										}
									}
								}

								q = ordered;
							}

							return q;
						}
						else
						{
							var fieldValue = c.GetAttributeValue<object>(node);

							// get the entity record
							c = fieldValue == null && c.LogicalName.IsFilled() && c.Id != Guid.Empty
								? c.IntegrateAttributes(Retrieve(state, c.LogicalName, c.Id, 
									isCacheResult, isCacheGlobal, node))
								: c;

							fieldValue = c.GetAttributeValue<object>(node);

							// if the field value is not a lookup, then we can't recurse
							if (!(fieldValue is EntityReference reference))
							{
								throw new Exception($"Field \"{node}\" is not a lookup.");
							}

							return
								new[]
								{
									new Entity(reference.LogicalName)
									{
										Id = reference.Id
									}
								};
						}
					});
			}

			return contextBuffer;
		}

		private static string UnescapeHtml(string expression)
		{
			return Regex.Replace(expression, "(?:([^`]*)|(?:(?<c>`)[^`]*?(?<-c>`))(?(c)(?!)))*",
				m =>
				{
					if (!m.Success)
					{
						return string.Empty;
					}

					return HttpUtility.HtmlDecode(m.Value);
				});
		}

		public static Entity Retrieve(GlobalState state,
			string entityName, Guid id, bool isCache, bool isCacheGlobal, params string [] attributes)
		{
			Entity Action() => state.Service.Retrieve(entityName, id,
				attributes?.Any() == true ? new ColumnSet(attributes) : new ColumnSet(false));

			return isCache
				? state.GetCachedAdd($"CrmParser.Retrieve|{entityName}|{id}|{attributes.StringAggregate()}", Action, isCacheGlobal)
				: Action();
		}

		public static Entity[] RetrieveMultiple(IOrganizationService service, GlobalState state, string fetchXml,
			bool isCache, bool isCacheGlobal)
		{
			Entity[] Action() => CrmHelpers.RetrieveRecords(service, fetchXml).ToArray();

			return isCache
				? state.GetCachedAdd($"CrmParser.RetrieveMultiple|{fetchXml}", Action, isCacheGlobal)
				: Action();
		}

		public static Entity CallAction(IOrganizationService service, string actionName, EntityReference target, string parameters)
		{
			var request = new OrganizationRequest(actionName);

			if (parameters.IsFilled())
			{
				foreach (var pair in SerialiserHelpers.DeserialiseSimpleJson(parameters))
				{
					request[pair.Key] = pair.Value;
				}
			}

			if (target != null)
			{
				request["Target"] = target;
			}

			var result = new Entity();

			foreach (var pair in service.Execute(request).Results)
			{
				var key = pair.Key;
				var value = pair.Value;

				if (value is EntityCollection collection)
				{
					if (collection.Entities.Any())
					{
						result.RelatedEntities[new Relationship(key)] = new EntityCollection(collection.Entities);
					}
				}
				else
				{
					result[pair.Key] = pair.Value;
				}
			}

			return result;
		}

		#region Text parser classes

		public abstract class Token
		{
			public virtual string Value { get; set; }

			private readonly Stack<Token> stack = new();

			protected readonly Queue<char> Input;
			protected string CurrentChar;
			protected string CurrentBuffer;
			protected readonly StringBuilder Buffer = new();

			private bool isEscapeMode;

			protected readonly List<string> RawCharList;
			public string ErrorLocationContext { get; private set; }

			protected Token(string value = "")
			{
				Value = value;
			}

			protected Token(Queue<char> input, List<string> rawCharList)
			{
				Input = input;
				RawCharList = rawCharList;
			}

			protected Token(Queue<char> input, List<string> rawCharList, string value = "") : this(input, rawCharList)
			{
				Value = value;
			}

			public void ProcessInput()
			{
				while (Input.Any())
				{
					CurrentBuffer = Buffer.ToString();
					CurrentChar = Dequeue();

					if (isEscapeMode)
					{
						if (CurrentChar == "`")
						{
							isEscapeMode = false;
							continue;
						}

						ProcessEscapedChar(Buffer, CurrentChar);

						continue;
					}

					switch (CurrentChar)
					{
						case @"\":
							Buffer.Append(Dequeue());
							continue;

						case "`":
							isEscapeMode = true;
							continue;
					}

					if (!ProcessCharacter())
					{
						break;
					}
				}

				PostProcess();

				SetErrorLocationContext();
			}

			protected abstract bool ProcessCharacter();

			protected abstract void PostProcess();

			protected virtual void ProcessEscapedChar(StringBuilder buffer, string character)
			{
				buffer.Append(character);
			}

			protected string Dequeue()
			{
				var character = Input.Any() ? Input.Dequeue().ToString() : "";
				RawCharList.Add(character);
				return character;
			}

			protected void ClearBuffer()
			{
				Buffer.Clear();
				CurrentBuffer = null;
			}

			protected void ThrowFormatException(string message)
			{
				SetErrorLocationContext();

				throw new FormatException($"{message}: {ErrorLocationContext}",
					new FormatException($"{this} {CurrentBuffer}{CurrentChar}"));
			}

			private void SetErrorLocationContext()
			{
				var skip = Math.Max(RawCharList.Count - 100, 0);
				var take = Math.Max(RawCharList.Count - skip, 1);

				ErrorLocationContext = $"{(skip > 0 ? "[...]" : "")}{RawCharList.Skip(skip).Take(take).StringAggregate("")}";
			}

			public override string ToString()
			{
				return $"{GetType().Name}{(Value.IsFilled() ? $":{Value}" : "")}";
			}
		}

		public class TokenGlobal : Token
		{
			public readonly Stack<Token> Stack = new();
			public Queue<Token> Queue => new(Stack.Reverse());

			public TokenGlobal(string input) : base(new Queue<char>(input), new List<string>())
			{ }

			protected override bool ProcessCharacter()
			{
				if (CurrentChar == "{")
				{
					if (CurrentBuffer.IsAny())
					{
						Stack.Push(new TokenText(CurrentBuffer));
						ClearBuffer();
					}

					var construct = new TokenConstruct(Input, RawCharList);
					construct.ProcessInput();
					Stack.Push(construct);

					return true;
				}

				Buffer.Append(CurrentChar);
				return true;
			}

			protected override void PostProcess()
			{
				if (Buffer.Length <= 0)
				{
					return;
				}

				CurrentBuffer = Buffer.ToString();
				Stack.Push(new TokenText(CurrentBuffer));
				ClearBuffer();
			}
		}

		public abstract class TokenCode : Token
		{
			protected TokenCode(string value = "") : base(value)
			{ }

			protected TokenCode(Queue<char> input, List<string> rawCharList, string value = "") : base(input, rawCharList, value)
			{ }
		}

		public class TokenScope : TokenCode
		{
			public readonly Stack<Token> Stack = new();
			public Queue<Token> Queue => new(Stack.Reverse());

			public TokenScope(Queue<char> input, List<string> rawCharList) : base(input, rawCharList)
			{ }

			protected override bool ProcessCharacter()
			{
				if (CurrentChar == "{")
				{
					if (CurrentBuffer.IsAny())
					{
						Stack.Push(new TokenOperand(CurrentBuffer));
						ClearBuffer();
					}

					var construct = new TokenConstruct(Input, RawCharList);
					construct.ProcessInput();
					Stack.Push(construct);

					return true;
				}
				
				if (Regex.IsMatch(CurrentChar, @"[()]"))
				{
					if (CurrentBuffer.IsAny())
					{
						Stack.Push(new TokenOperand(CurrentBuffer));
						ClearBuffer();
					}
				
					if (CurrentChar == "(")
					{
						var scope = new TokenScope(Input, RawCharList);
						scope.ProcessInput();
						Stack.Push(scope);
					}
				
					if (CurrentChar == ")")
					{
						return false;
					}

					return true;
				}

				if (Regex.IsMatch(CurrentChar, @"\s"))
				{
					return true;
				}

				var isOp = Regex.IsMatch(CurrentChar, Operators);

				if (Input.Any())
				{
					var doubleOp = CurrentChar + Input.Peek();
					var isDoubleOp = Regex.IsMatch(doubleOp, Operators);

					if (isDoubleOp)
					{
						Dequeue();
						isOp = true;
						CurrentChar = doubleOp;
					}
				}
				
				if (isOp)
				{
					if (CurrentBuffer.IsAny())
					{
						Stack.Push(new TokenOperand(CurrentBuffer));
						ClearBuffer();
					}

					Stack.Push(new TokenOperator(CurrentChar));
					return true;
				}

				Buffer.Append(CurrentChar);

				return true;
			}

			protected override void PostProcess()
			{
				if (Buffer.Length <= 0)
				{
					return;
				}

				CurrentBuffer = Buffer.ToString();
				Stack.Push(GetType() == typeof(Token) ? new TokenText(CurrentBuffer) : new TokenOperand(CurrentBuffer));
				ClearBuffer();
			}

			public override string ToString()
			{
				return $"{base.ToString()}{(Stack.Any() ? $">({Stack.Select(t => t.ToString()).Reverse().StringAggregate(" ")})" : "")}";
			}
		}

		public class TokenParameters : TokenScope
		{
			private bool isLatestComma;

			public TokenParameters(Queue<char> input, List<string> rawCharList) : base(input, rawCharList)
			{ }

			protected override bool ProcessCharacter()
			{
				switch (CurrentChar)
				{
					case ",":
						Stack.Push(new TokenOperand(CurrentBuffer));
						ClearBuffer();
						isLatestComma = true;
						return true;

					case ")" when isLatestComma:
						Stack.Push(new TokenOperand(CurrentBuffer));
						ClearBuffer();
						return false;

					default:
						isLatestComma = false;
						return base.ProcessCharacter();
				}
			}
		}

		public class TokenBody : TokenScope
		{
			public TokenBody(Queue<char> input, List<string> rawCharList) : base(input, rawCharList)
			{ }

			protected override bool ProcessCharacter()
			{
				if (!base.ProcessCharacter())
				{
					return false;
				}

				if (CurrentChar == "|")
				{
					if (CurrentBuffer.IsAny())
					{
						Stack.Push(new TokenOperand(CurrentBuffer));
					}

					ClearBuffer();
					return false;
				}

				return true;
			}
		}

		public abstract class TokenKeyword : TokenCode
		{
			protected abstract char StartChar { get; }
			protected abstract char EndChar { get; }

			public TokenParameters Parameters;
			public IReadOnlyList<string> ProcessedParams = Array.Empty<string>();

			public bool IsDefined => Value.IsFilled();

			protected TokenKeyword(Queue<char> input, List<string> rawCharList) : base(input, rawCharList)
			{ }

			protected override bool ProcessCharacter()
			{
				if (Regex.IsMatch(CurrentChar, @"\s"))
				{
					return true;
				}

				if (IsDefined)
				{
					if (CurrentChar == "(")
					{
						if (Parameters != null)
						{
							ThrowFormatException("Cannot define parameters at this position");
						}

						Parameters = new TokenParameters(Input, RawCharList);
						Parameters.ProcessInput();

						return true;
					}

					if (CurrentChar == EndChar.ToString())
					{
						if (CurrentBuffer.IsFilled() && CurrentBuffer != Value)
						{
							ThrowFormatException($"Keyword closure mismatch ({CurrentBuffer} should be {Value})");
						}

						return false;
					}

					ProcessKeyword();
				}
				else
				{
					if (Value.IsEmpty() && Regex.IsMatch(CurrentChar, @"[`{}@%|()\\]"))
					{
						Value = CurrentBuffer;
						ClearBuffer();
						return ProcessCharacter();
					}

					Buffer.Append(CurrentChar);
				}

				return true;
			}

			protected abstract void ProcessKeyword();

			protected void ValidateEmptyBuffer()
			{
				if (CurrentBuffer.IsAny())
				{
					ThrowFormatException("Previous characters are in an invalid position");
				}
			}

			protected override void PostProcess()
			{ }

			public override string ToString()
			{
				return $"{base.ToString()} {Parameters}";
			}
		}

		public class TokenConstruct : TokenKeyword
		{
			public readonly List<TokenPreprocessor> Preprocessors = new();
			public TokenBody Body;
			public string ProcessedBody;
			public readonly List<TokenPostProcessor> PostProcessors = new();

			protected override char StartChar => '{';
			protected override char EndChar => '}';

			public TokenConstruct(Queue<char> input, List<string> rawCharList) : base(input, rawCharList)
			{ }

			protected override void ProcessKeyword()
			{
				if (!IsDefined)
				{
					return;
				}

				switch (CurrentChar)
				{
					case "%":
					{
						if (Body != null)
						{
							ThrowFormatException($"Can only define a post-processor or end keyword at this position");
						}

						ValidateEmptyBuffer();
						var processor = new TokenPreprocessor(Input, RawCharList);
						processor.ProcessInput();
						Preprocessors.Add(processor);
						return;
					}

					case "@":
					{
						ValidateEmptyBuffer();
						var processor = new TokenPostProcessor(Input, RawCharList);
						processor.ProcessInput();
						PostProcessors.Add(processor);
						return;
					}

					case "|":
					{
						if (Body != null)
						{
							ThrowFormatException($"Can only define a post-processor or end keyword at this position");
						}

						ValidateEmptyBuffer();
						Body = new TokenBody(Input, RawCharList);
						Body.ProcessInput();
						return;
					}

					default:
						if (Regex.IsMatch(CurrentChar, @"[^`{}@%|()\\]"))
						{
							Buffer.Append(CurrentChar);
							return;
						}

						ThrowFormatException($"Can only define [{(Body == null ? "Preprocessor, Body," : "")}Post-processor] or end keyword at this position");
						return;
				}
			}

			protected override void ProcessEscapedChar(StringBuilder buffer, string character)
			{
				if (IsDefined)
				{
					base.ProcessEscapedChar(buffer, character);
				}
			}

			public override string ToString()
			{
				return $"{base.ToString()} {Preprocessors?.StringAggregate("")} {Body} {PostProcessors?.StringAggregate("")}";
			}
		}

		public class TokenPreprocessor : TokenKeyword
		{
			protected override char StartChar => '%';
			protected override char EndChar => '%';

			protected override void ProcessKeyword()
			{ }

			public TokenPreprocessor(Queue<char> input, List<string> rawCharList) : base(input, rawCharList)
			{ }
		}

		public class TokenPostProcessor : TokenKeyword
		{
			protected override char StartChar => '@';
			protected override char EndChar => '@';

			protected override void ProcessKeyword()
			{ }

			public TokenPostProcessor(Queue<char> input, List<string> rawCharList) : base(input, rawCharList)
			{ }
		}

		public class TokenString : Token
		{
			public TokenString(string value = "") : base(value)
			{ }

			protected override bool ProcessCharacter()
			{
				return true;
			}

			protected override void PostProcess()
			{ }
		}

		public class TokenText : TokenString
		{
			public TokenText(string value = "") : base(value)
			{ }
		}

		public class TokenOperator : TokenString
		{
			public TokenOperator(string value = "") : base(value)
			{ }
		}

		public class TokenOperand : TokenString
		{
			public override string Value
			{
				get => base.Value == "null" || base.Value == null ? string.Empty : base.Value;
				set => base.Value = value;
			}

			public TokenOperand(string value = "") : base(value)
			{ }
		}

		#endregion

		#region Factories

		private static class ConstructFactory
		{
			public static Construct GetConstruct(TokenConstruct keyword, GlobalState state,
				IReadOnlyList<Preprocessor> preProcessors, IReadOnlyList<PostProcessor> postProcessors)
			{
				keyword.Require(nameof(keyword));
				state.Require(nameof(state));

				var key = keyword.Value;

				var error = $"Unable to find a construct class with key '{key}' for '{keyword.ErrorLocationContext}'.";

				var type = state.ConstructTypes.FirstNotNullOrDefault(key);

				if (type == null)
				{
					throw new KeyNotFoundException(error);
				}

				var construct = Activator.CreateInstance(type, state, keyword, preProcessors, postProcessors) as Construct;

				if (construct == null)
				{
					throw new KeyNotFoundException(error);
				}

				return construct;
			}
		}

		private static class ProcessorFactory
		{
			public static StageProcessor GetProcessor<TProcessor>(TokenKeyword keyword, GlobalState state)
				where TProcessor : ProcessorAttribute
			{
				keyword.Require(nameof(keyword));
				state.Require(nameof(state));

				var key = keyword.Value;
				var className = key + typeof(TProcessor).FullName;

				var error = $"Unable to find a processor class '{className}' with key '{key}' for '{keyword.ErrorLocationContext}'.";

				var type = state.ProcessorTypes.FirstNotNullOrDefault(className);

				if (type == null)
				{
					throw new KeyNotFoundException(error);
				}

				var processor = Activator.CreateInstance(type, state, keyword) as StageProcessor;

				if (processor == null)
				{
					throw new KeyNotFoundException(error);
				}

				return processor;
			}
		}
		
		#endregion

		public class GlobalState
		{
			public readonly IOrganizationService Service;
			public readonly Guid? OrgId;

			public Entity Context;
			public object ContextObject;

			public readonly Type[] ConstructTypesLookup;

			public int Lcid = 1033;

			public readonly bool IsContextProvided = false;

			public IDictionary<string, Type> ConstructTypes
				=> CacheHelpers.GetFromMemCacheAdd("Yagasoft.CrmParser.GetTypes<ConstructAttribute>",
					() => Yagasoft.Libraries.Common.TypeHelpers.GetTypes<ConstructAttribute>(ConstructTypesLookup)
						.ToDictionary(t => t.GetCustomAttribute<ConstructAttribute>().Key, t => t),
					fallbackCacheDuration: fallbackCacheDuration);

			public IDictionary<string, Type> ProcessorTypes
				=> CacheHelpers.GetFromMemCacheAdd("Yagasoft.CrmParser.GetTypes<ProcessorAttribute>",
					() => Yagasoft.Libraries.Common.TypeHelpers.GetTypes<ProcessorAttribute>(ConstructTypesLookup)
						.ToDictionary(t =>
									  {
										  var attribute = t.GetCustomAttribute<ProcessorAttribute>();
										  return attribute.Key + attribute.GetType().FullName;
									  }, t => t),
					fallbackCacheDuration: fallbackCacheDuration);

			public InlineConfig InlineConfig;

			public readonly IDictionary<string, string> Templates = new Dictionary<string, string>();

			private readonly IDictionary<string, object> cache = new Dictionary<string, object>();

			private readonly IDictionary<string, object> memory = new Dictionary<string, object>();

			private readonly IDictionary<string, string> tokens = new Dictionary<string, string>();

			private int nextIndex = 1;

			public GlobalState(IOrganizationService service, Type[] constructTypes = null, object contextObject = null, Guid? orgId = null)
			{
				Service = service;
				ContextObject = contextObject;
				ConstructTypesLookup = (constructTypes ?? Type.EmptyTypes).Union(new [] {typeof(CrmParser)}).ToArray();
				OrgId = orgId;
			}

			public GlobalState(EntityReference contextRef, IOrganizationService service, Type[] constructTypes = null, object contextObject = null, Guid? orgId = null)
				: this(new Entity(contextRef.LogicalName, contextRef.Id), service, constructTypes, contextObject, orgId)
			{
				IsContextProvided = false;
			}

			public GlobalState(Entity context, IOrganizationService service, Type[] constructTypes = null, object contextObject = null, Guid? orgId = null)
				: this(service, constructTypes, contextObject, orgId)
			{
				Context = context;
				IsContextProvided = true;
			}

			public string GenerateToken(string str)
			{
				var index = nextIndex.ToString();
				nextIndex++;
				tokens[index] = str;
				return index;
			}

			public string GetToken(string token)
			{
				return tokens.TryGetValue(token, out var str) ? str : null;
			}

			public T AddCached<T>(string key, T obj, bool isGlobal = false)
			{
				if (isGlobal)
				{
					CacheHelpers.AddToMemCache(key, obj, Service, fallbackCacheDuration: fallbackCacheDuration, orgId: OrgId);
				}
				else
				{
					cache[key] = obj;
				}

				return obj;
			}

			public T GetCachedAdd<T>(string key, Func<T> objFunc, bool isGlobal = false)
			{
				var cached = GetCached<T>(key);

				if (cached != null)
				{
					return cached;
				}

				var obj = objFunc();

				if (isGlobal)
				{
					CacheHelpers.AddToMemCache(key, obj, Service, fallbackCacheDuration: fallbackCacheDuration, orgId: OrgId);
				}
				else
				{
					cache[key] = obj;
				}

				return obj;
			}

			public T GetCached<T>(string key)
			{
				return cache.TryGetValue(key, out var obj) && obj is T cast
					? cast
					: (CacheHelpers.GetFromMemCache<object>(key, orgId: OrgId) is T castGlobal ? castGlobal : default);
			}

			public string GetCached(string key)
			{
				return GetCached<string>(key);
			}

			public T Store<T>(string key, T obj)
			{
				memory[key] = obj;
				return obj;
			}

			public T Read<T>(string key)
			{
				return memory.TryGetValue(key, out var obj) && obj is T cast ? cast : default;
			}

			public string Read(string key)
			{
				return Read<string>(key);
			}
		}

		#region Definitions

		public enum ValueForm
		{
			Raw,
			Name,
			LogicalName,
			Id
		}

		public abstract class Processor
		{
			public readonly TokenKeyword Keyword;

			protected readonly GlobalState State;

			protected Processor(GlobalState state, TokenKeyword keyword)
			{
				State = state;
				Keyword = keyword;
			}

			protected void ThrowMisformattedParam(string paramName = null)
			{
				throw new FormatException($"Parameter {(paramName.IsFilled() ? $"'{paramName}' " : "")}for '{Keyword.Value}'"
					+ $" {GetType().BaseType?.Name} is misformatted for '{Keyword.ErrorLocationContext}'");
			}

			protected ProcessorParameters ExtractParameters(int minCount = 1, bool isRegexRequired = false)
			{
				var parameters = Keyword.ProcessedParams;
				var paramCount = parameters.Count;

				var regex = GetRegex(parameters.FirstOrDefault());

				if (regex == null)
				{
					if (isRegexRequired)
					{
						ThrowMisformattedParam();
					}
				}
				else
				{
					if (!isRegexRequired)
					{
						paramCount--;
					}
				}

				if (paramCount < minCount)
				{
					ThrowMisformattedParam();
				}

				return new ProcessorParameters { Params = parameters.Skip(regex == null ? 0 : 1).ToArray(), Regex = regex };
			}

			private static RegexParams GetRegex(string buffer)
			{
				if (buffer.IsEmpty())
				{
					return null;
				}

				var match = Regex.Match(buffer, @"^(?:[^\\]?/(.*?[^\\]?)/)+$");

				if (!match.Success)
				{
					return null;
				}

				var captures = match.Groups[1].ExtractCaptures().ToArray();
				var regex = captures.FirstOrDefault();
				var groups = captures.Skip(1).ToArray();

				return new RegexParams { Regex = regex, Groups = groups.Any() ? groups : null };
			}

			protected IReadOnlyList<string> ExtractMatches(string input, ProcessorParameters procParams,
				Func<Capture, string> captureOperation = null, string defaultValue = "")
			{
				captureOperation ??= (s => s.Value);

				var regex = procParams.Regex;

				if (regex == null)
				{
					return new [] { input };
				}

				var parameters = procParams.Params;
				var isLast = parameters.Any(s => s == "last");
				var isSingle = parameters.Any(s => s == "single");

				var matches = Regex.Matches(input, regex.Regex).Cast<Match>().ToArray();

				var isCapture = matches.Any(m => m.Groups.Count > 1);

				string[] captures;

				if (isLast)
				{
					captures = matches
						.LastOrDefault()?
						.Groups.Cast<Group>()
						.LastOrDefault()?
						.Captures.Cast<Capture>()
						.Select(captureOperation).ToArray();
				}
				else
				{
					var groups = matches
						.FirstOrDefault()?
						.Groups.Cast<Group>().ToArray();

					var captureGroup = groups?.Skip(1).FirstOrDefault();

					var group = isCapture && captureGroup != null
						? captureGroup
						: groups?.FirstOrDefault();

					captures = group?.Captures.Cast<Capture>().Select(captureOperation).ToArray();
				}

				return (captures?.Any() == true ? (isSingle ? captures.Take(1) : captures) : new[] { defaultValue }).ToArray();
			}

			protected static IReadOnlyList<string> Replace(IReadOnlyList<string> buffer, ProcessorParameters procParams)
			{
				var regex = procParams.Regex;
				var pattern = regex?.Regex ?? procParams.Params.First();

				if (pattern == null)
				{
					return buffer;
				}

				var replacementPattern = regex?.Regex == null ? procParams.Params.Skip(1).First() : procParams.Params.First();

				IDictionary<string, string> replacementMap = null;

				try
				{
					replacementMap = SerialiserHelpers.DeserialiseSimpleJson(replacementPattern);
				}
				catch (FormatException)
				{ }

				return buffer
					.Select(s => replacementMap?.Any() == true
						? s.ReplaceGroups(pattern, replacementMap)
						: (regex?.Groups == null
							? Regex.Replace(s, pattern, replacementPattern)
							: s.ReplaceGroups(pattern, regex.Groups.ToDictionary(p => p, _ => replacementPattern)))).ToArray();
			}
		}

		public class ProcessorParameters
		{
			public IReadOnlyList<string> Params { get; set; }
			public RegexParams Regex { get; set; }
		}

		public class RegexParams
		{
			protected internal string Regex { get; set; }
			protected internal string[] Groups { get; set; }
		}

		public abstract class Construct : Processor
		{
			public readonly IReadOnlyList<Preprocessor> Preprocessors;
			public IReadOnlyList<PostProcessor> PostProcessors;

			protected internal Entity Context => State.Context;

			protected internal readonly Stack<PostProcessor> ResetProcessors = new();
			protected internal readonly Queue<IModifier> Modifiers = new();

			protected internal bool IsCacheResult = true;
			protected internal bool IsCacheGlobal;

			protected internal int? BackupLcid;

			protected Construct(GlobalState state, TokenKeyword keyword,
				IReadOnlyList<Preprocessor> preProcessors, IReadOnlyList<PostProcessor> postProcessors)
			: base(state, keyword)
			{
				Preprocessors = preProcessors;
				PostProcessors = postProcessors;
			}

			public virtual IReadOnlyList<string> Execute(string block)
			{
				var durationBackup = fallbackCacheDuration;

				try
				{
					var cacheConfig = State.InlineConfig?.CacheConfig;

					if (cacheConfig != null)
					{
						IsCacheResult = cacheConfig.IsEnabled;
						IsCacheGlobal = cacheConfig.IsGlobal;
						fallbackCacheDuration = cacheConfig.Duration;
					}

					if (this is IPreExecutable preExecutable)
					{
						preExecutable.PreExecute(ref block);
					}

					return ExecutePostProcessors(ExecuteConstruct(ExecutePreprocessors(block))
						.FilterNull().ToArray()).FilterNull().ToArray();
				}
				catch (Exception ex)
				{
					throw new Exception($"CrmParser failed ({Keyword.ErrorLocationContext}): {ex.BuildShortExceptionMessage()}", ex);
				}
				finally
				{
					State.Lcid = BackupLcid ?? State.Lcid;
					fallbackCacheDuration = durationBackup;
				}
			}

			protected string ExecutePreprocessors(string buffer)
			{
				Modifiers.Clear();

				foreach (var preprocessor in Preprocessors)
				{
					if (preprocessor is IModifiable modifiable)
					{
						ApplyModifiers(modifiable);
					}

					if (preprocessor is IModifier modifier)
					{
						Modifiers.Enqueue(modifier);
					}

					buffer = preprocessor.Execute(buffer, this);
				}

				if (this is IModifiable modifiableConstruct)
				{
					ApplyModifiers(modifiableConstruct);
				}

				return buffer;
			}

			private void ApplyModifiers(IModifiable modifiable)
			{
				var modifierCount = Modifiers.Count;

				for (var i = 0; i < modifierCount; i++)
				{
					var modifierDequeue = Modifiers.Dequeue();

					if (!modifierDequeue.Apply(modifiable))
					{
						Modifiers.Enqueue(modifierDequeue);
					}
				}
			}

			protected abstract IReadOnlyList<string> ExecuteConstruct(string buffer);

			protected IReadOnlyList<string> ExecutePostProcessors(IReadOnlyList<string> buffer)
			{
				Modifiers.Clear();

				var result =
					PostProcessors.IsFilled()
						? PostProcessors
							.Aggregate(buffer,
								(current, processor) =>
								{
									if (processor is IModifiable modifiable)
									{
										ApplyModifiers(modifiable);
									}

									if (processor is IModifier modifier)
									{
										Modifiers.Enqueue(modifier);
									}

									return processor.Execute(current).ToArray();
								})
							.FilterNull().ToArray()
						: buffer;

				// clean up
				while (ResetProcessors.Count > 0)
				{
					result = ResetProcessors.Pop().Execute(result);
				}

				return result;
			}
		}

		public abstract class DefaultConstruct : Construct
		{
			protected DefaultConstruct(GlobalState state, TokenKeyword keyword,
				IReadOnlyList<Preprocessor> preProcessors, IReadOnlyList<PostProcessor> postProcessors)
				: base(state, keyword, preProcessors, postProcessors)
			{ }

			protected override IReadOnlyList<string> ExecuteConstruct(string buffer)
			{
				return ExecuteLogic(buffer);
			}

			protected abstract IReadOnlyList<string> ExecuteLogic(string buffer);
		}

		public abstract class DefaultContextConstruct : DefaultConstruct
		{
			protected DefaultContextConstruct(GlobalState state, TokenKeyword keyword,
				IReadOnlyList<Preprocessor> preProcessors, IReadOnlyList<PostProcessor> postProcessors)
				: base(state, keyword, preProcessors, postProcessors)
			{ }

			protected override IReadOnlyList<string> ExecuteLogic(string buffer)
			{
				Context.Require(nameof(Context),
					$"An entity context was not provided for the '{GetType().Name}' construct for '{Keyword.ErrorLocationContext}'.");
				return new[] { ExecuteContextLogic(Context, buffer) };
			}

			protected abstract string ExecuteContextLogic(Entity context, string buffer);
		}

		public abstract class DefaultNoContextConstruct : DefaultConstruct
		{
			protected DefaultNoContextConstruct(GlobalState state, TokenKeyword keyword,
				IReadOnlyList<Preprocessor> preProcessors, IReadOnlyList<PostProcessor> postProcessors)
				: base(state, keyword, preProcessors, postProcessors)
			{ }

			protected override IReadOnlyList<string> ExecuteLogic(string buffer)
			{
				return new[] { ExecuteNoContextLogic(buffer) };
			}

			protected abstract string ExecuteNoContextLogic(string buffer);
		}

		public abstract class StageProcessor : Processor
		{
			protected StageProcessor(GlobalState state, TokenKeyword token) : base(state, token)
			{ }
		}

		public abstract class Preprocessor : StageProcessor
		{
			protected Preprocessor(GlobalState state, TokenKeyword token)
				: base(state, token)
			{ }

			public abstract string Execute(string block, Construct construct);
		}

		public abstract class PostProcessor : StageProcessor
		{
			protected PostProcessor(GlobalState state, TokenKeyword token)
				: base(state, token)
			{ }

			public abstract IReadOnlyList<string> Execute(IReadOnlyList<string> buffer);

			protected IReadOnlyList<string> ApplyToCaptures(IReadOnlyList<string> buffer, Func<string, string> action, RegexParams regex)
			{
				return buffer
					.Select(s => regex?.Regex == null ? action(s) : s.ReplaceGroups(regex.Regex, action)).ToArray();
			}
		}

		public class RuntimeGenerated : Attribute
		{ }

		public interface IScoped
		{ }

		public interface IPreExecutable
		{
			void PreExecute(ref string block);
		}

		public interface IModifier
		{
			bool Apply(IModifiable target);
		}

		public interface IModifiable
		{ }

		public interface IQuery : IModifiable
		{
			IReadOnlyList<string> Distinct { get; set; }
			IReadOnlyList<string> Order { get; set; }
		}

		public class RowValue
		{
			public virtual string StringValue
			{
				get
				{
					var key = $"CrmParser.RowValue.StringValue|{Context.LogicalName}|{Context.Id}";
					return StringValueInner.IsFilled()
						? StringValueInner
						: (State.Service == null
							? $"{Context.LogicalName}:{Context.Id.ToString().ToUpper()}"
							: State.GetCachedAdd(key,
								() => CrmHelpers.GetRecordName(State.Service, Context, true, null, State.OrgId),
								IsCacheGlobal));
				}
				set => StringValueInner = value;
			}

			public readonly Entity Context;

			public readonly GlobalState State;

			protected readonly bool IsCacheGlobal;
			protected string StringValueInner;

			public RowValue(Entity context, GlobalState state, bool isCacheGlobal)
			{
				Context = context;
				State = state;
				IsCacheGlobal = isCacheGlobal;
			}

			public override string ToString()
			{
				return StringValue;
			}
		}

		public class FieldValue : RowValue
		{
			public override string StringValue
			{
				get => StringValueInner.IsFilled() ? StringValueInner : CrmHelpers.GetAttributeName(FieldName, Context);
				set => StringValueInner = value;
			}

			public readonly string FieldName;
			public object Value => Context.GetAttributeValue<object>(FieldName);

			public FieldValue(Entity context, string fieldName, GlobalState state, bool isCacheGlobal)
				: base(context, state, isCacheGlobal)
			{
				FieldName = fieldName;
			}
		}

		#region Attributes

		[AttributeUsage(AttributeTargets.Class)]
		public class ProcessorAttribute : Attribute
		{
			public readonly string Key;
			public readonly string LongForm;

			public ProcessorAttribute(string key, string longForm = null)
			{
				Key = key;
				LongForm = longForm;
			}
		}

		[AttributeUsage(AttributeTargets.Class)]
		public class ConstructAttribute : ProcessorAttribute
		{
			public ConstructAttribute(string key, string longForm = null) : base(key, longForm)
			{ }
		}

		[AttributeUsage(AttributeTargets.Class)]
		public class PreprocessorAttribute : ProcessorAttribute
		{
			public PreprocessorAttribute(string key, string longForm = null) : base(key, longForm)
			{ }
		}

		[AttributeUsage(AttributeTargets.Class)]
		public class PostProcessorAttribute : ProcessorAttribute
		{
			public PostProcessorAttribute(string key, string longForm = null) : base(key, longForm)
			{ }
		}

		#endregion

		#endregion

		#region Constructs

		[Construct("t", "template")]
		public class TemplateConstruct : Construct
		{
			public TemplateConstruct(GlobalState state, TokenKeyword keyword, IReadOnlyList<Preprocessor> preProcessors,
				IReadOnlyList<PostProcessor> postProcessors)
				: base(state, keyword, preProcessors, postProcessors)
			{ }

			protected override IReadOnlyList<string> ExecuteConstruct(string buffer)
			{
				var parameters = ExtractParameters();
				State.Templates[parameters.Params.First()] = buffer;
				return Array.Empty<string>();
			}
		}

		[Construct("p", "placeholder")]
		public class PlaceholderConstruct : Construct, IPreExecutable
		{
			public PlaceholderConstruct(GlobalState state, TokenKeyword keyword, IReadOnlyList<Preprocessor> preProcessors, IReadOnlyList<PostProcessor> postProcessors)
				: base(state, keyword, preProcessors, postProcessors)
			{ }

			public void PreExecute(ref string block)
			{
				var replacements = ExtractParameters(0).Params;

				if ((replacements.Count % 2) != 0)
				{
					ThrowMisformattedParam();
				}

				var isFound = State.Templates.TryGetValue(block, out var template);

				if (!isFound)
				{
					throw new KeyNotFoundException($"Template '{block}' for 'placeholder (p)' construct is undefined for '{Keyword.ErrorLocationContext}'");
				}

				for (var i = 0; i < replacements.Count; i += 2)
				{
					block = template.Replace(replacements[i], replacements[i + 1]);
				}
			}

			protected override IReadOnlyList<string> ExecuteConstruct(string buffer)
			{
				var body = new TokenGlobal(buffer);
				body.ProcessInput();
				buffer = ProcessToken(body, State).StringAggregate("");

				return new[] { buffer };
			}
		}

		[Construct(".", "reference")]
		public class ReferenceConstruct : Construct, IQuery, IScoped
		{
			public IReadOnlyList<string> Distinct { get; set; }
			public IReadOnlyList<string> Order { get; set; }

			public ReferenceConstruct(GlobalState state, TokenKeyword keyword, IReadOnlyList<Preprocessor> preProcessors, IReadOnlyList<PostProcessor> postProcessors)
				: base(state, keyword, preProcessors, postProcessors)
			{ }

			protected override IReadOnlyList<string> ExecuteConstruct(string buffer)
			{
				Context.Require(nameof(Context),
					$"An entity context was not provided for the 'context switch (.)' construct for '{Keyword.ErrorLocationContext}'.");

				var parameters = ExtractParameters().Params;

				var backupContext = Context;
				backupContext.Require(nameof(backupContext), "An entity context was not provided for the 'context switch (.)' construct.");

				var match = Regex.Match(parameters.First(),
					@"^([a-zA-Z0-9_]+)(?:((?:\.?|#)[a-zA-Z0-9_]+))*$");

				if (!match.Success)
				{
					return new[] { buffer };
				}

				var output = new List<string>();
				var scopeName = match.Groups[1].Value;

				var isGlobal = parameters.Contains("global");

				// context given name
				var contextName = (parameters.Count == 2 && !isGlobal) || (parameters.Count > 2) ? parameters[1] : null;

				// loop element name
				var localVarName = (parameters.Count == 3 && !isGlobal) || (parameters.Count > 3) ? parameters[2] : null;

				var storedScope = State.Read<object>(scopeName);
				var scope = new List<object>();

				if (storedScope is Func<object> storedFunc)
				{
					storedScope = storedFunc();
				}

				if (storedScope is IEnumerable<object> storedCollection)
				{
					scope.AddRange(storedCollection);
				}
				else
				{
					scope.Add(storedScope);
				}

				var isContextStored = scope.FirstOrDefault() is Entity;

				var localContexts = isContextStored ? scope.Cast<Entity>() : new[] { Context };

				foreach (var context in localContexts)
				{
					var traversalContexts = BuildTraversalContext(context, match.Groups[2].ExtractCaptures().ToArray(),
						State, Distinct, Order, IsCacheResult, IsCacheGlobal);

					foreach (var traversalContext in traversalContexts)
					{
						if (contextName.IsFilled())
						{
							State.Store(contextName, traversalContext);
						}

						State.Context = traversalContext;

						if (localVarName.IsFilled())
						{
							if (isContextStored)
							{
								State.Store(localVarName, traversalContext);
								output.Add(ProcessBody() ?? buffer);
							}
							else
							{
								foreach (var element in scope)
								{
									State.Store(localVarName, element);
									output.Add(ProcessBody() ?? buffer);
								}
							}
						}
						else
						{
							output.Add(ProcessBody() ?? buffer);
						}

						if (!isGlobal)
						{
							State.Context = backupContext;
						}
					}
				}

				return output;
			}

			private string ProcessBody()
			{
				return Keyword is TokenConstruct{Body: not null } construct ? ProcessToken(construct.Body, State).StringAggregate("") : null;
			}
		}

		[Construct("c", "column")]
		public class ColumnConstruct : DefaultContextConstruct, IModifiable
		{
			public ColumnConstruct(GlobalState state, TokenKeyword keyword, IReadOnlyList<Preprocessor> preProcessors, IReadOnlyList<PostProcessor> postProcessors)
				: base(state, keyword, preProcessors, postProcessors)
			{ }

			protected override string ExecuteContextLogic(Entity context, string buffer)
			{
				var match = Regex.Match(buffer, @"^([a-zA-Z0-9_]+?)(?:\.([a-zA-Z0-9_]+?))*$");

				if (!match.Success)
				{
					return null;
				}

				var initialFieldName = match.Groups[1].Value;
				var traversal = new[] { initialFieldName }.Union(match.Groups[2].ExtractCaptures()).ToArray();

				FieldValue returnValue = null;

				foreach (var fieldName in traversal)
				{
					var fieldValue = context.GetAttributeValue<object>(fieldName);

					// get the entity record
					context = fieldValue == null && context.LogicalName.IsFilled() && context.Id != Guid.Empty
						&& !State.IsContextProvided
						? context.IntegrateAttributes(Retrieve(State, context.LogicalName, context.Id,
							IsCacheResult, IsCacheGlobal, fieldName))
						: context;

					fieldValue = context.GetAttributeValue<object>(fieldName);

					returnValue = new FieldValue(context, fieldName, State, IsCacheGlobal);

					// if the field value is not a lookup, then we can't recurse
					if (fieldValue is not EntityReference reference)
					{
						break;
					}

					context =
						new Entity(reference.LogicalName)
						{
							Id = reference.Id
						};
				}

				var key = $"CrmParser.ColumnConstruct.ExecuteContextLogic|{context.LogicalName}|{context.Id}|{traversal.StringAggregate()}";

				if (returnValue == null)
				{
					return null;
				}

				var parameters = ExtractParameters(0).Params;

				if (parameters.IsEmpty())
				{
					return returnValue.StringValue;
				}

				switch (parameters.First())
				{
					case "raw":
						return returnValue.ToString();
					case "name":
						return
							returnValue.Value is OptionSetValue optionSet && State.Lcid != 1033
								? MetadataHelpers.GetOptionSetLabel(State.Service, returnValue.Context.LogicalName, returnValue.FieldName,
									optionSet.Value, State.Lcid, State.OrgId)
								: CrmHelpers.GetAttributeName(returnValue.FieldName, returnValue.Context);
					case "log":
						return returnValue.Value is EntityReference er1 ? er1.LogicalName : "";
					case "id":
						return
							(returnValue.Value is EntityReference er2
								? er2.Id
								: returnValue.Value is Guid id
									? id
									: (Guid?)null)?
								.ToString().ToUpper();
					case "url":
						return
							returnValue.Value is EntityReference er3
								? State.GetCachedAdd(key, () => CrmHelpers.GetRecordUrl(State.Service, er3, State.OrgId), IsCacheGlobal)
								: "";
					default:
						return returnValue.StringValue;
				}
			}
		}
		
		[Construct("i", "rowinfo")]
		public class RowInfoConstruct : DefaultContextConstruct
		{
			public RowInfoConstruct(GlobalState state, TokenKeyword keyword, IReadOnlyList<Preprocessor> preProcessors, IReadOnlyList<PostProcessor> postProcessors)
				: base(state, keyword, preProcessors, postProcessors)
			{ }

			protected override string ExecuteContextLogic(Entity context, string buffer)
			{
				buffer.RequireFilled("block", $"Block for 'row info' construct is missing for '{Keyword.ErrorLocationContext}'.");
				var key = $"CrmParser.RowInfoConstruct.ExecuteContextLogic|{buffer}|{context.LogicalName}|{context.Id}";

				return
					buffer switch {
						"raw" => $"{context.LogicalName}:{context.Id.ToString().ToUpper()}",
						"name" =>
							State.GetCachedAdd($"{key}|name", () => CrmHelpers.GetRecordName(State.Service, context, true, null, State.OrgId),
								IsCacheGlobal),
						"log" => context.LogicalName,
						"id" => context.Id.ToString().ToUpper(),
						"url" =>
							State.GetCachedAdd($"{key}|url", () => CrmHelpers.GetRecordUrl(State.Service, context.ToEntityReference(), State.OrgId),
								IsCacheGlobal),
						_ =>
							throw
								new NotSupportedException($"Value for 'row info' construct" + $" is not supported ('{buffer}') for '{Keyword.ErrorLocationContext}'.")
						};
			}
		}

		[Construct("u", "userinfo")]
		public class UserInfoConstruct : DefaultNoContextConstruct
		{
			public UserInfoConstruct(GlobalState state, TokenKeyword keyword, IReadOnlyList<Preprocessor> preProcessors, IReadOnlyList<PostProcessor> postProcessors)
				: base(state, keyword, preProcessors, postProcessors)
			{ }

			protected override string ExecuteNoContextLogic(string buffer)
			{
				var isId = Guid.TryParse(ExtractParameters(0).Params.FirstOrDefault(), out var userIdParam);

				buffer.RequireFilled("block", $"Block for {Keyword.Value} construct is missing for '{Keyword.ErrorLocationContext}'.");
				var key = $"CrmParser.UserInfoConstruct.ExecuteContextLogic|{buffer}";

				var userId = isId ? userIdParam : ((WhoAmIResponse)State.Service.Execute(new WhoAmIRequest())).UserId;
				const string logicalName = "systemuser";
				var user = new Entity("systemuser", userId);

				return
					buffer switch {
						"raw" => $"{logicalName}:{userId.ToString().ToUpper()}",
						"name" =>
							State.GetCachedAdd($"{key}|name", () => CrmHelpers.GetRecordName(State.Service, user, true, null, State.OrgId),
								IsCacheGlobal),
						"log" => logicalName,
						"id" => userId.ToString().ToUpper(),
						"lcid" =>
							State.GetCachedAdd($"{key}|lcid", () => (int?)CrmHelpers.GetPreferredLangCode(State.Service, user.ToEntityReference()),
								IsCacheGlobal).ToString(),
						"url" =>
							State.GetCachedAdd($"{key}|url", () => CrmHelpers.GetRecordUrl(State.Service, user.ToEntityReference(), State.OrgId),
								IsCacheGlobal),
						_ =>
							throw
								new NotSupportedException($"Value for 'row info' construct" + $" is not supported ('{buffer}') for '{Keyword.ErrorLocationContext}'.")
						};
			}
		}

		[Construct("<", "preload")]
		public class PreloadConstruct : DefaultContextConstruct
		{
			public PreloadConstruct(GlobalState state, TokenKeyword keyword, IReadOnlyList<Preprocessor> preProcessors, IReadOnlyList<PostProcessor> postProcessors)
				: base(state, keyword, preProcessors, postProcessors)
			{ }

			protected override string ExecuteContextLogic(Entity context, string buffer)
			{
				buffer.RequireFilled("block", $"Block for '{Keyword.Value}' construct is missing for '{Keyword.ErrorLocationContext}'.");

				var list = buffer.Split(new[] { "," }, StringSplitOptions.RemoveEmptyEntries);

				if (context.Attributes.Keys.Intersect(list).Count() == list.Length)
				{
					return null;
				}
				
				context.IntegrateAttributes(Retrieve(State, context.LogicalName, context.Id,
					IsCacheResult, IsCacheGlobal, list));

				return null;
			}
		}

		[Construct("_", "discard")]
		public class DiscardConstruct : DefaultNoContextConstruct
		{
			public DiscardConstruct(GlobalState state, TokenKeyword keyword, IReadOnlyList<Preprocessor> preProcessors, IReadOnlyList<PostProcessor> postProcessors)
				: base(state, keyword, preProcessors, postProcessors)
			{ }

			public override IReadOnlyList<string> Execute(string block)
			{
				base.Execute(block);
				return Array.Empty<string>();
			}

			protected override string ExecuteNoContextLogic(string buffer)
			{
				return buffer;
			}
		}

		[Construct("e", "expression")]
		public class ExpressionConstruct : DefaultNoContextConstruct
		{
			public ExpressionConstruct(GlobalState state, TokenKeyword keyword, IReadOnlyList<Preprocessor> preProcessors, IReadOnlyList<PostProcessor> postProcessors)
				: base(state, keyword, preProcessors, postProcessors)
			{ }

			protected override string ExecuteNoContextLogic(string buffer)
			{
				return buffer;
			}
		}

		[Construct("s", "inlineconfig")]
		public class ConfigConstruct : Construct
		{
			public ConfigConstruct(GlobalState state, TokenKeyword keyword, IReadOnlyList<Preprocessor> preProcessors, IReadOnlyList<PostProcessor> postProcessors)
				: base(state, keyword, preProcessors, postProcessors)
			{ }

			protected override IReadOnlyList<string> ExecuteConstruct(string buffer)
			{
				var parameters = ExtractParameters().Params;
				var input = SerialiserHelpers.DeserialiseSimpleJson(parameters.FirstOrDefault());
				var isGlobal = parameters.Contains("global");

				var config = new InlineConfig();

				foreach (var option in input)
				{
					var value = option.Value;

					switch (option.Key)
					{
						case "html":
							if (bool.TryParse(value, out var isParseHtml))
							{
								config.IsParseHtml = isParseHtml;
							}

							break;

						case "cache":
							var cacheConfigRaw = SerialiserHelpers.DeserialiseSimpleJson(value);
							var cacheConfig = config.CacheConfig = new CacheConfig();

							foreach (var cacheOption in cacheConfigRaw)
							{
								var cacheOptionValue = cacheOption.Value;

								switch (cacheOption.Key)
								{
									case "enabled":
										if (bool.TryParse(cacheOptionValue, out var isCacheEnabled))
										{
											cacheConfig.IsEnabled = isCacheEnabled;
										}

										break;

									case "global":
										if (bool.TryParse(cacheOptionValue, out var isCacheGlobal))
										{
											cacheConfig.IsGlobal = isCacheGlobal;
										}

										break;

									case "dur":
										if (int.TryParse(cacheOptionValue, out var duration))
										{
											cacheConfig.Duration = TimeSpan.FromSeconds(duration);
										}

										break;
								}
							}

							break;
					}
				}

				State.InlineConfig = config;

				var output = new[] { ProcessBody() };

				if (!isGlobal)
				{
					State.InlineConfig = null;
				}

				return output;
			}

			private string ProcessBody()
			{
				return Keyword is TokenConstruct construct ? ProcessToken(construct.Body, State).StringAggregate("") : string.Empty;
			}
		}

		public class InlineConfig
		{
			public bool IsParseHtml { get; set; }
			public CacheConfig CacheConfig { get; set; }
		}

		public class CacheConfig
		{
			public bool IsEnabled { get; set; } = true;
			public bool IsGlobal { get; set; }
			public TimeSpan Duration { get; set; } = fallbackCacheDuration;
		}
		
		[Construct("r", "replace")]
		public class ReplaceConstruct : DefaultNoContextConstruct
		{
			public ReplaceConstruct(GlobalState state, TokenKeyword keyword, IReadOnlyList<Preprocessor> preProcessors, IReadOnlyList<PostProcessor> postProcessors)
				: base(state, keyword, preProcessors, postProcessors)
			{ }

			protected override string ExecuteNoContextLogic(string buffer)
			{
				var procParams = ExtractParameters(1, true);
				return Replace(new [] { buffer }, procParams).FirstOrDefault();
			}
		}

		[Construct("v", "dictionary")]
		public class DictionaryConstruct : DefaultNoContextConstruct
		{
			public DictionaryConstruct(GlobalState state, TokenKeyword keyword, IReadOnlyList<Preprocessor> preProcessors, IReadOnlyList<PostProcessor> postProcessors)
				: base(state, keyword, preProcessors, postProcessors)
			{ }

			protected override string ExecuteNoContextLogic(string buffer)
			{
				var fetch =
					$@"<fetch no-lock='true'>
  <entity name='ys_keyvalue' >
    <attribute name='ys_value' />
    <attribute name='ys_value{(State.Lcid == 1033 ? "" : $"_{State.Lcid}")}' />
    <filter>
      <condition attribute='ys_name' operator='eq' value='{buffer}' />
    </filter>
  </entity>
</fetch>";

				return RetrieveMultiple(State.Service, State, fetch, IsCacheResult, IsCacheGlobal)
					.FirstOrDefault()?.GetAttributeValue<string>("ys_value");
			}
		}

		[Construct("g", "commonconfig")]
		public class CommonConfigConstruct : DefaultNoContextConstruct
		{
			public CommonConfigConstruct(GlobalState state, TokenKeyword keyword, IReadOnlyList<Preprocessor> preProcessors, IReadOnlyList<PostProcessor> postProcessors)
				: base(state, keyword, preProcessors, postProcessors)
			{ }

			protected override string ExecuteNoContextLogic(string buffer)
			{
				buffer.RequireFilled("block", $"Block for '{Keyword.Value}' construct is missing for '{Keyword.ErrorLocationContext}'.");

				var config = CrmHelpers.GetGenericConfig(State.Service, State.OrgId);
				var value = CrmHelpers.GetGenericConfig(State.Service, State.OrgId).GetAttributeValue<object>(buffer);

				return
					value is OptionSetValue optionSet && State.Lcid != 1033
						? MetadataHelpers.GetOptionSetLabel(State.Service, config.LogicalName, buffer,
							optionSet.Value, State.Lcid, State.OrgId)
						: CrmHelpers.GetAttributeName(buffer, config);
			}
		}
		
		[Construct("f", "fetch")]
		public class FetchConstruct : DefaultNoContextConstruct
		{
			public FetchConstruct(GlobalState state, TokenKeyword keyword, IReadOnlyList<Preprocessor> preProcessors, IReadOnlyList<PostProcessor> postProcessors)
				: base(state, keyword, preProcessors, postProcessors)
			{ }

			protected override string ExecuteNoContextLogic(string buffer)
			{
				var name = ExtractParameters().Params.First();

				if (name.IsEmpty())
				{
					ThrowMisformattedParam(nameof(name));
				}

				var body = new TokenGlobal(buffer);
				body.ProcessInput();

				State.Store(name, new Func<Entity[]>(
					() => RetrieveMultiple(State.Service, State, ProcessToken(body, State).StringAggregate(""), IsCacheResult, IsCacheGlobal)));

				return null;
			}
		}
		
		[Construct("a", "action")]
		public class ActionConstruct : DefaultContextConstruct
		{
			public ActionConstruct(GlobalState state, TokenKeyword keyword, IReadOnlyList<Preprocessor> preProcessors, IReadOnlyList<PostProcessor> postProcessors)
				: base(state, keyword, preProcessors, postProcessors)
			{ }

			protected override string ExecuteContextLogic(Entity context, string buffer)
			{
				var parameters = ExtractParameters().Params;
				var storeName = parameters.First();
				var input = parameters.Count > 1 ? parameters.Skip(1).FirstOrDefault(p => p != "global") : null;
				var isGlobal = parameters.Contains("global");

				State.Store(storeName, new Func<Entity>(() =>
					CallAction(State.Service, buffer, isGlobal ? null : context.ToEntityReference(), input)));

				return null;
			}
		}
		
		[Construct("*", "rand")]
		public class RandConstruct : DefaultNoContextConstruct
		{
			public RandConstruct(GlobalState state, TokenKeyword keyword, IReadOnlyList<Preprocessor> preProcessors, IReadOnlyList<PostProcessor> postProcessors)
				: base(state, keyword, preProcessors, postProcessors)
			{ }

			protected override string ExecuteNoContextLogic(string buffer)
			{
				var processorParameters = ExtractParameters(2);
				var parameters = processorParameters.Params;

				if (!int.TryParse(parameters[0], out var length))
				{
					throw new ArgumentNullException("Length", "Random generator string length param is missing.");
				}

				if (parameters.Count < 2)
				{
					throw new ArgumentNullException("Pool", "Random generator character pool param is missing.");
				}

				var pool = parameters[1];
				
				const string flagIndexer = "culn";
				var flags = pool.Select(flag => (RandomGenerator.SymbolFlag)flagIndexer.IndexOf(flag))
					.ToArray();

				if (flags.IsEmpty())
				{
					throw new ArgumentNullException("Pool", "Random generator character pool param is missing.");
				}

				var isLetterStart = false;

				if (parameters.Count >= 3 && !bool.TryParse(parameters[2], out isLetterStart))
				{
					throw new ArgumentNullException("Letter Start", "Random generator 'letter start' param flag value is invalid.");
				}

				var numberLetterRatio = 50;

				if (parameters.Count >= 4 && !int.TryParse(parameters[3], out numberLetterRatio))
				{
					throw new ArgumentNullException("Number to Letter Ratio", "Random generator 'number-letter ratio' param value is invalid (percentage; e.g. '43').");
				}


				return flags.Contains(RandomGenerator.SymbolFlag.Custom)
					? RandomGenerator.GetRandomString(length, isLetterStart, numberLetterRatio, buffer.Split(','))
					: RandomGenerator.GetRandomString(length, isLetterStart, numberLetterRatio, flags.ToArray());
			}
		}
		
		[Construct("d", "date")]
		public class DateConstruct : DefaultNoContextConstruct
		{
			public DateConstruct(GlobalState state, TokenKeyword keyword, IReadOnlyList<Preprocessor> preProcessors, IReadOnlyList<PostProcessor> postProcessors)
				: base(state, keyword, preProcessors, postProcessors)
			{ }

			protected override string ExecuteNoContextLogic(string buffer)
			{
				return DateTime.UtcNow.ToString("s");
			}
		}
		
		#endregion

		#region Preprocessors

		[Preprocessor("filter")]
		public class FilterPreprocessor : Preprocessor, IModifier
		{
			public FilterPreprocessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override string Execute(string block, Construct construct)
			{
				return block;
			}

			public bool Apply(IModifiable target)
			{
				throw new NotImplementedException();
			}
		}

		[Preprocessor("distinct")]
		public class DistinctPreprocessor : Preprocessor, IModifier
		{
			public DistinctPreprocessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override string Execute(string block, Construct construct)
			{
				return block;
			}

			public bool Apply(IModifiable target)
			{
				var parameters = ExtractParameters(0).Params;

				if (target is IQuery query && parameters.IsFilled())
				{
					query.Distinct = parameters;
					return true;
				}

				return false;
			}
		}

		[Preprocessor("order")]
		public class OrderPreprocessor : Preprocessor, IModifier
		{
			public OrderPreprocessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override string Execute(string block, Construct construct)
			{
				return block;
			}

			public bool Apply(IModifiable target)
			{
				var parameters = ExtractParameters(0).Params;

				if (target is IQuery query && parameters.IsFilled())
				{
					query.Order = parameters;
					return true;
				}

				return false;
			}
		}

		[Preprocessor("cache")]
		public class CachePreprocessor : Preprocessor
		{
			public CachePreprocessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override string Execute(string block, Construct construct)
			{
				var parameters = ExtractParameters(0).Params;

				if (bool.TryParse(parameters.FirstOrDefault(), out var isCache))
				{
					construct.IsCacheResult = isCache;
				}

				if (parameters.Contains("global"))
				{
					construct.IsCacheGlobal = true;
				}

				return block;
			}
		}

		[Preprocessor("store")]
		public class StorePreprocessor : Preprocessor
		{
			public StorePreprocessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override string Execute(string block, Construct construct)
			{
				return State.Store(ExtractParameters().Params.First(), block);
			}
		}

		[Preprocessor("read")]
		public class ReadPreprocessor : Preprocessor
		{
			public ReadPreprocessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override string Execute(string block, Construct construct)
			{
				return
					State.Read<object>(ExtractParameters().Params.First()) switch {
						string str => str,
						IEnumerable<object> e => e.StringAggregate(""),
						_ => ""
						};
			}
		}

		[Preprocessor("local")]
		public class LocalisePreprocessor : Preprocessor, IModifier
		{
			public LocalisePreprocessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override string Execute(string block, Construct construct)
			{
				return block;
			}

			public bool Apply(IModifiable target)
			{
				var parameters = ExtractParameters(0).Params;

				if (target is Construct construct && parameters.IsFilled())
				{
					var isLcid = int.TryParse(parameters.First(), out var lcid);
					var isGlobal = parameters.Contains("global");

					if (isLcid)
					{
						if (!isGlobal)
						{
							construct.BackupLcid = State.Lcid;
						}

						State.Lcid = lcid;
					}

					return true;
				}

				return false;
			}
		}
		
		[Preprocessor("replace")]
		public class StringReplacePreprocessor : Preprocessor
		{
			public StringReplacePreprocessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override string Execute(string block, Construct construct)
			{
				var procParams = ExtractParameters(1, true);
				return Replace(new[] { block }, procParams).StringAggregate("");
			}
		}

		#endregion

		#region Post processors

		[PostProcessor("store")]
		public class StorePostProcessor : PostProcessor
		{
			public StorePostProcessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override IReadOnlyList<string> Execute(IReadOnlyList<string> buffer)
			{
				return State.Store(ExtractParameters().Params.First(), buffer.FilterNull()).ToArray();
			}
		}

		[PostProcessor("read")]
		public class ReadPostProcessor : PostProcessor
		{
			public ReadPostProcessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override IReadOnlyList<string> Execute(IReadOnlyList<string> buffer)
			{
				return
					State.Read<object>(ExtractParameters().Params.First()) switch {
						string str => new[] { str },
						IEnumerable<string> e => e.ToArray(),
						_ => Array.Empty<string>()
						};
			}
		}

		[PostProcessor("discard")]
		public class DiscardPostProcessor : PostProcessor
		{
			public DiscardPostProcessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override IReadOnlyList<string> Execute(IReadOnlyList<string> buffer)
			{
				return buffer.Select(_ => (string)null).ToArray();
			}
		}

		[PostProcessor("sub")]
		public class StringSubPostProcessor : PostProcessor
		{
			public StringSubPostProcessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override IReadOnlyList<string> Execute(IReadOnlyList<string> buffer)
			{
				var processorParameters = ExtractParameters();
				var parameters = processorParameters.Params;

				var isStart = int.TryParse(parameters.First(), out var start);

				if (!isStart)
				{
					ThrowMisformattedParam(nameof(start));
				}

				var isLength = int.TryParse(parameters.Skip(1).First(), out var length);

				return ApplyToCaptures(buffer, s => isLength ? s.Substring(start, length) : s.Substring(start), processorParameters.Regex);
			}
		}

		[PostProcessor("trim")]
		public class StringTrimPostProcessor : PostProcessor
		{
			public StringTrimPostProcessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override IReadOnlyList<string> Execute(IReadOnlyList<string> buffer)
			{
				var processorParameters = ExtractParameters();
				var parameters = processorParameters.Params;

				var characters = parameters.First().ToCharArray();
				var isStart = parameters.Skip(1).Contains("start");
				var isEnd = parameters.Skip(1).Contains("end");

				return ApplyToCaptures(buffer,
					s =>
					{
						if (isStart)
						{
							s = s.TrimStart(characters);
						}

						if (isEnd)
						{
							s = s.TrimEnd(characters);
						}

						if (!isStart && !isEnd)
						{
							s = s.Trim(characters);
						}

						return s;
					},
					processorParameters.Regex);
			}
		}

		[PostProcessor("pad")]
		public class StringPadPostProcessor : PostProcessor
		{
			public StringPadPostProcessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override IReadOnlyList<string> Execute(IReadOnlyList<string> buffer)
			{
				var processorParameters = ExtractParameters(2);
				var parameters = processorParameters.Params;

				var character = parameters.First().ToCharArray().FirstOrDefault();

				if (character == default(char))
				{
					ThrowMisformattedParam(nameof(character));
				}

				var isLength = int.TryParse(parameters.Skip(1).First(), out var length);

				if (!isLength)
				{
					ThrowMisformattedParam(nameof(length));
				}

				var isRight = parameters.Skip(2).Contains("right");

				return ApplyToCaptures(
					buffer,
					s => isRight
						? s.PadRight(length, character)
						: s.PadLeft(length, character),
					processorParameters.Regex);
			}
		}

		[PostProcessor("length")]
		public class StringLengthPostProcessor : PostProcessor
		{
			public StringLengthPostProcessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override IReadOnlyList<string> Execute(IReadOnlyList<string> buffer)
			{
				var processorParameters = ExtractParameters(0);
				var output = new List<string>();

				ApplyToCaptures(
					buffer,
					s =>
					{
						output.Add(s.Length.ToString());
						return null;
					},
					processorParameters.Regex).ToArray();

				return output;
			}
		}

		[PostProcessor("upper")]
		public class StringUpperPostProcessor : PostProcessor
		{
			public StringUpperPostProcessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override IReadOnlyList<string> Execute(IReadOnlyList<string> buffer)
			{
				return ApplyToCaptures(
					buffer,
					s => s.ToUpper(),
					ExtractParameters(0).Regex);
			}
		}

		[PostProcessor("lower")]
		public class StringLowerPostProcessor : PostProcessor
		{
			public StringLowerPostProcessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override IReadOnlyList<string> Execute(IReadOnlyList<string> buffer)
			{
				return ApplyToCaptures(
					buffer,
					s => s.ToLower(),
					ExtractParameters(0).Regex);
			}
		}

		[PostProcessor("sentence")]
		public class StringSentencePostProcessor : PostProcessor
		{
			public StringSentencePostProcessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override IReadOnlyList<string> Execute(IReadOnlyList<string> buffer)
			{
				return ApplyToCaptures(
					buffer,
					s => s.ToSentenceCase(),
					ExtractParameters(0).Regex);
			}
		}

		[PostProcessor("title")]
		public class StringTitlePostProcessor : PostProcessor
		{
			public StringTitlePostProcessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override IReadOnlyList<string> Execute(IReadOnlyList<string> buffer)
			{
				return ApplyToCaptures(
					buffer,
					s => s.ToTitleCase(),
					ExtractParameters(0).Regex);
			}
		}

		[PostProcessor("truncate")]
		public class StringTruncatePostProcessor : PostProcessor
		{
			public StringTruncatePostProcessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override IReadOnlyList<string> Execute(IReadOnlyList<string> buffer)
			{
				var processorParameters = ExtractParameters();
				var parameters = processorParameters.Params;

				var isLength = int.TryParse(parameters.First(), out var length);

				if (!isLength)
				{
					ThrowMisformattedParam(nameof(length));
				}

				var replacement = parameters.Skip(1).FirstOrDefault();

				return ApplyToCaptures(
					buffer,
					s => s.Truncate(length, replacement),
					processorParameters.Regex);
			}
		}

		[PostProcessor("index")]
		public class StringIndexPostProcessor : PostProcessor
		{
			public StringIndexPostProcessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override IReadOnlyList<string> Execute(IReadOnlyList<string> buffer)
			{
				var processorParameters = ExtractParameters(0, true);
				return buffer.Select(s => ExtractMatches(s, processorParameters, c => c.Index.ToString(), "-1").StringAggregate()).ToArray();
			}
		}

		[PostProcessor("extract")]
		public class StringExtractPostProcessor : PostProcessor
		{
			public StringExtractPostProcessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override IReadOnlyList<string> Execute(IReadOnlyList<string> buffer)
			{
				var processorParameters = ExtractParameters(0, true);
				return buffer.Select(s => ExtractMatches(s, processorParameters, c => c.Value, null).StringAggregate()).ToArray();
			}
		}

		[PostProcessor("replace")]
		public class StringReplacePostProcessor : PostProcessor
		{
			public StringReplacePostProcessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override IReadOnlyList<string> Execute(IReadOnlyList<string> buffer)
			{
				var procParams = ExtractParameters(1, true);
				return Replace(buffer, procParams);
			}
		}

		[PostProcessor("split")]
		public class StringSplitPostProcessor : PostProcessor
		{
			public StringSplitPostProcessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override IReadOnlyList<string> Execute(IReadOnlyList<string> buffer)
			{
				var parameters = ExtractParameters();
				var splitString = parameters.Params.First();

				return buffer.SelectMany(
					s => ExtractMatches(s, parameters)
						.SelectMany(m => m.Split(new[] { splitString }, StringSplitOptions.None))).ToArray();
			}
		}

		[PostProcessor("html")]
		public class StringHtmlPostProcessor : PostProcessor
		{
			public StringHtmlPostProcessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override IReadOnlyList<string> Execute(IReadOnlyList<string> buffer)
			{
				var procParams = ExtractParameters(0);
				var isEncode = procParams.Params.Contains("encode") || procParams.Params.All(p => p != "decode");

				string Action(string e) => isEncode ? HttpUtility.HtmlEncode(e) : HttpUtility.HtmlDecode(e);

				return buffer.Select(s => procParams.Regex == null ? Action(s) : s.ReplaceGroups(procParams.Regex.Regex, Action)).ToArray();
			}
		}
		
		[PostProcessor("date")]
		public class FormatDatePostProcessor : PostProcessor
		{
			public FormatDatePostProcessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override IReadOnlyList<string> Execute(IReadOnlyList<string> buffer)
			{
				var processorParameters = ExtractParameters();
				var parameters = processorParameters.Params;

				var outputFormat = parameters.First();
				var kindString = parameters.Skip(1).FirstOrDefault();
				var kind = kindString == "utc" ? DateTimeStyles.AssumeUniversal : DateTimeStyles.AssumeLocal;
				var inputFormat = parameters.Skip(2).FirstOrDefault();

				return ApplyToCaptures(
					buffer,
					s => inputFormat.IsFilled()
						&& DateTime.TryParseExact(s, inputFormat, CultureInfo.CurrentCulture, kind, out var parsed)
						? parsed.ToString(outputFormat)
						: (DateTime.TryParse(s, CultureInfo.CurrentCulture, kind, out parsed)
							? parsed.ToString(outputFormat)
							: s),
					processorParameters.Regex);
			}
		}

		[PostProcessor("number")]
		public class FormatNumberPostProcessor : PostProcessor
		{
			public FormatNumberPostProcessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override IReadOnlyList<string> Execute(IReadOnlyList<string> buffer)
			{
				var processorParameters = ExtractParameters();
				var parameters = processorParameters.Params;

				var format = parameters.First();

				return ApplyToCaptures(
					buffer,
					s => format.IsFilled() && double.TryParse(s, out var parsed)
						? parsed.ToString(format)
						: s,
					processorParameters.Regex);
			}
		}

		[PostProcessor("clear")]
		public class AggrClearPostProcessor : PostProcessor
		{
			public AggrClearPostProcessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override IReadOnlyList<string> Execute(IReadOnlyList<string> buffer)
			{
				return buffer.FilterEmpty().ToArray();
			}
		}

		[PostProcessor("first")]
		public class AggrFirstPostProcessor : PostProcessor
		{
			public AggrFirstPostProcessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override IReadOnlyList<string> Execute(IReadOnlyList<string> buffer)
			{
				return buffer.Take(1).ToArray();
			}
		}

		[PostProcessor("nth")]
		public class AggrNthPostProcessor : PostProcessor
		{
			public AggrNthPostProcessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override IReadOnlyList<string> Execute(IReadOnlyList<string> buffer)
			{
				var isNth = int.TryParse(ExtractParameters().Params.First(), out var nth);

				if (!isNth)
				{
					ThrowMisformattedParam(nameof(nth));
				}

				return buffer.Skip(nth - 1).Take(1).ToArray();
			}
		}

		[PostProcessor("last")]
		public class AggrLastPostProcessor : PostProcessor
		{
			public AggrLastPostProcessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override IReadOnlyList<string> Execute(IReadOnlyList<string> buffer)
			{
				var collection = buffer.ToArray();
				return collection.Skip(collection.Length - 1).ToArray();
			}
		}

		[PostProcessor("count")]
		public class AggrCountPostProcessor : PostProcessor
		{
			public AggrCountPostProcessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override IReadOnlyList<string> Execute(IReadOnlyList<string> buffer)
			{
				return new[] { buffer.Count().ToString() };
			}
		}

		[PostProcessor("join")]
		public class AggrJoinPostProcessor : PostProcessor
		{
			public AggrJoinPostProcessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override IReadOnlyList<string> Execute(IReadOnlyList<string> buffer)
			{
				var join = ExtractParameters(0).Params.FirstOrDefault() ?? "";
				return new[] { string.Join(join, buffer) };
			}
		}

		[PostProcessor("min")]
		public class AggrMinPostProcessor : PostProcessor
		{
			public AggrMinPostProcessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override IReadOnlyList<string> Execute(IReadOnlyList<string> buffer)
			{
				return
					new[]
					{
						buffer
							.Select(s => double.TryParse(s, out var parsed) ? parsed : (double?)null)
							.FilterNull()
							.Min().ToString()
					};
			}
		}

		[PostProcessor("max")]
		public class AggrMaxPostProcessor : PostProcessor
		{
			public AggrMaxPostProcessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override IReadOnlyList<string> Execute(IReadOnlyList<string> buffer)
			{
				return
					new[]
					{
						buffer
							.Select(s => double.TryParse(s, out var parsed) ? parsed : (double?)null)
							.FilterNull()
							.Max().ToString()
					};
			}
		}

		[PostProcessor("avg")]
		public class AggrAvgPostProcessor : PostProcessor
		{
			public AggrAvgPostProcessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override IReadOnlyList<string> Execute(IReadOnlyList<string> buffer)
			{
				return
					new[]
					{
						buffer
							.Select(s => double.TryParse(s, out var parsed) ? parsed : (double?)null)
							.FilterNull()
							.Average().ToString()
					};
			}
		}

		[PostProcessor("sum")]
		public class AggrSumPostProcessor : PostProcessor
		{
			public AggrSumPostProcessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override IReadOnlyList<string> Execute(IReadOnlyList<string> buffer)
			{
				return
					new[]
					{
						buffer
							.Select(s => double.TryParse(s, out var parsed) ? parsed : (double?)null)
							.FilterNull()
							.Sum().ToString()
					};
			}
		}

		[PostProcessor("top")]
		public class AggrTopPostProcessor : PostProcessor
		{
			public AggrTopPostProcessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override IReadOnlyList<string> Execute(IReadOnlyList<string> buffer)
			{
				var isTop = int.TryParse(ExtractParameters().Params.First(), out var top);

				if (!isTop)
				{
					ThrowMisformattedParam(nameof(top));
				}

				return buffer.FilterNull().Take(top).ToArray();
			}
		}

		[PostProcessor("distinct")]
		public class AggrDistinctPostProcessor : PostProcessor
		{
			public AggrDistinctPostProcessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override IReadOnlyList<string> Execute(IReadOnlyList<string> buffer)
			{
				var parameters = ExtractParameters(0);

				return
					parameters?.Regex?.Regex.IsFilled() != true
						? buffer.Distinct().ToArray()
						: buffer.DistinctBy(s => ExtractMatches(s, parameters).StringAggregate()).ToArray();
			}
		}

		[PostProcessor("order")]
		public class AggrOrderPostProcessor : PostProcessor
		{
			public AggrOrderPostProcessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override IReadOnlyList<string> Execute(IReadOnlyList<string> buffer)
			{
				var parameters = ExtractParameters(0);
				var isDesc = parameters?.Params.Contains("true");

				return
					parameters?.Regex?.Regex.IsFilled() != true
						? buffer.OrderBy(s => s).ToArray()
						: (isDesc == true
							? buffer.OrderByDescending(s => ExtractMatches(s, parameters).StringAggregate())
							: buffer.OrderBy(s => ExtractMatches(s, parameters).StringAggregate())).ToArray();
			}
		}

		[PostProcessor("where")]
		public class AggrWherePostProcessor : PostProcessor
		{
			public AggrWherePostProcessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override IReadOnlyList<string> Execute(IReadOnlyList<string> buffer)
			{
				return buffer.Where(s => ExtractMatches(s, ExtractParameters(0, true)).FilterEmpty().Any()).ToArray();
			}
		}

		[PostProcessor("filter")]
		public class AggrFilterPostProcessor : PostProcessor
		{
			public AggrFilterPostProcessor(GlobalState state, TokenKeyword keyword)
				: base(state, keyword)
			{ }

			public override IReadOnlyList<string> Execute(IReadOnlyList<string> buffer)
			{
				var bufferArray = buffer.ToArray();
				return bufferArray
					.Except(bufferArray
						.Where(s => ExtractMatches(s, ExtractParameters(0, true)).FilterEmpty().Any())).ToArray();
			}
		}

		[RuntimeGenerated]
		private class InternalActionPostProcessor : PostProcessor
		{
			private readonly Action action;

			public InternalActionPostProcessor(GlobalState state, Action action)
				: base(state, null)
			{
				this.action = action;
			}

			public override IReadOnlyList<string> Execute(IReadOnlyList<string> buffer)
			{
				action();
				return buffer;
			}
		}

		#endregion
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static partial class CrmHelpers
	{
		public static string[] NonUpdatableFields =
			{
				"createdby",
				"createdon",
				"createdonbehalfby",
				"importsequencenumber",
				"modifiedby",
				"modifiedon",
				"modifiedonbehalfby",
				"owningbusinessunit",
				"owningteam",
				"owninguser",
				"timezoneruleversionnumber",
				"utcconversiontimezonecode",
				"versionumber",
			};

		/// <summary>
		///     Retrieves the generic configuration record from CRM. All fields are returned.<br />
		///     If none is found, an empty entity record is returned.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="service">CRM Organisation Service</param>
		/// <param name="orgId">CRM Organisation ID to make caching unique</param>
		public static Entity GetGenericConfig(IOrganizationService service, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.CrmHelpers.GetGenericConfig";
			var configLocal = CacheHelpers.GetFromMemCache<Entity>(cacheKey, orgId: orgId);

			if (service != null && configLocal == null)
			{
				var isExist = CacheHelpers.GetFromMemCacheAdd("Yagasoft.Common.GetGenericConfig|IsExist",
					() => MetadataHelpers.IsEntityExist(service, "ldv_genericconfiguration", orgId, true), DateTime.Now.AddYears(1), orgId: orgId);

				if (isExist)
				{
					configLocal =
						(from configQ in new OrganizationServiceContext(service).CreateQuery("ldv_genericconfiguration")
						 where (int)configQ["statecode"] == 0
						 select configQ).FirstOrDefault();
					CacheHelpers.AddToMemCache(cacheKey, configLocal,
						DateTime.Now.AddMinutes(configLocal?.GetAttributeValue<int>("ldv_configurationcacheduration") ?? 0), orgId: orgId);
				}
			}

			return configLocal
				?? new Entity("ldv_genericconfiguration")
				{
					["ldv_name"] = "Generic Config"
				};
		}

		internal static DateTime GetMetadataCacheExpiryDate(IOrganizationService service, Guid? orgId = null)
		{
			return DateTime.Now.AddMinutes(GetGenericConfig(service, orgId)?
				.GetAttributeValue<int>("ldv_metadatacacheduration") ?? 0);
		}

		/// <summary>
		///     Get the value of the primary name field of the record.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetRecordName(IOrganizationService service, Entity record, bool isRetrieveEmpty = true, string primaryNameField = null,
			Guid? orgId = null)
		{
			if (primaryNameField.IsEmpty())
			{
				primaryNameField = MetadataHelpers
					.GetEntityAttribute<string>(service, record.LogicalName, MetadataHelpers.EntityAttribute.PrimaryNameAttribute, orgId);
			}

			var name = record.GetAttributeValue<string>(primaryNameField);

			return (name.IsEmpty() && isRetrieveEmpty)
				? GetRecordName(service, record.LogicalName, record.Id, primaryNameField, orgId)
				: name;
		}

		/// <summary>
		///     Get the value of the primary name field of the record.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetRecordName(IOrganizationService service, string logicalName, Guid id, string primaryNameField = null,
			Guid? orgId = null)
		{
			if (primaryNameField.IsEmpty())
			{
				primaryNameField = MetadataHelpers
					.GetEntityAttribute<string>(service, logicalName, MetadataHelpers.EntityAttribute.PrimaryNameAttribute, orgId);
			}

			return service.Retrieve(logicalName, id, new ColumnSet(primaryNameField)).GetAttributeValue<string>(primaryNameField);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsRecordExists(IOrganizationService service, string logicalName, Guid id, bool isActivity = false)
		{
			var query = new QueryByAttribute(logicalName);
			query.AddAttributeValue(isActivity ? "activityid" : logicalName + "id", id);
			query.ColumnSet = new ColumnSet(false);
			return service.RetrieveMultiple(query).Entities.Any();
		}

		/// <summary>
		///     Get the total number of records returned by the given query using a modded binary search algorithm.<br />
		///     It is recommended that the query's column-set is set to 'false' for speed.<br />
		///     Please note that the 'PageInfo' object in the query will be overwritten.<br />
		///     This does NOT work with CRM Online.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static int GetRecordsCount(IOrganizationService service, QueryExpression query, int countPerPage = 5000,
			string cookie = null, int lowerPageLimit = 1, int upperPageLimit = int.MaxValue)
		{
			var minPage = lowerPageLimit;
			var minPageCount = GetCountInPage(service, query, cookie, minPage, countPerPage);

			// first page is already partially filled or empty, so there are no records after for sure
			if (minPageCount >= 0 && minPageCount < countPerPage)
			{
				return minPageCount;
			}

			var maxPage = minPage;
			int maxPageCount;

			// get max page with partial fill or no records, after which there are surely no records
			// jump pages using an exponent of 2 because it's more likely that there are low number of pages than high
			while (true)
			{
				maxPage = maxPage * 2;
				maxPage = Math.Min(maxPage, upperPageLimit);
				maxPageCount = GetCountInPage(service, query, cookie, maxPage, countPerPage);

				// a filled page is considered a minimum, so set it to reduce search range
				if (maxPageCount == countPerPage)
				{
					minPage = maxPage;
					minPageCount = maxPageCount;
				}
				else
				{
					break;
				}
			}

			var isMaxNextToMin = (minPage + 1) == maxPage;
			var isMaxPageEmpty = maxPageCount == 0;
			var isMaxPagePartial = maxPageCount > 0 && maxPageCount < countPerPage;

			// max page is next to min full page, and is empty or partially filled, so we have reached the end
			if (isMaxPagePartial || (isMaxPageEmpty && isMaxNextToMin))
			{
				return ((maxPage - 1) * countPerPage) + maxPageCount;
			}

			int currentPage;
			int currentPageCount;

			while (true)
			{
				// get the current page in the middle point between min and max
				currentPage = (int)Math.Ceiling((maxPage + minPage) / 2d);

				// if current is not min or max, get its count
				if (currentPage != minPage && currentPage != maxPage)
				{
					currentPageCount = GetCountInPage(service, query, cookie, currentPage, countPerPage);
				}
				else
				{
					currentPageCount = currentPage == minPage ? minPageCount : maxPageCount;
				}

				var isCurrentNextToMin = (minPage + 1) == currentPage;
				var isCurrentNextToMax = (maxPage - 1) == currentPage;
				var isCurrentPageEmpty = currentPageCount == 0;
				var isCurrentPagePartial = currentPageCount > 0 && currentPageCount < countPerPage;
				var isCurrentPageFull = currentPageCount == countPerPage;

				// current page is next to min full page or max empty page
				// and is empty or partially filled, so we have reached the end
				if (isCurrentPagePartial
					|| (isCurrentPageEmpty && isCurrentNextToMin) || (isCurrentPageFull && isCurrentNextToMax))
				{
					break;
				}

				if (isCurrentPageEmpty)
				{
					maxPage = currentPage;
				}

				if (isCurrentPageFull)
				{
					minPage = currentPage;
				}
			}

			return ((currentPage - 1) * countPerPage) + currentPageCount;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static int GetCountInPage(IOrganizationService service, QueryExpression query, string cookie = null,
			int page = 1, int countPerPage = 5000)
		{
			query.PageInfo = query.PageInfo ?? new PagingInfo();
			query.PageInfo.Count = countPerPage;
			query.PageInfo.PageNumber = page;
			query.PageInfo.PagingCookie = query.PageInfo.PagingCookie ?? cookie;
			query.ColumnSet = query.ColumnSet ?? new ColumnSet(false);
			var result = service.RetrieveMultiple(query);
			query.PageInfo.PagingCookie = result.PagingCookie ?? cookie;
			return result.Entities.Count;
		}

		/// <summary>
		///     Gets records from CRM using the query given.<br />
		///     Pass '-1' for limit to get all records, and pass '-1' to page to ignore pages.
		///     The cookie is saved in the query itself during retrieval, so either save the cookie somewhere
		///     and reset it before passing it here, or simply reuse the query for next pages.<br />
		///     You should not skip pages with CRM Online.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IReadOnlyList<Entity> RetrieveRecords(IOrganizationService service, QueryExpression query,
			int limit = -1, int page = -1)
		{
			query.PageInfo =
				new PagingInfo
				{
					PageNumber = page <= 0
						? (query.PageInfo == null || query.PageInfo.PageNumber <= 0
							? 1
							: query.PageInfo.PageNumber)
						: page,
					Count = limit <= 0
						? (query.PageInfo == null || query.PageInfo.Count <= 0
							? 5000
							: query.PageInfo.Count)
						: (limit > 5000 ? 5000 : limit)
				};

			limit = limit <= 0 ? int.MaxValue : limit;

			EntityCollection records;
			var entities = new List<Entity>();

			// get all records
			do
			{
				// fetch the records
				records = service.RetrieveMultiple(query);

				// next time get the next bundle of records
				query.PageInfo.PagingCookie = records.PagingCookie;
				query.PageInfo.PageNumber++;

				// add to existing list
				entities.AddRange(records.Entities);
			}
			while (records.MoreRecords && entities.Count < limit && page <= 0);

			return entities;
		}

		/// <summary>
		///     Gets records from CRM using the FetchXML given.<br />
		///     Pass '-1' for limit to get all records, and pass '-1' to page to ignore pages.
		///     You should not skip pages with CRM Online.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IReadOnlyList<Entity> RetrieveRecords(IOrganizationService service, string fetchXml,
			int limit = -1, int page = -1)
		{
			var isAllPages = page <= 0;
			page = page <= 0 ? 1 : page;
			var loopLimit = limit <= 0 ? int.MaxValue : limit;
			var count = limit > 5000 ? 5000 : limit;
			string cookie = null;

			EntityCollection records;
			var entities = new List<Entity>();

			// get all records
			do
			{
				fetchXml = SetFetchPaging(fetchXml, page, count, cookie);

				// fetch the records
				records = service.RetrieveMultiple(new FetchExpression(fetchXml));

				// next time get the next bundle of records
				cookie = records.PagingCookie;
				page++;

				// add to existing list
				entities.AddRange(records.Entities);
			}
			while (records.MoreRecords && entities.Count < loopLimit && isAllPages);

			return entities;
		}

		private static string SetFetchPaging(string fetchXml, int page, int count = -1, string cookie = null)
		{
			var doc = new XmlDocument();
			doc.LoadXml(fetchXml);

			var fetchNode = doc.SelectNodes("//fetch")?.Cast<XmlNode>().FirstOrDefault();

			if (fetchNode == null)
			{
				throw new FormatException("FetchXML is not properly formatted.");
			}

			var tempDoc = fetchNode.OwnerDocument;

			if (tempDoc == null)
			{
				throw new FormatException("Couldn't find owner document in FetchXML node.");
			}

			if (fetchNode.Attributes == null)
			{
				throw new FormatException("Couldn't find attributes collection in FetchXML node.");
			}

			var attribute = tempDoc.CreateAttribute("page");
			attribute.Value = page.ToString();
			fetchNode.Attributes.SetNamedItem(attribute);

			if (count > 0)
			{
				attribute = tempDoc.CreateAttribute("count");
				attribute.Value = count.ToString();
				fetchNode.Attributes.SetNamedItem(attribute);
			}

			if (!string.IsNullOrWhiteSpace(cookie))
			{
				attribute = tempDoc.CreateAttribute("paging-cookie");
				attribute.Value = cookie;
				fetchNode.Attributes.SetNamedItem(attribute);
			}

			return doc.OuterXml;
		}

		/// <summary>
		///     Extracts the entity references from a record URL. Usually the URL is provided as input to a custom activity.<br />
		///     Execution Context can be null, it is used to cache inside a plugin only.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)<br />
		///     Credit: Yousra Mohamed
		/// </summary>
		public static IEnumerable<EntityReference> GetEntityReferencesFromUrls(IOrganizationService service, Guid? orgId = null,
			params string[] dynamicUrlParams)
		{
			// loop over dynamic urls to retrieve entity reference
			return
				from url in dynamicUrlParams
				where (url.Contains("etc=") || url.Contains("etn=")) && url.Contains("id=")
				select url.Trim().Split('?')
				into urlParts
				select urlParts[1].Split('&')
				into urlParams
				let objectTypeCode = urlParams.FirstOrDefault(p => p.Contains("etc="))?.Replace("etc=", "")
				let objectId = urlParams.First(p => p.Contains("id=")).Replace("id=", "")
				let entityName = objectTypeCode == null
					? urlParams.FirstOrDefault(p => p.Contains("etn="))?.Replace("etn=", "")
					: MetadataHelpers.GetEntityNameUsingTypeCode(service, int.Parse(objectTypeCode), orgId)
				select new EntityReference(entityName, Guid.Parse(objectId));
		}

		/// <summary>
		/// Returns a new Entity with the source and destination attributes merged.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
        public static T MergeAttributes<T>(this T destinationEntity, Entity sourceEntity)
            where T : Entity
        {
            sourceEntity.Require(nameof(sourceEntity));
	        destinationEntity.Require(nameof(destinationEntity));

	        return
				new Entity(destinationEntity.LogicalName)
					.IntegrateAttributes(destinationEntity)
					.IntegrateAttributes(sourceEntity)
					.ToEntity<T>();
        }

		/// <summary>
		/// Returns the destination Entity (left-side of . operator) with the destination attributes merged.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
        public static T IntegrateAttributes<T>(this T destinationEntity, Entity sourceEntity)
            where T : Entity
        {
            sourceEntity.Require(nameof(sourceEntity));
	        destinationEntity.Require(nameof(destinationEntity));

	        foreach (var kv in sourceEntity.Attributes)
	        {
		        destinationEntity[kv.Key] = kv.Value;
	        }

	        foreach (var kv in sourceEntity.FormattedValues)
	        {
		        destinationEntity.FormattedValues[kv.Key] = kv.Value;
	        }

	        return destinationEntity;
        }

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
        public static T ExtractEntityByAlias<T>(this Entity sourceEntity, string alias)
            where T : Entity
        {
            sourceEntity.Require(nameof(sourceEntity));
            alias.RequireNotEmpty(nameof(alias));

            var values = sourceEntity.Attributes
                .Where(kv => kv.Key.StartsWith($"{alias}."))
                .Select(kv => kv.Value as AliasedValue)
                .Where(v => v != null).ToArray();

	        var logicalName = values.FirstOrDefault()?.EntityLogicalName;

	        if (logicalName == null)
	        {
		        return null;
	        }

            var newEntity = new Entity(logicalName);

            foreach (var aliasedValue in values)
            {
                newEntity[aliasedValue.AttributeLogicalName] = aliasedValue.Value;
            }

            var formattedValues = sourceEntity.FormattedValues
                .Where(kv => kv.Key.StartsWith($"{alias}."));

            foreach (var kv in formattedValues)
            {
                newEntity.FormattedValues[kv.Key.Replace($"{alias}.", "")] = kv.Value;
            }

            return newEntity.ToEntity<T>();
        }

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
        public static T ExcludeExistingValues<T>(this T newRecord, Entity existingRecord)
            where T : Entity
        {
            newRecord.Require(nameof(newRecord));
            existingRecord.Require(nameof(existingRecord));

            // IDs' will probably match and be removed below; so restore it after
            var id = newRecord.Id;

            // 'ToArray' is used to create a new collection; modifying collections mid iteration causes exception
            foreach (var attribute in newRecord.Attributes.ToArray())
            {
                var key = attribute.Key;
                var value = attribute.Value;

                bool isEqual;

                switch (value)
                {
                    case OptionSetValue optionSetValue:
                        var existingOsValue = existingRecord.GetAttributeValue<OptionSetValue>(key);
                        isEqual = optionSetValue.Value == existingOsValue?.Value;
                        break;

                    case EntityReference entityReference:
                        var existingRefValue = existingRecord.GetAttributeValue<EntityReference>(key);
                        isEqual = entityReference.Id == existingRefValue?.Id;
                        break;

                    case Money money:
                        var existingMoneyValue = existingRecord.GetAttributeValue<Money>(key);
                        isEqual = money.Value == existingMoneyValue?.Value;
                        break;

                    default:
                        var existingValue = existingRecord.GetAttributeValue<object>(key);
                        isEqual = value == existingValue || value?.Equals(existingValue) == true;
                        break;
                }

                if (isEqual)
                {
                    newRecord.Attributes.Remove(key);
                }
            }

            newRecord.Id = id;

            return newRecord;
        }

		/// <summary>
		///     Executes given requests in a transaction. The returned value should only be taken into consideration
		///     if 'isReturnResponses' is 'true'.<br />
		///     All executed requests will be rolled back if one fails.<br />
		///     The handler takes 'current batch index (1, 2 ... etc.), total batch count, responses' as parameters.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IDictionary<OrganizationRequest, ExecuteBulkResponse> ExecuteTransaction(this IEnumerable<OrganizationRequest> requestsParam,
			IOrganizationService service, bool isReturnResponses = false, int batchSize = 1000,
	        Action<int, int, IDictionary<OrganizationRequest, ExecuteBulkResponse>> bulkFinishHandler = null)
		{
			var requests = requestsParam.ToArray();

	        if (requests?.Any() != true)
	        {
                return new Dictionary<OrganizationRequest, ExecuteBulkResponse>();
	        }

            var bulkRequest =
                new ExecuteTransactionRequest
                {
                    Requests = new OrganizationRequestCollection(),
                    ReturnResponses = isReturnResponses
                };

            var responses = new Dictionary<OrganizationRequest, ExecuteBulkResponse>();
	        var perBulkResponses = new Dictionary<OrganizationRequest, ExecuteBulkResponse>();

            var batchCount = Math.Ceiling(requests.Length / (double)batchSize);

            // take bulk size only for each iteration
            for (var i = 0; i < batchCount; i++)
            {
                // clear the previous batch
                bulkRequest.Requests.Clear();
	            perBulkResponses.Clear();

                // take batches
                bulkRequest.Requests.AddRange(requests.Skip(i * batchSize).Take(batchSize));
                var bulkResponses = (ExecuteTransactionResponse)service.Execute(bulkRequest);

                // no need to build a response
                if (!isReturnResponses)
                {
	                bulkFinishHandler?.Invoke(i + 1, (int)batchCount, perBulkResponses);
                    continue;
                }

                for (var j = 0; j < bulkResponses.Responses.Count; j++)
                {
                    var request = bulkRequest.Requests[j];
                    var bulkResponse = bulkResponses.Responses[j];

                    var response =
                        new ExecuteBulkResponse
                        {
                            RequestType = request.GetType(),
                            Response = bulkResponse,
                            ResponseType = bulkResponse?.GetType()
                        };
                    responses[request] = response;
					perBulkResponses[request] = response;
                }

				bulkFinishHandler?.Invoke(i + 1, (int)batchCount, perBulkResponses);
            }

            return responses;
        }

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IDictionary<OrganizationRequest, ExecuteBulkResponse> ExecuteBulk(IOrganizationService service,
			IReadOnlyList<OrganizationRequest> requests,
			bool isReturnResponses = false, int batchSize = 1000, bool isContinueOnError = true,
			Action<int, int, IDictionary<OrganizationRequest, ExecuteBulkResponse>> bulkFinishHandler = null)
		{
			return requests.ExecuteBulk(service, isReturnResponses, batchSize, isContinueOnError, bulkFinishHandler);
		}

		/// <summary>
		///     Executes given requests in bulk. The returned value should only be taken into consideration
		///     if 'isReturnResponses' is 'true'.<br />
		///     The handler takes 'current batch index (1, 2 ... etc.), total batch count, responses' as parameters.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IDictionary<OrganizationRequest, ExecuteBulkResponse> ExecuteBulk(this IEnumerable<OrganizationRequest> requestsParam,
			IOrganizationService service,
			bool isReturnResponses = false, int batchSize = 1000, bool isContinueOnError = true,
			Action<int, int, IDictionary<OrganizationRequest, ExecuteBulkResponse>> bulkFinishHandler = null)
		{
			var requests = requestsParam.ToArray();

			if (requests?.Any() != true)
			{
				return new Dictionary<OrganizationRequest, ExecuteBulkResponse>();
			}

			var bulkRequest =
				new ExecuteMultipleRequest
				{
					Requests = new OrganizationRequestCollection(),
					Settings =
						new ExecuteMultipleSettings
						{
							ContinueOnError = isContinueOnError,
							ReturnResponses = isReturnResponses
						}
				};

			var responses = new Dictionary<OrganizationRequest, ExecuteBulkResponse>();
			var perBulkResponses = new Dictionary<OrganizationRequest, ExecuteBulkResponse>();

			var batchCount = Math.Ceiling(requests.Length / (double)batchSize);

			// take bulk size only for each iteration
			for (var i = 0; i < batchCount; i++)
			{
				// clear the previous batch
				bulkRequest.Requests.Clear();
				perBulkResponses.Clear();

				// take batches
				bulkRequest.Requests.AddRange(requests.Skip(i * batchSize).Take(batchSize));
				var bulkResponses = (ExecuteMultipleResponse)service.Execute(bulkRequest);

				// no need to build a response
				if (!isReturnResponses)
				{
					// break on error and no 'continue on error' option
					if (!isContinueOnError && (bulkResponses.IsFaulted || bulkResponses.Responses.Any(e => e.Fault != null)))
					{
						break;
					}
					else
					{
						bulkFinishHandler?.Invoke(i + 1, (int)batchCount, perBulkResponses);
						continue;
					}
				}

				for (var j = 0; j < bulkResponses.Responses.Count; j++)
				{
					var request = bulkRequest.Requests[j];
					var bulkResponse = bulkResponses.Responses[j];
					var fault = bulkResponse.Fault;
					string faultMessage = null;

					// build fault message
					if (fault != null)
					{
						var builder = new StringBuilder();
						builder.AppendFormat("Message: \"{0}\", code: {1}", fault.Message, fault.ErrorCode);

						if (fault.TraceText != null)
						{
							builder.AppendFormat(", trace: \"{0}\"", fault.TraceText);
						}

						if (fault.InnerFault != null)
						{
							builder.AppendFormat(", inner message: \"{0}\", inner code: {1}", fault.InnerFault.Message,
								fault.InnerFault.ErrorCode);

							if (fault.InnerFault.TraceText != null)
							{
								builder.AppendFormat(", trace: \"{0}\"", fault.InnerFault.TraceText);
							}
						}

						faultMessage = builder.ToString();
					}

					var response =
						new ExecuteBulkResponse
						{
							RequestType = request.GetType(),
							Response = bulkResponse.Response,
							ResponseType = bulkResponse.Response == null ? null : bulkResponse.Response.GetType(),
							Fault = fault,
							FaultMessage = faultMessage
						};
					responses[request] = response;
					perBulkResponses[request] = response;
				}

				bulkFinishHandler?.Invoke(i + 1, (int)batchCount, perBulkResponses);

				// break on error and no 'continue on error' option
				if (!isContinueOnError && (bulkResponses.IsFaulted || bulkResponses.Responses.Any(e => e.Fault != null)))
				{
					break;
				}
			}

			return responses;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RunWorkflow(IOrganizationService service, Guid entityId, Guid workflowId)
		{
			service.Execute(
				new ExecuteWorkflowRequest
				{
					EntityId = entityId,
					WorkflowId = workflowId
				});
		}

		/// <summary>
		///     Checks whether the given FetchXML returns any records.
		///  The record's ID is added to the FetchXML is as a condition.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsConditionMet(IOrganizationService service, string fetchXml,
			EntityReference record, Guid? orgId = null)
		{
			service.Require("service");
			fetchXml.RequireNotEmpty("fetchXml");
			record.Require("record");

			var primaryIdName = MetadataHelpers.GetEntityAttributes(service, record.LogicalName, orgId,
				MetadataHelpers.EntityAttribute.PrimaryIdAttribute).PrimaryIdAttribute;
			var finalFetchXml = string.Empty;

			var querySplit = fetchXml.Split(new[] { "</entity>" }, StringSplitOptions.None);

			finalFetchXml += querySplit[0];
			finalFetchXml += "<filter type='and'> ";
			finalFetchXml += "<condition attribute='" + primaryIdName + "' operator='eq' value= '" + record.Id + "' /> ";
			finalFetchXml += "</filter>" + "</entity>";
			finalFetchXml += querySplit[querySplit.Length - 1];

			return service.RetrieveMultiple(new FetchExpression(finalFetchXml)).Entities.Any();
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string BuildExceptionMessage(Exception ex, string preMessage = null, bool isUseExStackTrace = false, int depth = 0)
		{
			return ex.BuildExceptionMessage(preMessage, isUseExStackTrace, depth);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string BuildFaultMessage(OrganizationServiceFault fault, int depth)
		{
			return fault.BuildFaultMessage(depth);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static InvalidPluginExecutionException BuildInvalidPluginExecException(Exception ex, string preMessage = null)
		{
			preMessage = (preMessage == null ? string.Empty : preMessage + " ") +
				"<div style=\"display:none\">Exception: " + ex.GetType() + " => \"" + ex.Message + "\"." +
				(ex.InnerException == null
					? string.Empty
					: " Inner exception: " + ex.InnerException.GetType() + " => \"" + ex.InnerException.Message + "\".") +
				"</div>";

			var message = "\nException: " + ex.GetType() + " => \"" + ex.Message + "\"." +
				"\nSource: " + ex.Source +
				"\n\n" + (ex.StackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common")) + "\n" +
				(ex.InnerException == null
					? string.Empty
					: "\n\nInner exception: " + ex.InnerException.GetType() + " => \"" +
						ex.InnerException.Message + "\"." +
						"\nSource: " + ex.InnerException.Source +
						"\n\n" + ex.InnerException.StackTrace + "\n");

			message = message
				.Replace("\"", "&quot;").Replace("'", "\\'").Replace("\n", "<br />").Replace("\\n", "<br />").Replace("\r",
					string.Empty);

			var script = "<br />" +
				"<button class=\"ms-crm-RefreshDialog-Button\" style=\"margin-right: 30px; margin-left: 8px;\"" +
				"onclick=\"" +
				" var w = window.open('', 'Error Details', 'height=100, width=600, toolbar=no, menubar=no, resizable=no, scrollbars=yes, location=no, directories=no, status=no');"
				+
				" parent.$(w.document.body).html('" + message + "');" +
				" w.document.title = 'Error Details';" +
				" parent.$(w.document.body).css({ 'color': 'blue', 'font-size': 13 });" +
				"\">More Details</button>"
				+ "<br />"
				+ "<br />";

			return new InvalidPluginExecutionException(preMessage + script, ex);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetAttributeName(string field, Entity record)
		{
			record.FormattedValues.TryGetValue(field, out var label);
			return label.IsFilled() ? label : GetAttributeName(record.GetAttributeValue<object>(field));
		}

		public static string GetAttributeName(object fieldValue)
		{
			if (fieldValue == null)
			{
				return null;
			}

			if (fieldValue is string s)
			{
				return s;
			}

			if (fieldValue is OptionSetValue value)
			{
				return value.Value.ToString();
			}

			if (fieldValue is DateTime time)
			{
				return time.ToString("yyyy-MM-ddTHH:mm:ss.fffZ");
			}

			if (fieldValue is EntityReference fieldRef)
			{
				return $"{fieldRef.LogicalName}:{fieldRef.Id.ToString().ToUpper()}";
			}

			if (fieldValue is Guid fieldGuid)
			{
				return fieldGuid.ToString().ToUpper();
			}

			if (fieldValue is int fieldInt)
			{
				return fieldInt.ToString();
			}

			if (fieldValue is Money fieldMoney)
			{
				return fieldMoney.Value.ToString();
			}

			return fieldValue.ToString();
		}

		#region Relations helpers

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IReadOnlyList<Entity> GetRelatedRecords(IOrganizationService service, EntityReference entity,
			MetadataHelpers.RelationType[] relationTypes, FilterExpression filter = null,
			Guid? orgId = null, params string[] attributes)
		{
			if (relationTypes == null || relationTypes.Length <= 0)
			{
				return Array.Empty<Entity>();
			}

			var relationAttributes =
				new[]
				{
					MetadataHelpers.RelationAttribute.SchemaName, MetadataHelpers.RelationAttribute.RelationshipType, MetadataHelpers.RelationAttribute.IntersectEntityName,
					MetadataHelpers.RelationAttribute.ReferencedEntity, MetadataHelpers.RelationAttribute.ReferencedAttribute,
					MetadataHelpers.RelationAttribute.ReferencingEntity, MetadataHelpers.RelationAttribute.ReferencingAttribute,
					MetadataHelpers.RelationAttribute.Entity1LogicalName, MetadataHelpers.RelationAttribute.Entity1IntersectAttribute,
					MetadataHelpers.RelationAttribute.Entity2LogicalName, MetadataHelpers.RelationAttribute.Entity2IntersectAttribute
				};

			var relations = MetadataHelpers
				.GetCustomRelationships(service, entity.LogicalName, relationTypes, relationAttributes, orgId)
				.Select(r =>
						{
							var relation =
								MetadataHelpers.BuildRelationMetadata(r,
									r.RelationshipType == RelationshipType.OneToManyRelationship
										? MetadataHelpers.RelationType.OneToManyRelationships
										: MetadataHelpers.RelationType.ManyToManyRelationships);
							relation.Require(nameof(relation), $"Unable to find relation '{r.SchemaName}' in entity '{entity.LogicalName}'.");
							return relation;
						});
			return GetRelatedRecordsInner(service, entity, relations.ToArray(), filter, orgId, attributes);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IReadOnlyList<Entity> GetRelatedRecords(IOrganizationService service, EntityReference entity,
			string relationName, FilterExpression filter = null, Guid? orgId = null, params string[] attributes)
		{
			service.Require(nameof(service));
			entity.Require(nameof(entity));
			relationName.RequireNotEmpty(nameof(relationName));

			var relation = MetadataHelpers.GetRelation(service, entity.LogicalName, relationName, orgId);
			relation.Require(nameof(relation), $"Unable to find relation '{relationName}' in entity '{entity.LogicalName}'.");

			return GetRelatedRecordsInner(service, entity, new[] { relation }, filter,
				orgId, attributes);
		}

		private static IReadOnlyList<Entity> GetRelatedRecordsInner(IOrganizationService service, EntityReference entity,
			IReadOnlyList<RelationMetadata> relations, FilterExpression filter = null, Guid? orgId = null, params string[] attributes)
		{
			var related = new List<Entity>();

			var idFieldName = MetadataHelpers.GetEntityAttribute<string>(service, entity.LogicalName,
				MetadataHelpers.EntityAttribute.PrimaryIdAttribute, orgId);

			var manyToMany = relations.Where(relation => relation.Type == MetadataHelpers.RelationType.ManyToManyRelationships).ToArray();

			if (manyToMany.Any())
			{
				foreach (var rel in manyToMany)
				{
					var entity2Name = rel.Entity1Name == entity.LogicalName
						? rel.Entity2Name
						: rel.Entity1Name;
					var entity2Id = rel.Entity1Name == entity.LogicalName
						? rel.Entity2FieldName
						: rel.Entity1FieldName;
					var intersectEntity = rel.IntersectingEntityName;

					related.AddRange(GetRecords(entity, service, entity2Name, intersectEntity, entity2Id,
						entity2Id, idFieldName, -1, -1, filter, attributes));
				}
			}

			var oneToMany = relations.Where(relation => relation.Type == MetadataHelpers.RelationType.OneToManyRelationships).ToArray();

			if (oneToMany.Any())
			{
				foreach (var rel in oneToMany)
				{
					var entity2Name = rel.Entity2Name;
					var entity2LookupName = rel.Entity2FieldName;

					related.AddRange(GetRecords(entity, service, entity2Name, entity.LogicalName,
						entity2LookupName, idFieldName, idFieldName, -1, -1, filter, attributes));
				}
			}

			var manyToOne = relations.Where(relation => relation.Type == MetadataHelpers.RelationType.ManyToOneRelationships).ToArray();

			if (manyToOne.Any())
			{
				foreach (var rel in manyToOne)
				{
					var entity2Name = rel.Entity1Name;
					var entity2LookupName = rel.Entity1FieldName;

					related.AddRange(GetRecords(entity, service, entity2Name, entity.LogicalName,
						entity2LookupName, idFieldName, idFieldName, -1, -1, filter, attributes));
				}
			}

			return related;
		}

		#endregion

		#region User helpers

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IReadOnlyList<Guid> GetTeamMembers(IOrganizationService service, Guid teamId)
		{
			using (var svcContext = new OrganizationServiceContext(service))
			{
				return
					(from user in svcContext.CreateQuery("systemuser")
						join member in svcContext.CreateQuery("teammembership")
							on user["systemuserid"] equals member["systemuserid"]
						join teamQ in svcContext.CreateQuery("team")
							on member["teamid"] equals teamQ["teamid"]
						where teamQ["teamid"].Equals(teamId)
						select (Guid)user["systemuserid"]).ToArray();
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IReadOnlyList<Guid> GetQueueMembers(IOrganizationService service, Guid queueId)
		{
			using (var svcContext = new OrganizationServiceContext(service))
			{
				return
					(from user in svcContext.CreateQuery("systemuser")
						join member in svcContext.CreateQuery("queuemembership")
							on user["systemuserid"] equals member["systemuserid"]
						join queue in svcContext.CreateQuery("queue")
							on member["queueid"] equals queue["queueid"]
						where queue["queueid"].Equals(queueId)
						select (Guid)user["systemuserid"]).ToArray();
			}
		}

		/// <summary>
		///     From the SDK: http://msdn.microsoft.com/en-us/library/hh670609.aspx <br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static int GetPreferredLangCode(IOrganizationService service, EntityReference record)
		{
			if (record.LogicalName == "systemuser")
			{
				var userSettingsQuery = new QueryExpression("usersettings");
				userSettingsQuery.ColumnSet.AddColumns("uilanguageid", "systemuserid");
				userSettingsQuery.Criteria.AddCondition("systemuserid", ConditionOperator.Equal, record.Id);
				var userSettings = service.RetrieveMultiple(userSettingsQuery);

				if (userSettings.Entities.Count > 0)
				{
					var code = (int)userSettings.Entities[0]["uilanguageid"];
					return code <= 0 ? 1033 : code;
				}
			}
			else if (record.LogicalName == "account" || record.LogicalName == "contact")
			{
				Entity result;

				result = service.Retrieve(record.LogicalName, record.Id, new ColumnSet("ldv_preferredcommunicationlanguage"));

				if (!result.Contains("ldv_preferredcommunicationlanguage"))
				{
					return 1033;
				}

				return ((OptionSetValue)result["ldv_preferredcommunicationlanguage"]).Value;
			}
			else
			{
				throw new NotSupportedException("Entity does not support a default language spec '" + record.LogicalName + "'.");
			}

			return 1033;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static int GetUserTimeZoneBiasMinutes(IOrganizationService service, Guid userId)
		{
			return GetUsersTimeZoneBiasMinutes(service, userId).FirstOrDefault().Value;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IDictionary<Guid, int> GetUsersTimeZoneBiasMinutes(IOrganizationService service, params Guid[] userIds)
		{
			var query = new QueryExpression("usersettings");
			var filter = new FilterExpression(LogicalOperator.Or);

			foreach (var userId in userIds)
			{
				filter.AddCondition("systemuserid", ConditionOperator.Equal, userId);
			}

			query.ColumnSet = new ColumnSet("systemuserid", "timezonebias");
			query.Criteria.Filters.Add(filter);

			var userSettings = service.RetrieveMultiple(query).Entities;

			if (userSettings == null || userSettings.Count < userIds.Length
				|| userSettings.Any(settings => !settings.Contains("timezonebias")))
			{
				throw new Exception("Can't retrieve the settings of the users.");
			}

			return userSettings.ToDictionary(
				settings => settings.GetAttributeValue<Guid>("systemuserid"),
				settings => settings.GetAttributeValue<int>("timezonebias") * -1);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static Guid? GetManagerId(IOrganizationService service, Guid userId)
		{
			var user = service.Retrieve("systemuser", userId, new ColumnSet("parentsystemuserid"));

			if (!user.Contains("parentsystemuserid"))
			{
				throw new Exception("User record does not contain a manager.");
			}

			return ((EntityReference)user["parentsystemuserid"]).Id;
		}

		/// <summary>
		///     Validates that the owner can edit the record.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="targetRecord">The target record to check for access rights.</param>
		/// <param name="targetOwner">The owner to check the rights for.</param>
		public static bool CanUpdateRecord(IOrganizationService service, EntityReference targetRecord,
			EntityReference targetOwner)
		{
			// request user's access rights to current record
			var principalAccessRequest =
				new RetrievePrincipalAccessRequest
				{
					Principal = targetOwner,
					Target = targetRecord
				};

			// response will contain AccessRights mask, like AccessRights.WriteAccess | AccessRights.ReadAccess | ...
			var principalAccessResponse = (RetrievePrincipalAccessResponse)service.Execute(principalAccessRequest);

			// if user can't edit record
			if ((principalAccessResponse.AccessRights & AccessRights.WriteAccess) != AccessRights.WriteAccess)
			{
				return false;
			}

			return true;
		}

		#endregion

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetRecordUrl(IOrganizationService service, EntityReference recordRef, Guid? orgId = null)
		{
			recordRef.Require(nameof(recordRef));

			var config = GetGenericConfig(service, orgId);
			var baseUrl = config.GetAttributeValue<string>("ldv_organisationbaseurl");
			baseUrl.RequireNotEmpty(nameof(baseUrl));
			var rowTemplate = config.GetAttributeValue<string>("ys_rowurltemplate");
			rowTemplate.RequireNotEmpty(nameof(rowTemplate));

			return $"{baseUrl.Trim('/')}/main.aspx"
				+ $"?{(rowTemplate.Replace("{id}", recordRef.Id.ToString().ToUpper()).Replace("{table}", recordRef.LogicalName))}";
		}

		/// <summary>
		private static IReadOnlyList<Entity> GetRecords(EntityReference entity, IOrganizationService service,
			string fromEntityName, string toEntityName, string fromFieldName, string toFieldName,
			string intersectIdFieldName, int limit = -1, int page = -1,
			FilterExpression filter = null, params string[] attributes)
		{
			return RetrieveRecords(service, BuildRetrieveQuery(entity, fromEntityName, toEntityName,
				fromFieldName, toFieldName, intersectIdFieldName, filter, attributes), limit, page);
		}

		private static QueryExpression BuildRetrieveQuery(EntityReference entity,
			string fromEntityName, string toEntityName, string fromFieldName, string toFieldName,
			string intersectIdFieldName, FilterExpression filter = null, params string[] attributes)
		{
			// create the query taking into account paging
			var query = new QueryExpression(fromEntityName);
			query.LinkEntities.Add(new LinkEntity(fromEntityName, toEntityName, fromFieldName, toFieldName, JoinOperator.Inner));
			query.LinkEntities[0].EntityAlias = "linkedEntityAlias";
			query.Criteria.AddCondition("linkedEntityAlias", intersectIdFieldName, ConditionOperator.Equal, entity.Id);

			if (filter != null)
			{
				query.Criteria.AddFilter(filter);
			}

			if (attributes.Length == 1 && attributes[0] == "*")
			{
				query.ColumnSet = new ColumnSet(true);
			}
			else if (attributes.Length > 0)
			{
				query.ColumnSet = new ColumnSet(attributes);
			}
			else
			{
				query.ColumnSet = new ColumnSet(false);
			}

			return query;
		}

		public static string SecureConnectionString(string connectionString)
		{
			return Regex
				.Replace(Regex
					.Replace(connectionString, @"Password\s*?=.*?(?:;{0,1}$|;)", "Password=********;")
					.Replace("\r\n", " "),
					@"\s+", " ")
				.Replace(" = ", "=");
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IEnumerable<TEntity> ToEntity<TEntity>(this IEnumerable<Entity> entities) where TEntity : Entity
		{
			return entities.Select(e => e.ToEntity<TEntity>());
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static int? GetTimeZoneBias(int timeZoneCode, IOrganizationService service)
		{
			var query = new QueryByAttribute("timezonedefinition");
			query.AddAttributeValue("timezonecode", timeZoneCode);
			query.ColumnSet = new ColumnSet("bias");
			var bias = service.RetrieveMultiple(query).Entities.FirstOrDefault()?.GetAttributeValue<int?>("bias");
			return -bias;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetTimeZoneStandardName(int timeZoneCode, IOrganizationService service)
		{
			var query = new QueryByAttribute("timezonedefinition");
			query.AddAttributeValue("timezonecode", timeZoneCode);
			query.ColumnSet = new ColumnSet("standardname");
			return service.RetrieveMultiple(query).Entities.FirstOrDefault()?.GetAttributeValue<string>("standardname")
				?? throw new TimeZoneNotFoundException($"Time zone not found in CRM ({timeZoneCode}).");
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static DateTime ConvertToUtc(DateTime date, int timeZoneCode, IOrganizationService service)
		{
			return TimeZoneInfo
				.ConvertTimeToUtc(date,
					TimeZoneInfo.FindSystemTimeZoneById(GetTimeZoneStandardName(timeZoneCode, service)));
		}
	}

	/// <summary>
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static partial class MetadataHelpers
	{
		private static readonly string[] nonStandard =
		{
			"applicationfile",
			"attachment", // Not included with CrmSvcUtil 6.0.0001.0061
			"authorizationserver", // Not included with CrmSvcUtil 6.0.0001.0061
			"businessprocessflowinstance",
			// Not included with CrmSvcUtil 2013  http://community.dynamics.com/crm/f/117/t/117642.aspx
			"businessunitmap", // Not included with CrmSvcUtil 2013
			"clientupdate", // Not included with CrmSvcUtil 2013
			"commitment", // Not included with CrmSvcUtil 2013
			"competitoraddress", // isn't include in CrmSvcUtil but it shows in the default solution
			"complexcontrol", // Not Included with CrmSvcUtil 2013
			"dependencynode", // Not Included with CrmSvcUtil 2013
			"displaystringmap", // Not Included with CrmSvcUtil 2013
			"documentindex", // Not Included with CrmSvcUtil 2013
			"emailhash", // Not Included with CrmSvcUtil 2013
			"emailsearch", // Not Included with CrmSvcUtil 2013
			"filtertemplate", // Not Included with CrmSvcUtil 2013
			"imagedescriptor", // Not included with CrmSvcUtil 2013
			"importdata", // Not included with CrmSvcUtil 6.0.0001.0061
			"integrationstatus", // Not included with CrmSvcUtil 6.0.0001.0061
			"interprocesslock", // Not included with CrmSvcUtil 6.0.0001.0061
			"multientitysearchentities", // Not included with CrmSvcUtil 6.0.0001.0061
			"multientitysearch", // Not included with CrmSvcUtil 6.0.0001.0061
			"notification", // Not included with CrmSvcUtil 6.0.0001.0061
			"organizationstatistic", // Not included with CrmSvcUtil 6.0.0001.0061
			"owner", // Not included with CrmSvcUtil 2013
			"partnerapplication", // Not included with CrmSvcUtil 6.0.0001.0061
			"principalattributeaccessmap", // Not included with CrmSvcUtil 6.0.0001.0061
			"principalobjectaccessreadsnapshot", // Not included with CrmSvcUtil 6.0.0001.0061
			"principalobjectaccess", // Not included with CrmSvcUtil 6.0.0001.0061
			"privilegeobjecttypecodes", // Not included with CrmSvcUtil 6.0.0001.0061
			"postregarding", // Not included with CrmSvcUtil 2013
			"postrole", // Not included with CrmSvcUtil 2013
			"subscriptionclients", // Not included with CrmSvcUtil 6.0.0001.0061
			"salesprocessinstance", // Not included with CrmSvcUtil 6.0.0001.0061
			"recordcountsnapshot", // Not included with CrmSvcUtil 6.0.0001.0061
			"replicationbacklog", // Not included with CrmSvcUtil 6.0.0001.0061
			"resourcegroupexpansion", // Not included with CrmSvcUtil 6.0.0001.0061
			"ribboncommand", // Not included with CrmSvcUtil 6.0.0001.0061
			"ribboncontextgroup", // Not included with CrmSvcUtil 6.0.0001.0061
			"ribbondiff", // Not included with CrmSvcUtil 6.0.0001.0061
			"ribbonrule", // Not included with CrmSvcUtil 6.0.0001.0061
			"ribbontabtocommandmap", // Not included with CrmSvcUtil 6.0.0001.0061
			"roletemplate", // Not included with CrmSvcUtil 6.0.0001.0061
			"statusmap", // Not included with CrmSvcUtil 6.0.0001.0061
			"stringmap", // Not included with CrmSvcUtil 6.0.0001.0061
			"sqlencryptionaudit",
			"subscriptionsyncinfo",
			"subscription", // Not included with CrmSvcUtil 6.0.0001.0061
			"subscriptiontrackingdeletedobject",
			"systemapplicationmetadata", // Not included with CrmSvcUtil 6.0.0001.0061
			"systemuserbusinessunitentitymap", // Not included with CrmSvcUtil 6.0.0001.0061
			"systemuserprincipals", // Not included with CrmSvcUtil 6.0.0001.0061
			"traceassociation", // Not included with CrmSvcUtil 6.0.0001.0061
			"traceregarding", // Not included with CrmSvcUtil 6.0.0001.0061
			"unresolvedaddress", // Not included with CrmSvcUtil 6.0.0001.0061
			"userapplicationmetadata", // Not included with CrmSvcUtil 6.0.0001.0061
			"userfiscalcalendar", // Not included with CrmSvcUtil 6.0.0001.0061
			"webwizard", // Not included with CrmSvcUtil 6.0.0001.0061
			"wizardaccessprivilege", // Not included with CrmSvcUtil 6.0.0001.0061
			"wizardpage", // Not included with CrmSvcUtil 6.0.0001.0061
			"workflowwaitsubscription", // Not included with CrmSvcUtil 6.0.0001.0061
			// the following cause duplicate errors in generated code
			"bulkdeleteoperation",
			"reportlink",
			"rollupjob"
		};

		public enum EntityAttribute
		{
			LogicalName,
			SchemaName,
			DisplayName,
			PrimaryIdAttribute,
			PrimaryNameAttribute,
			ObjectTypeCode,
			IsActivity,
			Keys
		}

		public enum FieldAttribute
		{
			OptionSet,
			DisplayName
		}

		public enum RelationAttribute
		{
			SchemaName,
			RelationshipType,
			ReferencedEntity,
			ReferencedAttribute,
			ReferencingEntity,
			ReferencingAttribute,
			IntersectEntityName,
			Entity1LogicalName,
			Entity1IntersectAttribute,
			Entity2LogicalName,
			Entity2IntersectAttribute
		}

		public enum RelationType
		{
			OneToManyRelationships,
			ManyToOneRelationships,
			ManyToManyRelationships
		}

		/// <summary>
		///     Checks whether the given field exists in the entity by its logical name.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsFieldExistInEntity(IOrganizationService service, string entityName, string fieldName, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.IsFieldExistInEntity|{entityName}|{fieldName}";
			var isExist = CacheHelpers.GetFromMemCache<bool?>(cacheKey, orgId: orgId);

			if (isExist.HasValue)
			{
				return isExist.Value;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.AddRange("Attributes");

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions
				.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entityName));

			var attributeProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			attributeProperties.PropertyNames.AddRange("LogicalName");

			var attributeFilter = new MetadataFilterExpression(LogicalOperator.And);
			attributeFilter.Conditions
				.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, fieldName));

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties,
					AttributeQuery =
						new AttributeQueryExpression
						{
							Criteria = attributeFilter,
							Properties = attributeProperties
						}
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			var result = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest)).EntityMetadata;
			return CacheHelpers.AddToMemCache(cacheKey,
				result != null && result.Count > 0 && result.First().Attributes.Length > 0
					&& result.First().Attributes.Any(attribute => attribute.LogicalName == fieldName),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
		}

		/// <summary>
		///     Get the names of all entities.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IDictionary<string, string> GetEntityNames(IOrganizationService service, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.GetEntityNames";
			var entityNames = CacheHelpers.GetFromMemCache<IDictionary<string, string>>(cacheKey, orgId: orgId);

			if (entityNames != null)
			{
				return entityNames;
			}

			return CacheHelpers.AddToMemCache(cacheKey,
				GetEntities(service, orgId, EntityAttribute.LogicalName, EntityAttribute.DisplayName)
					.Where(e => e.DisplayName?.UserLocalizedLabel?.Label != null)
					.OrderBy(e => e.LogicalName)
					.ToDictionary(e => e.LogicalName, e => e.DisplayName?.UserLocalizedLabel?.Label),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
		}

		/// <summary>
		///     Get the given properties of all entities.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IReadOnlyList<EntityMetadata> GetEntities(IOrganizationService service, Guid? orgId = null,
			params EntityAttribute[] attributes)
		{
			return GetEntities(service, orgId, attributes.Select(attribute => attribute.ToString()).ToArray());
		}

		/// <summary>
		///     Get the names of all entities.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IReadOnlyList<EntityMetadata> GetEntities(IOrganizationService service, Guid? orgId = null, params string[] attributes)
		{
			var cacheKey = $"Yagasoft.Common.GetEntities|{attributes.Aggregate("", (a1, a2) => a1 + "," + a2)}";
			var entities = CacheHelpers.GetFromMemCache<IReadOnlyList<EntityMetadata>>(cacheKey, orgId: orgId);

			if (entities != null)
			{
				return entities;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};

			if (attributes?.Any() == true)
			{
				entityProperties.PropertyNames.AddRange(attributes);
			}

			var logicalNameString = EntityAttribute.LogicalName.ToString();

			if (attributes?.Contains(logicalNameString) != true)
			{
				entityProperties.PropertyNames.Add(logicalNameString);
			}

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Properties = entityProperties
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			return CacheHelpers.AddToMemCache(cacheKey,
				((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest)).EntityMetadata
					.Where(entity =>
					{
						if (entity.LogicalName == null)
						{
							return false;
						}

						return !nonStandard.Contains(entity.LogicalName);
					}).ToArray(),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
		}

		/// <summary>
		///     Get the entity meta data from the metadata cache.<br />
		///     Includes: LogicalName, DisplayName, PrimaryIdAttribute, PrimaryNameAttribute, Keys,
		///     Attributes, OneToManyRelationships, ManyToOneRelationships, ManyToManyRelationships<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static EntityMetadata GetEntity(IOrganizationService service, string logicalName, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.GetEntity|{logicalName}";
			var entity = CacheHelpers.GetFromMemCache<EntityMetadata>(cacheKey, orgId: orgId);

			if (entity != null)
			{
				return entity;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.AddRange("LogicalName", "DisplayName", "PrimaryIdAttribute", "PrimaryNameAttribute",
				"Keys", "Attributes", "OneToManyRelationships", "ManyToOneRelationships", "ManyToManyRelationships");

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions
				.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, logicalName));

			var attributeProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			attributeProperties.PropertyNames.AddRange("LogicalName", "DisplayName");

			var attributeFilter = new MetadataFilterExpression(LogicalOperator.And);
			attributeFilter.Conditions
				.Add(new MetadataConditionExpression("AttributeOf", MetadataConditionOperator.Equals, null));

			var keyProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			keyProperties.PropertyNames.AddRange("KeyAttributes");

			var relationProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			relationProperties.PropertyNames.AddRange("SchemaName",
				"ReferencedEntity", "ReferencedAttribute", "ReferencingEntity", "ReferencingAttribute",
				"IntersectEntityName", "Entity1LogicalName", "Entity1IntersectAttribute",
				"Entity2LogicalName", "Entity2IntersectAttribute");

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties,
					AttributeQuery =
						new AttributeQueryExpression
						{
							Properties = attributeProperties,
							Criteria = attributeFilter
						},
					KeyQuery =
						new EntityKeyQueryExpression
						{
							Properties = keyProperties
						},
					RelationshipQuery =
						new RelationshipQueryExpression
						{
							Properties = relationProperties
						}
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			return CacheHelpers.AddToMemCache(cacheKey,
				((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
					.EntityMetadata?.FirstOrDefault(),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
		}

		/// <summary>
		///     Checks whether the entity exists in the metadata cache.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsEntityExist(IOrganizationService service, string logicalName, Guid? orgId = null, bool isNoCache = false)
		{
			var cacheKey = $"Yagasoft.Common.IsEntityExist|{logicalName}";
			var isExist = CacheHelpers.GetFromMemCache<bool?>(cacheKey, orgId: orgId);

			if (isExist.HasValue)
			{
				return isExist.Value;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.Add("LogicalName");

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions
				.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, logicalName));

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			var result = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
				.EntityMetadata?.Any() == true;

			return isNoCache
				? result
				: CacheHelpers.AddToMemCache(cacheKey, result,
					CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
		}

		/// <summary>
		///     Get the value of an entity attribute from the metadata.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static T GetEntityAttribute<T>(IOrganizationService service, string entityName,
			EntityAttribute attribute, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.GetEntityAttribute|{entityName}|{attribute}";
			var attributeCached = CacheHelpers.GetFromMemCache<T>(cacheKey, orgId: orgId);

			if (attributeCached != null)
			{
				return attributeCached;
			}

			var entityProperties = new MetadataPropertiesExpression
			{
				AllProperties = false
			};
			entityProperties.PropertyNames.AddRange(attribute.ToString());

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions.Add(
				new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals,
					entityName));

			var entityQueryExpression = new EntityQueryExpression
			{
				Criteria = entityFilter,
				Properties = entityProperties
			};

			var retrieveMetadataChangesRequest = new RetrieveMetadataChangesRequest
			{
				Query = entityQueryExpression,
				ClientVersionStamp = null
			};

			var metadata = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
				.EntityMetadata?.FirstOrDefault();
			return CacheHelpers.AddToMemCache(cacheKey,
				(T)metadata?.GetType().GetProperty(attribute.ToString())?.GetValue(metadata),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
		}

		/// <summary>
		///     Get the value of a list of entity attributes from the metadata.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static EntityMetadata GetEntityAttributes(IOrganizationService service, string entityName,
			Guid? orgId = null, params EntityAttribute[] attributes)
		{
			var cacheKey = $"Yagasoft.Common.GetEntityAttributes|{entityName}|"
				+ $"{attributes.Select(a => a.ToString()).Aggregate<string>((a1, a2) => a1 + "," + a2)}";
			var attributesCached = CacheHelpers.GetFromMemCache<EntityMetadata>(cacheKey, orgId: orgId);

			if (attributesCached != null)
			{
				return attributesCached;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.AddRange(attributes.Select(a => a.ToString()));

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions
				.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entityName));

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			return CacheHelpers.AddToMemCache(cacheKey,
				((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
					.EntityMetadata?.FirstOrDefault(),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
		}

		/// <summary>
		///     Gets the logical name using the entity's object type code.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetEntityNameUsingTypeCode(IOrganizationService service, int typeCode, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.GetEntityNameUsingTypeCode|{typeCode}";
			var entityName = CacheHelpers.GetFromMemCache<string>(cacheKey, orgId: orgId);

			if (entityName != null)
			{
				return entityName;
			}

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions.Add(new MetadataConditionExpression("ObjectTypeCode",
				MetadataConditionOperator.Equals, typeCode));

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.AddRange("LogicalName");

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			return CacheHelpers.AddToMemCache(cacheKey,
				((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
					.EntityMetadata?.FirstOrDefault()?.LogicalName,
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
		}

		/// <summary>
		///     Gets the entity's object type code using its logical name.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static int GetTypeCodeUsingEntityName(IOrganizationService service, string entityName,
			Guid? orgId = null)
		{
			return GetEntityAttribute<int?>(service, entityName, EntityAttribute.ObjectTypeCode, orgId) ?? 0;
		}

		/// <summary>
		///     Get the value of a field attribute from the metadata.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static T GetFieldAttribute<T>(IOrganizationService service, string entityName, string fieldName,
			FieldAttribute attribute, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.GetFieldAttribute|{entityName}|{fieldName}|{attribute}";
			var attributeCached = CacheHelpers.GetFromMemCache<T>(cacheKey, orgId: orgId);

			if (attributeCached != null)
			{
				return attributeCached;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.AddRange("Attributes");

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions.Add(
				new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entityName));

			var attributeFilter = new MetadataFilterExpression(LogicalOperator.And);
			attributeFilter.Conditions
				.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, fieldName));

			var attributeProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			attributeProperties.PropertyNames.AddRange(attribute.ToString());

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties,
					AttributeQuery =
						new AttributeQueryExpression
						{
							Properties = attributeProperties,
							Criteria = attributeFilter
						}
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			var metadata = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
				.EntityMetadata?.FirstOrDefault();

			AttributeMetadata fieldmetadata = null;

			if (metadata != null)
			{
				fieldmetadata = metadata.Attributes?.FirstOrDefault();
			}

			return CacheHelpers.AddToMemCache(cacheKey,
				(T)fieldmetadata?.GetType().GetProperty(attribute.ToString())?.GetValue(fieldmetadata),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
		}

		/// <summary>
		///     Get the properties of all relations of a given type in an the entity from the metadata cache.<br />
		///     Includes: "SchemaName", "ReferencedEntity", "ReferencedAttribute", "ReferencingEntity",
		///     "ReferencingAttribute", "IntersectEntityName", "Entity1LogicalName", "Entity1IntersectAttribute",
		///     "Entity2LogicalName", "Entity2IntersectAttribute"<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IEnumerable<RelationMetadata> GetEntityRelations(IOrganizationService service, string entityName,
			RelationType? type, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.GetEntityRelations|{entityName}|{type}";
			var metadata = CacheHelpers.GetFromMemCache<EntityMetadata>(cacheKey, orgId: orgId);

			if (metadata == null)
			{
				var entityProperties =
					new MetadataPropertiesExpression
					{
						AllProperties = false
					};

				if (type == null)
				{
					entityProperties.PropertyNames.AddRange(Enum.GetNames(typeof(RelationType)));
				}
				else
				{
					entityProperties.PropertyNames.Add(type.ToString());
				}

				var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
				entityFilter.Conditions
					.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entityName));

				var relationProperties =
					new MetadataPropertiesExpression
					{
						AllProperties = false
					};
				relationProperties.PropertyNames.AddRange("SchemaName",
					"ReferencedEntity", "ReferencedAttribute", "ReferencingEntity", "ReferencingAttribute",
					"IntersectEntityName", "Entity1LogicalName", "Entity1IntersectAttribute",
					"Entity2LogicalName", "Entity2IntersectAttribute");

				var entityQueryExpression =
					new EntityQueryExpression
					{
						Criteria = entityFilter,
						Properties = entityProperties,
						RelationshipQuery =
							new RelationshipQueryExpression
							{
								Properties = relationProperties,
							}
					};

				var retrieveMetadataChangesRequest =
					new RetrieveMetadataChangesRequest
					{
						Query = entityQueryExpression,
						ClientVersionStamp = null
					};

				metadata = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
					.EntityMetadata?.FirstOrDefault();

				if (metadata == null)
				{
					return new RelationMetadata[0];
				}

				CacheHelpers.AddToMemCache(cacheKey, metadata, CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
			}

			return BuildRelationMetadata(metadata);
		}

		/// <summary>
		///     Get the properties of the relation from the metadata cache.<br />
		///     Includes: "SchemaName", "ReferencedEntity", "ReferencedAttribute", "ReferencingEntity",
		///     "ReferencingAttribute", "IntersectEntityName", "Entity1LogicalName", "Entity1IntersectAttribute",
		///     "Entity2LogicalName", "Entity2IntersectAttribute"<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static RelationMetadata GetRelation(IOrganizationService service, string entityName, string relationName,
			Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.GetRelation|{entityName}|{relationName}";
			var metadata = CacheHelpers.GetFromMemCache<EntityMetadata>(cacheKey, orgId: orgId);

			if (metadata == null)
			{
				var entityProperties =
					new MetadataPropertiesExpression
					{
						AllProperties = false
					};
				entityProperties.PropertyNames.AddRange(Enum.GetNames(typeof(MetadataHelpers.RelationType)));

				var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
				entityFilter.Conditions
					.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entityName));

				var relationFilter = new MetadataFilterExpression(LogicalOperator.And);
				relationFilter.Conditions
					.Add(new MetadataConditionExpression("SchemaName", MetadataConditionOperator.Equals, relationName));

				var relationProperties =
					new MetadataPropertiesExpression
					{
						AllProperties = false
					};
				relationProperties.PropertyNames.AddRange("SchemaName",
					"ReferencedEntity", "ReferencedAttribute", "ReferencingEntity", "ReferencingAttribute",
					"IntersectEntityName", "Entity1LogicalName", "Entity1IntersectAttribute",
					"Entity2LogicalName", "Entity2IntersectAttribute");

				var entityQueryExpression =
					new EntityQueryExpression
					{
						Criteria = entityFilter,
						Properties = entityProperties,
						RelationshipQuery =
							new RelationshipQueryExpression
							{
								Properties = relationProperties,
								Criteria = relationFilter
							}
					};

				var retrieveMetadataChangesRequest =
					new RetrieveMetadataChangesRequest
					{
						Query = entityQueryExpression,
						ClientVersionStamp = null
					};

				metadata = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
					.EntityMetadata?.FirstOrDefault();

				if (metadata == null)
				{
					return null;
				}

				CacheHelpers.AddToMemCache(cacheKey, metadata, CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
			}

			return BuildRelationMetadata(metadata).FirstOrDefault();
		}

		/// <summary>
		///     Get the value of a relation attribute from the metadata cache.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static T GetRelationAttribute<T>(IOrganizationService service, string entityName, string relationName,
			RelationType type, RelationAttribute attribute, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.GetRelationAttribute|{entityName}|{relationName}|{type}|{attribute}";
			var attributeCached = CacheHelpers.GetFromMemCache<T>(cacheKey, orgId: orgId);

			if (attributeCached != null)
			{
				return attributeCached;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.Add(type.ToString());

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions
				.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entityName));

			var relationFilter = new MetadataFilterExpression(LogicalOperator.And);
			relationFilter.Conditions
				.Add(new MetadataConditionExpression("SchemaName", MetadataConditionOperator.Equals, relationName));

			var relationProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			relationProperties.PropertyNames.AddRange(attribute.ToString());

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties,
					RelationshipQuery =
						new RelationshipQueryExpression
						{
							Properties = relationProperties,
							Criteria = relationFilter
						}
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			var metadata = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
				.EntityMetadata?.FirstOrDefault();

			if (metadata == null)
			{
				return default(T);
			}

			RelationshipMetadataBase relationMetadata = null;

			if (metadata.OneToManyRelationships != null)
			{
				relationMetadata = metadata.OneToManyRelationships.FirstOrDefault();
			}

			if (metadata.ManyToOneRelationships != null)
			{
				relationMetadata = metadata.ManyToOneRelationships.FirstOrDefault();
			}

			if (metadata.ManyToManyRelationships != null)
			{
				relationMetadata = metadata.ManyToManyRelationships.FirstOrDefault();
			}

			return CacheHelpers.AddToMemCache(cacheKey,
				(T)relationMetadata?.GetType().GetProperty(attribute.ToString())?.GetValue(relationMetadata),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static List<RelationshipMetadataBase> GetCustomRelationships(IOrganizationService service,
			string entityName, RelationType[] types, RelationAttribute[] attributes,
			Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.GetCustomRelationships|{entityName}|"
				+ $"{types.Select(t => t.ToString()).Aggregate<string>((t1, t2) => t1 + "," + t2)}"
				+ $"{attributes.Select(a => a.ToString()).Aggregate<string>((a1, a2) => a1 + "," + a2)}";
			var relations = CacheHelpers.GetFromMemCache<List<RelationshipMetadataBase>>(cacheKey, orgId: orgId);

			if (relations != null)
			{
				return relations;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.AddRange(types.Select(type => type.ToString()));

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions.Add(
				new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entityName));

			var relationFilter = new MetadataFilterExpression(LogicalOperator.And);
			relationFilter.Conditions
				.Add(new MetadataConditionExpression("IsCustomRelationship", MetadataConditionOperator.Equals, true));

			var relationProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			relationProperties.PropertyNames.AddRange(attributes.Select(attribute => attribute.ToString()));
			if (!attributes.Contains(MetadataHelpers.RelationAttribute.RelationshipType))
			{
				relationProperties.PropertyNames.AddRange(MetadataHelpers.RelationAttribute.RelationshipType.ToString());
			}

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties,
					RelationshipQuery =
						new RelationshipQueryExpression
						{
							Properties = relationProperties,
							Criteria = relationFilter
						}
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			var metadata = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
				.EntityMetadata?.FirstOrDefault();

			var relationMetadata = new List<RelationshipMetadataBase>();

			if (metadata == null)
			{
				return relationMetadata;
			}

			if (metadata.OneToManyRelationships != null)
			{
				relationMetadata.AddRange(metadata.OneToManyRelationships);
			}

			if (metadata.ManyToOneRelationships != null)
			{
				relationMetadata.AddRange(metadata.ManyToOneRelationships);
			}

			if (metadata.ManyToManyRelationships != null)
			{
				relationMetadata.AddRange(metadata.ManyToManyRelationships);
			}

			return CacheHelpers.AddToMemCache(cacheKey, relationMetadata, CrmHelpers.GetMetadataCacheExpiryDate(service, orgId),
				orgId: orgId);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetOptionSetLabel(IOrganizationService service, string entityName, string fieldName,
			int value, int? language = null, Guid? orgId = null)
		{
			var label = GetFieldAttribute<OptionSetMetadata>(service, entityName, fieldName, FieldAttribute.OptionSet,
				orgId)?.Options.FirstOrDefault(optionQ => optionQ.Value == value)?.Label;

			return language == null
				? label?.UserLocalizedLabel?.Label
				: label?.LocalizedLabels?.Where(l => l.LanguageCode == language).FirstOrDefault()?.Label;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IEnumerable<RelationMetadata> BuildRelationMetadata(EntityMetadata entityMetadata)
		{
			IEnumerable<RelationMetadata> relationMetadata = new RelationMetadata[0];

			if (entityMetadata.OneToManyRelationships?.Length > 0)
			{
				relationMetadata = relationMetadata.Union(entityMetadata.OneToManyRelationships
					.Select(m => BuildRelationMetadata(m, RelationType.OneToManyRelationships))
					.Where(r => r != null));
			}

			if (entityMetadata.ManyToOneRelationships?.Length > 0)
			{
				relationMetadata = relationMetadata.Union(entityMetadata.ManyToOneRelationships
					.Select(m => BuildRelationMetadata(m, RelationType.ManyToOneRelationships))
					.Where(r => r != null));
			}

			if (entityMetadata.ManyToManyRelationships?.Length > 0)
			{
				relationMetadata = relationMetadata.Union(entityMetadata.ManyToManyRelationships
					.Select(m => BuildRelationMetadata(m, RelationType.ManyToManyRelationships))
					.Where(r => r != null));
			}

			return relationMetadata;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static RelationMetadata BuildRelationMetadata(RelationshipMetadataBase relationMetadata, RelationType type)
		{
			if (relationMetadata is OneToManyRelationshipMetadata relation1NTypeSpecific
				&& type == RelationType.OneToManyRelationships)
			{
				return new RelationMetadata
				{
					SchemaName = relation1NTypeSpecific.SchemaName,
					Entity1Name = relation1NTypeSpecific.ReferencedEntity,
					Entity1FieldName = relation1NTypeSpecific.ReferencedAttribute,
					Entity2Name = relation1NTypeSpecific.ReferencingEntity,
					Entity2FieldName = relation1NTypeSpecific.ReferencingAttribute,
					Type = type
				};
			}

			if (relationMetadata is OneToManyRelationshipMetadata relationN1TypeSpecific
				&& type == RelationType.ManyToOneRelationships)
			{
				return new RelationMetadata
				{
					SchemaName = relationN1TypeSpecific.SchemaName,
					Entity1Name = relationN1TypeSpecific.ReferencedEntity,
					Entity1FieldName = relationN1TypeSpecific.ReferencedAttribute,
					Entity2Name = relationN1TypeSpecific.ReferencingEntity,
					Entity2FieldName = relationN1TypeSpecific.ReferencingAttribute,
					Type = type
				};
			}

			if (relationMetadata is ManyToManyRelationshipMetadata relationNnTypeSpecific
				&& type == RelationType.ManyToManyRelationships)
			{
				return new RelationMetadata
				{
					SchemaName = relationNnTypeSpecific.SchemaName,
					Entity1Name = relationNnTypeSpecific.Entity1LogicalName,
					Entity1FieldName = relationNnTypeSpecific.Entity1IntersectAttribute,
					Entity2Name = relationNnTypeSpecific.Entity2LogicalName,
					Entity2FieldName = relationNnTypeSpecific.Entity2IntersectAttribute,
					IntersectingEntityName = relationNnTypeSpecific.IntersectEntityName,
					Type = type
				};
			}

			return null;
		}
	}

	/// <summary>
	///		Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class ErrorHelpers
	{
		public static string BuildExceptionMessage(this Exception ex, string preMessage = null, bool isUseExStackTrace = false,
			int depth = 0)
		{
			if (ex == null || depth > 5)
			{
				return string.Empty;
			}

			depth++;

			var message = (preMessage == null ? string.Empty : preMessage + "\r\n")
				+ "- Exception: " + ex.GetType()
				+ "\r\n- Message: " + ex.Message
				+ (ex.Source == null ? string.Empty : "\r\n- Source: " + ex.Source)
				+ (ex.HelpLink == null ? string.Empty : "\r\n- Help link: " + ex.HelpLink);

			try
			{
				message += (ex.TargetSite == null ? string.Empty : "\r\n- Target site: " + ex.TargetSite);
			}
			catch
			{
				// ignored
			}

			message += $"\r\n- HResult: {ex.HResult}"
				+ (ex.StackTrace == null
					? string.Empty
					: "\r\n- Stack trace:"
						+ "\r\n" + (ex.StackTrace
							?? (isUseExStackTrace
								? string.Empty
								: Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common"))));

			if (ex is System.ServiceModel.FaultException<OrganizationServiceFault> fault
				&& fault.CreateMessageFault().HasDetail)
			{
				message += $"\r\n\r\n--- START ** ORG SRV FAULT ---\r\n"
					+ $"\r\n{fault.Detail.BuildFaultMessage(depth)}"
					+ $"\r\n\r\n--- END ** ORG SRV FAULT ---";
			}

			if (ex.InnerException != null)
			{
				message += $"\r\n\r\n----- START ** INNER EXCEPTION -----\r\n"
					+ $"\r\n{ex.InnerException.BuildExceptionMessage(null, true, depth)}"
					+ $"\r\n\r\n----- END ** INNER EXCEPTION -----";
			}

			return message;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string BuildFaultMessage(this OrganizationServiceFault fault, int depth = 0)
		{
			if (fault == null || depth > 5)
			{
				return string.Empty;
			}

			depth++;

			var message = $"- Error: {fault.Message}"
				+ $"\r\n- Error code: {fault.ErrorCode}"
				+ $"\r\n- Timestamp: {fault.Timestamp}"
				+ $"\r\n- Activity ID: {fault.ActivityId}";

			var text = fault.TraceText;

			if (text.IsFilled())
			{
				message += $"\r\n- Trace text:\r\n{text}";
			}

			if (fault.ErrorDetails?.Any() == true)
			{
				message = fault.ErrorDetails.Aggregate($"{message}\r\n- Error details:",
					(current, errorDetail) =>
						current + $"\r\n({errorDetail.Key}, {errorDetail.Value})");
			}

			if (fault.InnerFault != null)
			{
				message += $"\r\n\r\n--- INNER ORG SRV FAULT ---\r\n"
					+ $"\r\n{fault.InnerFault.BuildFaultMessage(depth)}";
			}

			return message;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string BuildShortExceptionMessage(this Exception ex, int depth = 0)
		{
			if (ex == null || depth > 5)
			{
				return string.Empty;
			}

			depth++;

			var message = "Exception: " + ex.GetType()
				+ " | Message: " + ex.Message
				+ (ex.Source == null ? string.Empty : " | Source: " + ex.Source);

			try
			{
				message += (ex.TargetSite == null ? string.Empty : " | Target site: " + ex.TargetSite);
			}
			catch
			{
				// ignored
			}

			message += $" | HResult: {ex.HResult}";

			if (ex is System.ServiceModel.FaultException<OrganizationServiceFault> fault
				&& fault.CreateMessageFault().HasDetail)
			{
				message += $" |> SRV FAULT: {fault.Detail.BuildShortFaultMessage(depth)} <|";
			}

			if (ex.InnerException != null)
			{
				message += $" |>> {ex.InnerException.BuildExceptionMessage(null, true, depth)} <<|";
			}

			return message;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string BuildShortFaultMessage(this OrganizationServiceFault fault, int depth = 0)
		{
			if (fault == null || depth > 5)
			{
				return string.Empty;
			}

			depth++;

			var message = $"Error: {fault.Message}"
				+ $" | Error code: {fault.ErrorCode}"
				+ $" | Timestamp: {fault.Timestamp}"
				+ $" | Activity ID: {fault.ActivityId}";

			var text = fault.TraceText;

			if (fault.ErrorDetails?.Any() == true)
			{
				message = fault.ErrorDetails.Aggregate($"{message} | Error details:",
					(current, errorDetail) =>
						current + $" ({errorDetail.Key}, {errorDetail.Value})");
			}

			if (fault.InnerFault != null)
			{
				message += $" |> INNER SRV FAULT: {fault.InnerFault.BuildFaultMessage(depth)} <|";
			}

			return message;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string ExtractErrorCode(this string message)
		{
			var code = new Regex(@"0x\d*").Match(message).Value;
			return code.IsHexErrorCode() ? code : null;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsHexErrorCode(this string code)
		{
			return new Regex(@"^0x\d*$").IsMatch(code);
		}
	}

	/// <summary>
	///     credit: http://stackoverflow.com/a/961904/1919456 <br />
	///     Credit: http://stackoverflow.com/questions/19049514/strategy-for-logging-in-production-for-dynamics-crm-plugins
	///     <br />
	///		Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class PluginInfo
	{
		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetPluginExecutionInfo(IExecutionContext context, IOrganizationService organizationService = null)
		{
			context.Require(nameof(context), "Plugin execution context is required.");

			var contextTemp = context as IPluginExecutionContext;

			var lines =
				new List<string>
				{
					"MessageName: " + context.MessageName,
					"PrimaryEntityName: " + context.PrimaryEntityName,
					"PrimaryEntityId: " + context.PrimaryEntityId,
					"SecondaryEntityName: " + context.SecondaryEntityName,
					"BusinessUnitId: " + context.BusinessUnitId,
					"CorrelationId: " + context.CorrelationId,
					"Depth: " + context.Depth,
					"InitiatingUserId: " + context.InitiatingUserId,
					"UserId: " + context.UserId,
					"IsInTransaction: " + context.IsInTransaction,
					"IsolationMode: " + context.IsolationMode,
					"Mode: " + context.Mode,
					"OperationCreatedOn: " + context.OperationCreatedOn,
					"OperationId: " + context.OperationId,
					"Organization: " + context.OrganizationName + " (" + context.OrganizationId + ")"
				};


			if (contextTemp != null)
			{
				lines.Add("Stage: " + contextTemp.Stage);
			}

			AddEntityReference(lines, context.OwningExtension, "OwningExtension");
			
			ParameterCollection inputParams = null;

			try
			{
				inputParams = context.InputParameters;
			}
			catch
			{
				// ignored
			}

			if (inputParams != null)
			{
				AddParameters(lines, inputParams, "Input Parameters", organizationService);
			}

			AddParameters(lines, context.OutputParameters, "Output Parameters", organizationService);
			AddParameters(lines, context.SharedVariables, "Shared Variables", organizationService);
			AddEntityImages(lines, context.PostEntityImages, "Post Entity Images", organizationService);
			AddEntityImages(lines, context.PreEntityImages, "Pre Entity Images", organizationService);

			if (contextTemp != null)
			{
				lines.Add("Has Parent Context: " + (contextTemp.ParentContext != null));

				if (contextTemp.ParentContext != null)
				{
					lines.Add("-- Parent Context --");
					lines.Add(GetPluginExecutionInfo(contextTemp.ParentContext, organizationService));
				}
			}

			return string.Join(Environment.NewLine, lines);
		}

		private static void AddEntity(List<string> nameValuePairs, Entity entity, string name, IOrganizationService service = null)
		{
			if (entity != null)
			{
				nameValuePairs.Add($"** {name} **");
				nameValuePairs.AddRange(entity.Attributes
					.Select(att =>
						"    Entity[" + att.Key + "]: " +
							GetAttributeValue(entity.LogicalName, att.Key, att.Value, service)));
			}
			else
			{
				nameValuePairs.Add(name + ": Empty");
			}
		}

		private static string GetAttributeValue(string logicalName, string key, object value,
			IOrganizationService organizationService = null)
		{
			if (value == null)
			{
				return "Null";
			}

			var type = value.GetType();

			if (type == typeof(OptionSetValue) && organizationService != null && logicalName.IsFilled() && key.IsFilled())
			{
				var retrieveOptionSetRequest =
					new RetrieveAttributeRequest
					{
						EntityLogicalName = logicalName,
						LogicalName = key,
						RetrieveAsIfPublished = true
					};

				var response = (RetrieveAttributeResponse)organizationService.Execute(retrieveOptionSetRequest);

				var metadata = response.AttributeMetadata as EnumAttributeMetadata;

				if (metadata != null)
				{
					var valueTemp = ((OptionSetValue)value).Value;
					return valueTemp + " (" +
						metadata.OptionSet.Options
							.FirstOrDefault(option => option.Value == valueTemp)?
							.Label.UserLocalizedLabel?.Label + ")";
				}
			}

			if (type == typeof(EntityReference))
			{
				var reference = (EntityReference)value;

				if (reference.LogicalName == null)
				{
					return value.ToString();
				}

				if (organizationService != null)
				{
					var primaryAttribute = ((RetrieveEntityResponse)organizationService
						.Execute(
							new RetrieveEntityRequest
							{
								EntityFilters = EntityFilters.Entity,
								LogicalName = reference.LogicalName
							})).EntityMetadata.PrimaryNameAttribute;

					return reference.Id + " (" +
						organizationService.Retrieve(reference.LogicalName, reference.Id, new ColumnSet(primaryAttribute))
							.GetAttributeValue<string>(primaryAttribute) + ")";
				}
			}

			return Helpers.GetStringRepresentation(value);
		}

		private static void AddEntityReference(ICollection<string> nameValuePairs, EntityReference entity, string name)
		{
			if (entity != null)
			{
				nameValuePairs.Add(name + ": " + entity.Name);
			}
		}

		private static void AddEntityImages(List<string> nameValuePairs, EntityImageCollection images,
			string name, IOrganizationService organizationService = null)
		{
			if (images != null && images.Count > 0)
			{
				nameValuePairs.Add("** " + name + " **");

				foreach (var image in images)
				{
					if (image.Value == null || image.Value.Attributes.Count == 0)
					{
						if (image.Value != null)
						{
							nameValuePairs.Add("    Image[" + image.Key + "] " + image.Value.ToEntityReference().Name + ": Empty");
						}
					}
					else
					{
						nameValuePairs.Add("*   Image[" + image.Key + "] " + image.Value.ToEntityReference().Name + "   *");
						nameValuePairs.AddRange(image.Value.Attributes
							.Select(att =>
								"        Entity[" + att.Key + "]: " +
									GetAttributeValue(image.Value.ToEntityReference().LogicalName, att.Key, att.Value,
										organizationService)));
					}
				}
			}
			else
			{
				nameValuePairs.Add(name + ": Empty");
			}
		}

		private static void AddParameters(List<string> nameValuePairs, ParameterCollection parameters,
			string name, IOrganizationService service = null)
		{
			if (parameters != null && parameters.Count > 0)
			{
				nameValuePairs.Add("* " + name + " *");
				nameValuePairs.AddRange(parameters
					.Where(param => !(param.Value is Entity))
					.Select(param => "    Param[" + param.Key + "]: " + Helpers.GetStringRepresentation(param.Value)));

				foreach (var kv in parameters
					.Where(param => param.Value is Entity))
				{
					var entity = (Entity)kv.Value;
					AddEntity(nameValuePairs, entity, $"{kv.Key} {entity.ToEntityReference().Name}", service);
				}
			}
			else
			{
				nameValuePairs.Add(name + ": Empty");
			}
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static partial class BpfHelpers
	{
		/// <summary>
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		///     Returns all stages in the process, in order, with their names.<br />
		/// </summary>
		/// <param name="service">The service.</param>
		/// <param name="processId">The process identifier.</param>
		public static List<BpfStageInfo> GetStages(IOrganizationService service, Guid processId, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.GetStages|{processId}";
			var process = CacheHelpers.GetFromMemCache<Entity>(cacheKey, orgId: orgId)
				?? CacheHelpers.AddToMemCache(cacheKey,
					service.Retrieve("workflow", processId, new ColumnSet("xaml")),
					CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);

			if (!process.Contains("xaml"))
			{
				return null;
			}

			var doc = new XmlDocument();
			doc.LoadXml((string)process["xaml"]);

			var stepNodes = doc.SelectNodes("//*[local-name()='Workflow']/*[local-name()='ActivityReference']" +
				"/*[local-name()='ActivityReference.Properties']/*[local-name()='Collection']" +
				"/*[local-name()='ActivityReference']/*[local-name()='ActivityReference.Properties']");

			var stages = new List<BpfStageInfo>();

			if (stepNodes == null || stepNodes.Count <= 0)
			{
				return null;
			}

			for (var i = 0; i < stepNodes.Count; i++)
			{
				var idText = stepNodes[i].SelectSingleNode("*[local-name()='String' and @*[local-name()='Key']='StageId']");
				var id = idText?.InnerText;
				var labelNode =
					stepNodes[i].SelectSingleNode("*[local-name()='Collection']/*[local-name()='StepLabel']/@Description");
				var label = labelNode?.InnerText;

				if (id != null)
				{
					stages.Add(
						new BpfStageInfo
						{
							Id = Guid.Parse(id),
							Name = label,
							Index = i
						});
				}
			}

			return stages.Any() ? stages : null;
		}

		/// <summary>
		///     Fetches the BPF entity's record related to the given record as raw Entity object.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="service">CRM service.</param>
		/// <param name="record">Target record with the process set.</param>
		/// <param name="processId">The process.</param>
		/// <param name="isIncludeStage">Include the current Stage ID and Traversed Path in the retrieved info.</param>
		/// <param name="primaryEntityPrefix">
		///     Prefix of the Primary Entity ID attribute.
		///     Default: "bpf", and for OoB Entities it's empty.
		/// </param>
		public static BpfRecord GetBpfRecord(IOrganizationService service, EntityReference record, Guid processId,
			bool isIncludeStage = false, string primaryEntityPrefix = "bpf", Guid? orgId = null)
		{
			var processRecord = GetBpfRecordRaw(service, record, processId, isIncludeStage, primaryEntityPrefix, orgId);

			return
				new BpfRecord
				{
					LogicalName = processRecord.LogicalName,
					Id = processRecord.GetAttributeValue<Guid>("businessprocessflowinstanceid"),
					ProcessId = processRecord.GetAttributeValue<EntityReference>("processid").Id,
					StageId = processRecord.GetAttributeValue<EntityReference>("activestageid") == null
						? (Guid?)null
						: processRecord.GetAttributeValue<EntityReference>("activestageid").Id,
					TraversedPath = processRecord.GetAttributeValue<string>("traversedpath")
				};
		}

		/// <summary>
		///     Fetches the BPF entity's record related to the given record as raw Entity object.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="service">CRM service.</param>
		/// <param name="record">Target record with the process set.</param>
		/// <param name="processId">The process.</param>
		/// <param name="isIncludeStage">Include the current Stage ID and Traversed Path in the retrieved info.</param>
		/// <param name="primaryEntityPrefix">
		///     Prefix of the Primary Entity ID attribute.
		///     Default: "bpf", and for OoB Entities it's empty.
		/// </param>
		public static Entity GetBpfRecordRaw(IOrganizationService service, EntityReference record, Guid processId,
			bool isIncludeStage = false, string primaryEntityPrefix = "bpf", Guid? orgId = null)
		{
			var cacheKeyRecordName = $"Yagasoft.Common.GetBpfRecordRaw|{record.Id}|{processId}|processRecordName";
			var processRecordName = CacheHelpers.GetFromMemCache<string>(cacheKeyRecordName, orgId: orgId);

			var cacheKeyRecord = $"Yagasoft.Common.GetBpfRecordRaw|{record.Id}|{processId}|processRecord";
			var processRecord = CacheHelpers.GetFromMemCache<Entity>(cacheKeyRecord, orgId: orgId);

			if (!isIncludeStage && processRecord != null)
			{
				return processRecord;
			}

			using (var context = new OrganizationServiceContext(service) { MergeOption = MergeOption.NoTracking })
			{
				if (processRecordName == null)
				{
					// can't figure out the process record name except from the process's name in the DB
					processRecordName = CacheHelpers.AddToMemCache(cacheKeyRecordName,
						(from process in context.CreateQuery("workflow")
						 where (Guid)process["workflowid"] == processId
						 select (string)process["uniquename"]).FirstOrDefault(),
						CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);

					if (processRecordName == null)
					{
						throw new Exception($"Could not get the entity name of process: {processId}.");
					}
				}

				// get the special entity's record for this process and given target record
				processRecord =
					(from processRecordQ in context.CreateQuery(processRecordName)
					 where processRecordQ["processid"] == (object)processId
						 && processRecordQ[$"{(primaryEntityPrefix.IsFilled() ? $"{primaryEntityPrefix}_" : "")}{record.LogicalName}id"]
							 == (object)record.Id
					 select processRecordQ).FirstOrDefault();

				if (isIncludeStage)
				{
					return processRecord;
				}

				return CacheHelpers.AddToMemCache(cacheKeyRecord, processRecord,
					CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
			}
		}

		/// <summary>
		///     Returns the BPF Instance records. Logical Name of the Process Entity, and the Traversed Path are excluded.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IEnumerable<BpfRecord> GetBpfInstances(IOrganizationService service, EntityReference record, bool isIncludeStage = false,
			Guid? orgId = null)
		{
			return GetBpfInstancesRaw(service, record, isIncludeStage, orgId)?
				.Select(
					e =>
						new BpfRecord
						{
							Id = e.Id,
							ProcessId = e.GetAttributeValue<EntityReference>("processid")?.Id,
							StageId = e.GetAttributeValue<Guid?>("processstageid")
						});
		}

		/// <summary>
		///     Returns the BPF Instance records as raw Entity objects.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IReadOnlyList<Entity> GetBpfInstancesRaw(IOrganizationService service, EntityReference record, bool isIncludeStage = false,
			Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.GetBpfInstancesRaw|{record.Id}";
			var instances = CacheHelpers.GetFromMemCache<IReadOnlyList<Entity>>(cacheKey, orgId: orgId);

			if (!isIncludeStage && instances != null)
			{
				return instances;
			}

			instances =
				((RetrieveProcessInstancesResponse)service.Execute(
					new RetrieveProcessInstancesRequest
					{
						EntityId = record.Id,
						EntityLogicalName = record.LogicalName
					})).Processes?.Entities;

			if (isIncludeStage)
			{
				return instances;
			}

			return CacheHelpers.AddToMemCache(cacheKey, instances,
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
		}

		/// <summary>
		///     Returns the BPF Instance record of the given Process. The Traversed Path is excluded.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static BpfRecord GetBpfInstance(IOrganizationService service, EntityReference record, string processLogicalName,
			Guid processId, bool isIncludeStage = false, Guid? orgId = null)
		{
			var instance = GetBpfInstances(service, record, isIncludeStage, orgId)?
				.FirstOrDefault(e => e.ProcessId == processId);

			if (instance != null)
			{
				instance.LogicalName = processLogicalName;
			}

			return instance;
		}

		/// <summary>
		///     Returns the BPF Instance record of the given Process as raw Entity object.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static Entity GetBpfInstanceRaw(IOrganizationService service, EntityReference record,
			Guid processId, bool isIncludeStage = false, Guid? orgId = null)
		{
			return GetBpfInstancesRaw(service, record, isIncludeStage, orgId)
				.FirstOrDefault(e => e.GetAttributeValue<EntityReference>("processid")?.Id == processId);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static Guid? GetActiveProcessId(IOrganizationService service, EntityReference record, Guid? orgId = null)
		{
			return GetBpfInstances(service, record, false, orgId).FirstOrDefault()?.ProcessId;
		}

		public static Guid? GetActiveStageId(IOrganizationService service, EntityReference record, Guid? orgId = null)
		{
			return GetBpfInstances(service, record, true, orgId).FirstOrDefault()?.StageId;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static BpfStageRecord GetActiveStage(IOrganizationService service, EntityReference record, Guid? processId, string primaryEntityPrefix = "bpf",
			Guid? orgId = null)
		{
			service.Require(nameof(service));
			record.Require(nameof(record));
			processId.Require(nameof(processId));

			var bpfRecord = GetBpfRecordRaw(service, record, processId.GetValueOrDefault(), true, primaryEntityPrefix, orgId);
			var stageId = bpfRecord.GetAttributeValue<EntityReference>("activestageid")?.Id;
			stageId.Require(nameof(stageId), $"Unable to find Stage ID in Process ({processId}) record ({bpfRecord.Id})"
				+ $" for record ({record.LogicalName}|{record.Id}).");
			var activePath = GetActivePathRaw(service, bpfRecord.Id);
			var stage = activePath.FirstOrDefault(e => e.Id == stageId);
			stage.Require(nameof(stage), $"Unable to find Stage ({stageId}) info in Active Path of Process ({processId})"
				+ $" for record ({record.LogicalName}|{record.Id}).");
			var stageEntityName = stage?.GetAttributeValue<string>("primaryentitytypecode");
			var stageEntityRef = bpfRecord.GetAttributeValue<EntityReference>(
				$"{(primaryEntityPrefix.IsFilled() ? $"{primaryEntityPrefix}_" : "")}{stageEntityName}id");

			return
				new BpfStageRecord
				{
					Id = stageId.GetValueOrDefault(),
					StageRecord = stageEntityRef,
					ActivePath = activePath.Select(s => s.Id.ToString().ToLower()).StringAggregate(),
					TraversedPath = bpfRecord.GetAttributeValue<string>("traversedpath")
				};
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void MoveStage(IOrganizationService service, EntityReference record, string processLogicalName, Guid processId, bool moveBackwards = false,
			EntityReference stageRecordRef = null, string stageRecordLookupName = null, Guid? orgId = null)
		{
			service.Require(nameof(service));
			record.Require(nameof(record));
			processLogicalName.RequireNotEmpty(nameof(processLogicalName));

			var instance = GetBpfInstance(service, record, processLogicalName, processId, false, orgId);

			if (instance == null)
			{
				throw new Exception($"Can't find the BPF instance for process: {processId}.");
			}

			var activePath = GetActivePath(service, instance.Id).ToArray();

			Guid? targetStage = null;

			for (var i = 0; i < activePath.Length; i++)
			{
				if (activePath[i] != instance.StageId)
				{
					continue;
				}

				if (moveBackwards)
				{
					if (i <= 0)
					{
						throw new Exception("Can't move backwards from first stage in the process.");
					}

					targetStage = activePath[i - 1];
				}
				else
				{
					if (i >= activePath.Length - 1)
					{
						throw new Exception("Can't move forwards from last stage in the process.");
					}

					targetStage = activePath[i + 1];
				}

				break;
			}

			if (targetStage == null)
			{
				throw new Exception($"Can't find a stage to move to. Process: '{processId}', backwards: {moveBackwards}.");
			}

			var traversedPath = BuildTraversedPath(targetStage.Value, activePath);
			MoveToStage(service, record, targetStage.Value, instance, traversedPath, traversedPath, stageRecordRef, stageRecordLookupName, orgId);
		}

		/// <summary>
		///     Moves the process to the given stage.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="service">CRM service.</param>
		/// <param name="record">The target record to set the Stage in.</param>
		/// <param name="processLogicalName">The Logical Name of the BPF Entity.</param>
		/// <param name="processId">The process that includes the Stage.</param>
		/// <param name="stageId">The Stage.</param>
		/// <param name="stageRecordRef">The Stage record if multi-entity BPF.</param>
		/// <param name="stageRecordLookupName">The name of the Lookup in the Stage record Entity pointing to the main Entity.</param>
		public static void MoveToStage(IOrganizationService service, EntityReference record, string processLogicalName, Guid processId, Guid stageId,
			EntityReference stageRecordRef = null, string stageRecordLookupName = null, Guid? orgId = null)
		{
			service.Require(nameof(service));
			record.Require(nameof(record));
			processLogicalName.RequireNotEmpty(nameof(processLogicalName));

			var instance = GetBpfInstance(service, record, processLogicalName, processId, true, orgId);

			// first time the record is going to this process, so invoke a change so that CRM creates a BPF record first
			if (instance == null)
			{
				service.Update(
					new Entity(record.LogicalName, record.Id)
					{
						["processid"] = processId,
						["stageid"] = stageId
					});
				instance = GetBpfInstance(service, record, processLogicalName, processId, true, orgId);

				if (instance == null)
				{
					throw new Exception($"Can't find the BPF instance for Process: {processId}, for record: {record.Id}|{record.LogicalName}.");
				}
			}

			if (instance.StageId == null)
			{
				throw new Exception($"Can't find Active Stage ID in BPF record: {instance.Id},"
					+ $" for Process: {processId}, for record: {record.Id}|{record.LogicalName}.");
			}

			if (instance.StageId == stageId)
			{
				return;
			}

			if (instance == null)
			{
				throw new Exception($"Can't find the BPF instance for BPF record: {instance.Id},"
					+ $" for process: {processId}, for record: {record.Id}|{record.LogicalName}.");
			}

			var activePath = GetActivePath(service, instance.Id).ToArray();
			var oldTraversedPath = BuildTraversedPath(instance.StageId.Value, activePath);
			var newTraversedPath = BuildTraversedPath(stageId, activePath);
			MoveToStage(service, record, stageId, instance, oldTraversedPath, newTraversedPath, stageRecordRef, stageRecordLookupName, orgId);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void MoveToStage(IOrganizationService service, EntityReference record, Guid stageId, BpfRecord bpfInstanceRecord,
			string oldTraversedPath, string newTraversedPath, EntityReference stageRecordRef = null, string stageRecordLookupName = null,
			Guid? orgId = null)
		{
			service.Require(nameof(service));
			record.Require(nameof(record));
			bpfInstanceRecord.Require(nameof(bpfInstanceRecord));
			bpfInstanceRecord.ProcessId.Require(nameof(bpfInstanceRecord.ProcessId));
			oldTraversedPath.RequireNotEmpty(nameof(oldTraversedPath));
			newTraversedPath.RequireNotEmpty(nameof(newTraversedPath));

			var oldPathLength = oldTraversedPath.Split(',').Length;
			var newPathLength = newTraversedPath.Split(',').Length;

			//if (Math.Abs(oldPathLength - newPathLength) > 1)
			//{
			//	MoveStage(service, record, bpfInstanceRecord.LogicalName, bpfInstanceRecord.ProcessId.GetValueOrDefault(), orgId,
			//		oldPathLength > newPathLength);
			//}

			var updatedProcessRecord =
				new Entity(bpfInstanceRecord.LogicalName)
				{
					Id = bpfInstanceRecord.Id,
					[$"bpf_{record.LogicalName}id"] = record,
					["activestageid"] = new EntityReference("processstage", stageId)
				};

			if (stageRecordRef != null)
			{
				updatedProcessRecord[$"bpf_{stageRecordRef.LogicalName}id"] = stageRecordRef;

				// before jumping into a stage entity record, it has to be related to the current record first, if not already so
				if (stageRecordLookupName.IsFilled())
				{
					service.Update(
						new Entity(stageRecordRef.LogicalName, stageRecordRef.Id) { [stageRecordLookupName] = record });
				}
			}

			service.Update(updatedProcessRecord);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IEnumerable<Guid> GetActivePath(IOrganizationService service, Guid instanceId)
		{
			return GetActivePathRaw(service, instanceId).Select(s => s.Id);
		}

		public static IReadOnlyList<Entity> GetActivePathRaw(IOrganizationService service, Guid instanceId)
		{
			return
				((RetrieveActivePathResponse)service.Execute(
					new RetrieveActivePathRequest
					{
						ProcessInstanceId = instanceId
					})).ProcessStages.Entities;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string BuildTraversedPath(Guid stageId, IEnumerable<Guid> activePath)
		{
			var path = activePath.TakeWhile(s => s != stageId).Union(new[] { stageId }).Select(s => s.ToString()).StringAggregate();

			return path.IsFilled()
				? path
				: throw new Exception($"Couldn't find target stage '{stageId}' in the active path of the process.");
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static partial class SlaHelpers
	{
		/// <summary>
		///     Get the date by adding duration to the start date within timeslots
		/// Credit: https://www.codeproject.com/Articles/1181377/Calculate-Due-Date-Based-on-the-Customer-Service-C
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="calendarName">Calendar name as it appears in CRM</param>
		/// <param name="startDate">Date to measure from, in UTC</param>
		/// <param name="duration">Duration after the start date in minutes</param>
		/// <param name="service">CRM service</param>
		/// <returns>DateTime after adding the duration to the start date</returns>
		public static DateTime GetDueDate(string calendarName, DateTime startDate, int duration,
			IOrganizationService service, Guid? orgId = null)
		{
			var calendar = RetrieveCalender(calendarName, service, orgId);
			var holidays = RetrieveHolidays(calendar.HolidayRef, service, orgId);
			return ProcessCalendar(startDate, duration, calendar, holidays, service, orgId);
		}

		/// <summary>
		///     Get the date by adding duration to the start date within timeslots
		/// Credit: https://www.codeproject.com/Articles/1181377/Calculate-Due-Date-Based-on-the-Customer-Service-C
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="calendarId">ID of calendar to use</param>
		/// <param name="startDate">Date to measure from, in UTC</param>
		/// <param name="duration">Duration after the start date in minutes</param>
		/// <param name="service">CRM service</param>
		/// <returns>DateTime after adding the duration to the start date</returns>
		public static DateTime GetDueDate(Guid calendarId, DateTime startDate, int duration,
			IOrganizationService service, Guid? orgId = null)
		{
			var calendar = RetrieveCalender(calendarId, service, orgId);
			var holidays = RetrieveHolidays(calendar.HolidayRef, service, orgId);
			return ProcessCalendar(startDate, duration, calendar, holidays, service, orgId);
		}

		/// <summary>
		///     Get the date by adding duration to the start date within timeslots
		/// Credit: https://www.codeproject.com/Articles/1181377/Calculate-Due-Date-Based-on-the-Customer-Service-C
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="calendarName">Calendar name as it appears in CRM</param>
		/// <param name="startDate">Date to measure from, in UTC</param>
		/// <param name="endDate">Date to measure to, in UTC</param>
		/// <param name="service">CRM service</param>
		/// <returns>Duration, in minutes, within the given range</returns>
		public static int GetDuration(string calendarName, DateTime startDate, DateTime endDate,
			IOrganizationService service, Guid? orgId = null)
		{
			var calendar = RetrieveCalender(calendarName, service, orgId);
			var holidays = RetrieveHolidays(calendar.HolidayRef, service, orgId);
			return ProcessCalendar(startDate, endDate, calendar, holidays, service, orgId);
		}

		/// <summary>
		///     Get the date by adding duration to the start date within timeslots
		/// Credit: https://www.codeproject.com/Articles/1181377/Calculate-Due-Date-Based-on-the-Customer-Service-C
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="calendarId">ID of calendar to use</param>
		/// <param name="startDate">Date to measure from, in UTC</param>
		/// <param name="endDate">Date to measure to, in UTC</param>
		/// <param name="service">CRM service</param>
		/// <returns>Duration, in minutes, within the given range</returns>
		public static int GetDuration(Guid calendarId, DateTime startDate, DateTime endDate,
			IOrganizationService service, Guid? orgId = null)
		{
			var calendar = RetrieveCalender(calendarId, service, orgId);
			var holidays = RetrieveHolidays(calendar.HolidayRef, service, orgId);
			return ProcessCalendar(startDate, endDate, calendar, holidays, service, orgId);
		}

		private static CrmCalendar RetrieveCalender(string calendarName, IOrganizationService service, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.RetrieveCalender|{calendarName}";
			var calendars = CacheHelpers.GetFromMemCache<DataCollection<Entity>>(cacheKey, orgId: orgId);

			if (calendars == null)
			{
				var query =
					new QueryExpression("calendar") { ColumnSet = new ColumnSet("holidayschedulecalendarid") };
				query.Criteria.AddCondition("name", ConditionOperator.Equal, calendarName);
				query.NoLock = true;
				calendars = service.RetrieveMultiple(query).Entities;

				CacheHelpers.AddToMemCache(cacheKey, calendars, CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
			}

			return calendars.Select(calendar =>
				new CrmCalendar
				{
					Id = calendar.Id,
					HolidayRef = calendar.GetAttributeValue<EntityReference>("holidayschedulecalendarid")
				}).FirstOrDefault();
		}

		private static CrmCalendar RetrieveCalender(Guid calendarId, IOrganizationService service, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.RetrieveCalender|{calendarId}";
			var calendar = CacheHelpers.GetFromMemCache<Entity>(cacheKey, orgId: orgId);

			if (calendar == null)
			{
				calendar = service.Retrieve("calendar", calendarId, new ColumnSet("holidayschedulecalendarid"));
				CacheHelpers.AddToMemCache(cacheKey, calendar, CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
			}

			return
				new CrmCalendar
				{
					Id = calendar.Id,
					HolidayRef = calendar.GetAttributeValue<EntityReference>("holidayschedulecalendarid")
				};
		}

		private static DateTime ProcessCalendar(DateTime startDate, int duration, CrmCalendar calendar, IEnumerable<Holiday> holidays,
			IOrganizationService service, Guid? orgId = null)
		{
			var holidaysArray = holidays as Holiday[] ?? holidays?.ToArray();

			DateTime? targetDate = null;
			var defaultTarget = DateTime.UtcNow.AddMinutes(duration);
			
			while (targetDate == null)
			{
				var timeSlots = RetrieveCalendarTimeSlots(calendar.Id, service, startDate, null, orgId);
				var availableSlots = GetAvailableTimeSlots(timeSlots, holidaysArray);

				foreach (var slot in availableSlots.Where(s => s.End > startDate))
				{
					var slotStart = slot.Start >= startDate ? slot.Start : startDate;
					var slotEnd = slot.End;
					var slotDuration = (int)((slotEnd - slotStart)?.TotalMinutes).GetValueOrDefault();

					// startDate was at the slot's end, or startDate was after the slot's end
					if (slotDuration <= 0)
					{
						continue;
					}

					if (slotDuration <= duration)
					{
						duration -= slotDuration;
						continue;
					}

					// something is wrong, assign default target date
					targetDate = slotStart?.AddMinutes(duration);
					break;
				}

				// duration > available slots
				if (targetDate == null)
				{
					var slotsEnd = timeSlots.LastOrDefault()?.End;

					// something is wrong, exit
					if (slotsEnd == null)
					{
						targetDate = defaultTarget;
					}
					else
					{
						// get more slots from CRM
						startDate = slotsEnd.Value;
					}
				}
			}

			return targetDate.Value;
		}

		private static int ProcessCalendar(DateTime startDate, DateTime endDate, CrmCalendar calendar, IEnumerable<Holiday> holidays,
			IOrganizationService service, Guid? orgId = null)
		{
			var timeSlots = RetrieveCalendarTimeSlots(calendar.Id, service, startDate, endDate, orgId);
			var availableSlots = GetAvailableTimeSlots(timeSlots, holidays);

			return
				(from slot in availableSlots.Where(s => s.End > startDate)
				 let slotStart = slot.Start >= startDate ? slot.Start : startDate
				 let slotEnd = slot.End <= endDate ? slot.End : endDate
				 let slotDuration = (int)Math.Round(((slotEnd - slotStart)?.TotalMinutes).GetValueOrDefault())
				 where slotDuration > 0
				 select slotDuration).Sum();
		}

		private static IEnumerable<Holiday> RetrieveHolidays(EntityReference holidayRef, IOrganizationService service, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.RetrieveHolidays|{holidayRef}";
			var rules = CacheHelpers.GetFromMemCache<DataCollection<Entity>>(cacheKey, orgId: orgId);

			if (rules == null && holidayRef != null)
			{
				rules = service.Retrieve(holidayRef.LogicalName, holidayRef.Id, new ColumnSet(true))
					.GetAttributeValue<EntityCollection>("calendarrules").Entities;
				CacheHelpers.AddToMemCache(cacheKey, rules, CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
			}

			return holidayRef == null
				? new Holiday[0]
				: rules.Select(holidayCalrule =>
						new Holiday
						{
							Start = holidayCalrule.GetAttributeValue<DateTime>("effectiveintervalstart"),
							End = holidayCalrule.GetAttributeValue<DateTime>("effectiveintervalend"),
							TimeZoneCode = holidayCalrule.GetAttributeValue<int?>("timezonecode")
						});
		}

		private static TimeInfo[] RetrieveCalendarTimeSlots(Guid calendarId, IOrganizationService service, DateTime startDate,
			DateTime? endDate = null, Guid? orgId = null)
		{
			startDate = startDate.Date;
			endDate = endDate?.AddDays(1).Date ?? startDate.AddDays(30);

			var cacheKey = $"Yagasoft.Common.RetrieveCalendarTimeSlots|{calendarId}|{startDate}|{endDate}";
			var slots = CacheHelpers.GetFromMemCache<TimeInfo[]>(cacheKey, orgId: orgId);

			if (slots == null)
			{
				slots = ((ExpandCalendarResponse)service.Execute(
					new ExpandCalendarRequest
					{
						CalendarId = calendarId,
						Start = startDate,
						End = endDate.Value
					})).result;
				CacheHelpers.AddToMemCache(cacheKey, slots, CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
			}

			return slots;
		}

		private static IEnumerable<TimeInfo> GetAvailableTimeSlots(TimeInfo[] timeSlots, IEnumerable<Holiday> holidays)
		{
			return
				from timeSlotQ in timeSlots
				where holidays?.Any(holiday => holiday.Start < timeSlotQ.Start && holiday.End > timeSlotQ.End) != true
				select timeSlotQ;
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class FetchXmlTriggerHelpers
	{
		/// <summary>
		/// Register steps to handle FetchXML condition changes.<br />
		/// If you only care about satisfaction of conditions, then only pass plugin configs for post-operations.<br />
		/// If you need to check for negative/dissatisfaction of conditions, use pre and post-operations,
		/// passing the list of 'root' record IDs from the pre to the post plugin through the SharedVariables object.<br />
		/// You must mark the 'root' plugin, which can be common with other triggers.<br />
		/// 'GetFilteredTriggerConfigs' method can be used to get the serialised trigger config from the plugin config,
		/// which contains the FetchXML used for fetching the 'root' records.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RegisterTriggeringStep(IOrganizationService service, string id, string suffix, string fetchXml,
			TriggerConfigPlugin[] pluginConfigs, Guid? orgId = null)
		{
			service.Require(nameof(service));
			pluginConfigs.Require(nameof(pluginConfigs));
			id.RequireNotEmpty(nameof(id));
			fetchXml.RequireNotEmpty(nameof(fetchXml));

			var triggerConfigs = new List<TriggerConfig>();

			ParseConditionFields(service, $"{id}{(string.IsNullOrWhiteSpace(suffix) ? "" : $"-{suffix}")}",
				fetchXml, triggerConfigs, orgId);
			RegisterTriggeringStep(service, pluginConfigs, triggerConfigs, false, orgId);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void UnregisterTriggeringStep(IOrganizationService service, string id, string suffix, string fetchXml,
			TriggerConfigPlugin[] pluginConfigs, Guid? orgId = null)
		{
			service.Require(nameof(service));
			pluginConfigs.Require(nameof(pluginConfigs));
			id.RequireNotEmpty(nameof(id));
			fetchXml.RequireNotEmpty(nameof(fetchXml));

			var triggerConfigs = new List<TriggerConfig>();

			ParseConditionFields(service, $"{id}{(string.IsNullOrWhiteSpace(suffix) ? "" : $"-{suffix}")}",
				fetchXml, triggerConfigs, orgId);
			RegisterTriggeringStep(service, pluginConfigs, triggerConfigs, true, orgId);
		}

		public static IEnumerable<TriggerConfig> GetFilteredTriggerConfigs(string pluginConfig, params string[] fields)
		{
			return GetFilteredTriggerConfigs(ParseTriggerConfigs(pluginConfig), fields);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IEnumerable<TriggerConfig> GetFilteredTriggerConfigs(IEnumerable<TriggerConfig> triggerConfigs,
			params string[] fields)
		{
			return triggerConfigs.Where(t => fields.Contains("*") || fields.Intersect(t.Fields).Any());
		}

		private static void RegisterTriggeringStep(IOrganizationService service, TriggerConfigPlugin[] pluginConfigs,
			IReadOnlyList<TriggerConfig> triggerConfigs, bool isRemoveCurrent = false, Guid? orgId = null)
		{
			service.Require(nameof(service));
			pluginConfigs.Require(nameof(pluginConfigs));
			triggerConfigs.Require(nameof(triggerConfigs));

			foreach (var triggerConfig in triggerConfigs)
			{
				var id = triggerConfig.Id;
				var entityName = triggerConfig.EntityName;

				foreach (var pluginConfig in pluginConfigs)
				{
					if (triggerConfig.IsRootEntity != pluginConfig.IsRootEntity)
					{
						continue;
					}

					var step = GetStep(service, GetStepName(pluginConfig.Type, pluginConfig.Message, entityName));

					// get existing entity map from plugin configuration
					var stepConfig = step?.GetAttributeValue<string>("configuration");
					var parsedStepConfig = stepConfig == null
						? new List<TriggerConfig>()
						: ParseTriggerConfigs(stepConfig).Where(c => c.Id != id).ToList();

					foreach (var config in parsedStepConfig.Where(c => string.IsNullOrWhiteSpace(c.EntityName)))
					{
						config.EntityName = entityName;
					}

					if (!isRemoveCurrent)
					{
						parsedStepConfig.Add(triggerConfig);
					}

					if (pluginConfig.ExtraTriggerFields?.Any() == true)
					{
						foreach (var field in pluginConfig.ExtraTriggerFields)
						{
							triggerConfig.Fields.Add(field);
						}
					}

					var filteredStepConfigs = parsedStepConfig.Where(c => c.Fields.Any()).ToArray();

					var parsedStepConfigString = filteredStepConfigs
						.Select(c => $"{c.Id}|||{c.IsRootEntity}|||{c.Fields.StringAggregate()}"
							+ $"{(c.IsRootEntity ? "" : $"|||{c.FetchXml.StringAggregate("^^^")}")}")
						.Aggregate("", (c1, c2) => $"{c1};;;{c2}").Trim(',', ';');

					string[] filteringAttributes = null;

					if (pluginConfig.Message == "Update")
					{
						filteringAttributes = filteredStepConfigs.SelectMany(c => c.Fields).Distinct().ToArray();
					}

					RegisterStep(service, entityName, pluginConfig, parsedStepConfigString, orgId, filteringAttributes);
				}
			}
		}

		private static IEnumerable<TriggerConfig> ParseTriggerConfigs(string rawString)
		{
			rawString.RequireNotEmpty(nameof(rawString));

			return rawString.Decompress()
				.Split(new[] { ";;;" }, StringSplitOptions.RemoveEmptyEntries)
				.Select(c => c.Split(new[] { "|||" }, StringSplitOptions.RemoveEmptyEntries))
				.Where(c => c.Any() && !string.IsNullOrWhiteSpace(c[0]))
				.Select(c =>
					new TriggerConfig
					{
						Id = c[0],
						IsRootEntity = c.Length > 1 && bool.Parse(c[1]),
						Fields = c.Length > 2 ? new HashSet<string>(c[2].Split(',')) : new HashSet<string>(),
						FetchXml = c.Length > 3
							? c[3].Split(new[] { "^^^" }, StringSplitOptions.RemoveEmptyEntries).ToList()
							: new List<string>()
					});
		}

		private static void ParseConditionFields(IOrganizationService service, string id, string fetchXml,
			List<TriggerConfig> triggerConfigs, Guid? orgId = null)
		{
			fetchXml.RequireNotEmpty(nameof(fetchXml));
			triggerConfigs.Require(nameof(triggerConfigs));

			var doc = new XmlDocument();
			doc.LoadXml(fetchXml);

			var parentNodes = doc.SelectNodes("//entity")?.Cast<XmlNode>().ToList();

			if (parentNodes == null)
			{
				throw new FormatException("FetchXML is not properly formatted.");
			}

			var linkNodes = doc.SelectNodes("//link-entity")?.Cast<XmlNode>();

			if (linkNodes != null)
			{
				parentNodes.AddRange(linkNodes);
			}

			foreach (var parent in parentNodes)
			{
				var conditionNodes = parent?.SelectNodes("filter//condition")?.Cast<XmlNode>();

				if (conditionNodes == null)
				{
					continue;
				}

				foreach (var node in conditionNodes)
				{
					var entityName = parent.Attributes?["name"]?.Value;
					var attributeName = node.Attributes?["attribute"]?.Value;

					if (entityName == null || attributeName == null)
					{
						continue;
					}

					var isRoot = parent.Name == "entity";
					var triggerConfig = triggerConfigs
							.FirstOrDefault(c => c.IsRootEntity == isRoot && c.EntityName == entityName);

					if (triggerConfig == null)
					{
						triggerConfig =
							new TriggerConfig
							{
								Id = id,
								IsRootEntity = isRoot,
								EntityName = entityName,
								FetchXml = new List<string>(),
								Fields = new HashSet<string>()
							};
						triggerConfigs.Add(triggerConfig);
					}

					triggerConfig.Fields.Add(attributeName);

					var xmlParser = new XmlDocument();
					var primaryIdField = MetadataHelpers.GetEntityAttribute<string>(service, entityName,
						MetadataHelpers.EntityAttribute.PrimaryIdAttribute, orgId);

					xmlParser.LoadXml("<temp><filter>"
						+ $@"<condition attribute=""{primaryIdField}"" operator=""eq"" value=""{{{{recordId}}}}""/></filter></temp>");

					var tempXmlNodes = xmlParser.SelectSingleNode("/temp")?.ChildNodes.Cast<XmlNode>();
					var newXmlNodes = new List<XmlNode>();

					if (tempXmlNodes != null)
					{
						foreach (var tempNode in tempXmlNodes)
						{
							var newNode = parent.OwnerDocument?.ImportNode(tempNode, true);
							newXmlNodes.Add(newNode);

							if (newNode != null)
							{
								parent.AppendChild(newNode);
							}
						}
					}

					var newFetchXml = doc.OuterXml;
					triggerConfig.FetchXml.Add(newFetchXml);

					foreach (var newXmlNode in newXmlNodes)
					{
						parent.RemoveChild(newXmlNode);
					}
				}
			}
		}

		private static void RegisterStep(IOrganizationService service, string entity, TriggerConfigPlugin pluginConfig,
			string unsecureConfig, Guid? orgId = null, params string[] filteringAttributes)
		{
			service.Require(nameof(service));
			entity.RequireNotEmpty(nameof(entity));
			pluginConfig.Require(nameof(pluginConfig));

			var message = GetMessage(service, entity, pluginConfig.Message, orgId);

			if (message == null)
			{
				throw new Exception($"Couldn't find a message '{pluginConfig.Message}' for entity '{entity}'.");
			}

			var query =
				new QueryExpression("plugintype")
				{
					Distinct = true,
					NoLock = true,
					ColumnSet = new ColumnSet("name", "plugintypeid")
				};
			query.Criteria.AddCondition("name", ConditionOperator.Equal, pluginConfig.Type);

			var type = service.RetrieveMultiple(query).Entities
				.Select(e =>
					new
					{
						e.Id,
						Name = e.GetAttributeValue<string>("name")
					}).FirstOrDefault();

			if (type == null)
			{
				throw new Exception($"Couldn't find '{pluginConfig.Type}' plugin type.");
			}

			message.PluginTypeId = type.Id;
			message.TypeName = type.Name;

			var stepName = GetStepName(message.TypeName, message.MessageName, entity);
			var step = GetStep(service, stepName);

			if (string.IsNullOrWhiteSpace(unsecureConfig))
			{
				if (step != null)
				{
					service.Delete("sdkmessageprocessingstep", step.Id);
				}
			}
			else
			{
				step = step
					?? new Entity("sdkmessageprocessingstep")
					{
						["name"] = stepName,
						["rank"] = 999,
						["stage"] = new OptionSetValue((int)pluginConfig.Stage),
						["supporteddeployment"] = new OptionSetValue(0),
						["sdkmessageid"] = new EntityReference("sdkmessage", message.MessageId),
						["sdkmessagefilterid"] = new EntityReference("sdkmessagefilter", message.FilteredId),
						["eventhandler"] = new EntityReference("plugintype", message.PluginTypeId)
					};

				step["configuration"] = unsecureConfig.Compress();

				if (filteringAttributes?.Any() == true)
				{
					step["filteringattributes"] = filteringAttributes.Aggregate("", (f1, f2) => $"{f1},{f2}").Trim(',', ';');
				}

				if (pluginConfig.Mode == PluginMode.Asynchronous)
				{
					step["asyncautodelete"] = true;
				}

				step["mode"] = new OptionSetValue((int)pluginConfig.Mode);

				if (step.Id == Guid.Empty)
				{
					var stepId = service.Create(step);

					if (pluginConfig.IsPreImage || pluginConfig.IsPostImage)
					{
						RegisterImage(service, pluginConfig, stepId);
					}
				}
				else
				{
					service.Update(step);
				}
			}
		}

		private static void RegisterImage(IOrganizationService service, TriggerConfigPlugin pluginConfig, Guid stepId)
		{
			service.Require(nameof(service));
			pluginConfig.Require(nameof(pluginConfig));

			int imageType;

			if (pluginConfig.IsPreImage && !pluginConfig.IsPostImage)
			{
				imageType = 0;
			}
			else if (!pluginConfig.IsPreImage && pluginConfig.IsPostImage)
			{
				imageType = 1;
			}
			else if (pluginConfig.IsPreImage && pluginConfig.IsPostImage)
			{
				imageType = 2;
			}
			else
			{
				throw new ArgumentOutOfRangeException("ImageType", "Image type is not supported.");
			}

			var image =
				new Entity("sdkmessageprocessingstepimage")
				{
					["name"] = "image",
					["entityalias"] = "image",
					["imagetype"] = new OptionSetValue(imageType),
					["messagepropertyname"] = pluginConfig.Message == "Create" ? "Id" : "Target",
					["sdkmessageprocessingstepid"] = new EntityReference("sdkmessageprocessingstep", stepId)
				};
			service.Create(image);
		}

		private static SdkMessageInfo GetMessage(IOrganizationService service, string entityName, string messageName,
			Guid? orgId = null)
		{
			service.Require(nameof(service));
			entityName.RequireNotEmpty(nameof(entityName));
			messageName.RequireNotEmpty(nameof(messageName));

			var query =
				new FetchExpression("<fetch no-lock='true' >" +
					"  <entity name='sdkmessage' >" +
					"    <attribute name='name' />" +
					"    <attribute name='sdkmessageid' />" +
					"    <filter>" +
					$"      <condition attribute='name' operator='eq' value='{messageName}' />" +
					"    </filter>" +
					"    <link-entity name='sdkmessagefilter' from='sdkmessageid' to='sdkmessageid' alias='messagefilter' >" +
					"      <attribute name='sdkmessagefilterid' />" +
					"      <filter>" +
					"        <condition attribute='primaryobjecttypecode' operator='eq'"
					+ $" value='{MetadataHelpers.GetTypeCodeUsingEntityName(service, entityName, orgId)}' />" +
					"      </filter>" +
					"    </link-entity>" +
					"  </entity>" +
					"</fetch>");

			var message = service.RetrieveMultiple(query).Entities
				.Select(e =>
					new SdkMessageInfo
					{
						MessageId = e.GetAttributeValue<Guid>("sdkmessageid"),
						MessageName = e.GetAttributeValue<string>("name"),
						FilteredId = (Guid)
							(e.GetAttributeValue<AliasedValue>("messagefilter.sdkmessagefilterid")?.Value ?? Guid.Empty)
					}).FirstOrDefault();

			if (message == null || message.MessageId == Guid.Empty || message.FilteredId == Guid.Empty)
			{
				throw new Exception($"Couldn't find {messageName} message for entity '{entityName}'.");
			}

			return message;
		}

		private static Entity GetStep(IOrganizationService service, string stepName)
		{
			service.Require(nameof(service));
			stepName.RequireNotEmpty(nameof(stepName));

			var query =
				new QueryExpression("sdkmessageprocessingstep")
				{
					NoLock = true,
					ColumnSet = new ColumnSet(true)
				};
			query.Criteria.AddCondition("name", ConditionOperator.Equal, stepName);
			return service.RetrieveMultiple(query).Entities.FirstOrDefault();
		}

		private static string GetStepName(string typeName, string messageName, string entityName)
		{
			var builder = new StringBuilder();
			builder.Append("FetchXmlTrigger: ");
			builder.Append(typeName);
			builder.Append(": ");
			builder.Append(messageName);
			builder.Append(" of ");
			builder.Append(entityName == "none" ? "any entity" : entityName);

			return builder.ToString();
		}
	}

	public class CacheParams
	{
		public Guid? OrgId;
		public string CacheSuffix;
		public DateTime? CacheExpiryTarget;
	}

	public class SdkMessageInfo
	{
		public Guid MessageId;
		public Guid FilteredId;
		public string MessageName;
		public Guid PluginTypeId;
		public string TypeName;
	}

	public class TriggerConfig
	{
		public string Id;
		public bool IsRootEntity;
		public string EntityName;
		public HashSet<string> Fields;
		public List<string> FetchXml;
	}

	public class TriggerConfigPlugin
	{
		public string Type;
		public string Message;
		public bool IsRootEntity;
		public PluginStage Stage;
		public PluginMode Mode;
		public bool IsPreImage;
		public bool IsPostImage;
		public string[] ExtraTriggerFields;
	}

	public class CrmCalendar
	{
		public Guid Id;
		public EntityReference HolidayRef;
	}

	public class Holiday
	{
		public DateTime Start;
		public DateTime End;
		public int? TimeZoneCode;
	}

	public class RetrievePagingInfo
	{
		public string Cookie
		{
			get; set;
		}

		public int NextPage { get; set; } = 1;

		public int RecordCountLimit { get; set; } = -1;

		public bool IsMoreRecords { get; set; } = true;
	}

	public class BpfRecord
	{
		public Guid Id
		{
			get; set;
		}
		public string LogicalName
		{
			get; set;
		}
		public Guid? ProcessId
		{
			get; set;
		}
		public Guid? StageId
		{
			get; set;
		}
		public string TraversedPath
		{
			get; set;
		}
	}

	public class BpfStageRecord
	{
		public Guid Id { get; set; }
		public EntityReference StageRecord { get; set; }
		public string ActivePath { get; set; }
		public string TraversedPath { get; set; }
	}

	public class BpfStageInfo
	{
		public Guid Id
		{
			get; set;
		}

		public string Name
		{
			get; set;
		}

		public int Index
		{
			get; set;
		}
	}

	public class ExecuteBulkResponse
	{
		public OrganizationResponse Response
		{
			get; set;
		}

		public Type RequestType
		{
			get; set;
		}

		public Type ResponseType
		{
			get; set;
		}

		public OrganizationServiceFault Fault
		{
			get; set;
		}

		public string FaultMessage
		{
			get; set;
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	public class EntityComparer : IEqualityComparer<Entity>
	{
		public bool Equals(Entity x, Entity y)
		{
			return x.Id == y.Id;
		}

		public int GetHashCode(Entity obj)
		{
			return obj.Id.GetHashCode();
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	public class EntityRefComparer : IEqualityComparer<EntityReference>
	{
		public bool Equals(EntityReference x, EntityReference y)
		{
			return x.Id == y.Id;
		}

		public int GetHashCode(EntityReference obj)
		{
			return obj.Id.GetHashCode();
		}
	}

	public class RelationMetadata
	{
		public string SchemaName
		{
			get; set;
		}
		public string Entity1Name
		{
			get; set;
		}
		public string Entity1FieldName
		{
			get; set;
		}
		public string Entity2Name
		{
			get; set;
		}
		public string Entity2FieldName
		{
			get; set;
		}
		public MetadataHelpers.RelationType Type
		{
			get; set;
		}
		public string IntersectingEntityName
		{
			get; set;
		}
	}

	/// <summary>
	///     Unlike <see cref="Semaphore" />, this implementation ensures that holds are released in the order of acquiring the
	///     hold.
	///     It also implements <see cref="IDisposable" />, but in a reusable fashion; e.g:
	///     <code>	using (fifoSemaphore.GetPermit())
	/// 	{
	///  		// code ...
	///   	}
	///     </code>
	///     After exiting the 'using' block, <see cref="ReleasePermit" /> is called automatically.<br />
	///		Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public sealed class FifoSemaphore : IDisposable
	{
		private readonly Queue<ManualResetEvent> threadLocksQueue = new Queue<ManualResetEvent>();

		private readonly int maxConcurrency;

		private readonly object lockObject = new object();
		private int currentRequests;

		public FifoSemaphore(int maxConcurrency)
		{
			this.maxConcurrency = maxConcurrency;
		}

		public void Dispose()
		{
			ReleasePermit();
		}

		/// <summary>
		///     Check how many permits have been requested before, and if the number is greater than the limit,
		///     hold this request until a permit elsewhere is released.
		/// </summary>
		public FifoSemaphore AcquirePermit()
		{
			lock (lockObject)
			{
				currentRequests++;

				// if the limit hasn't been reached yet, note it, and give permission
				if (currentRequests <= maxConcurrency)
				{
					return this;
				}
			}

			using (var newLock = new ManualResetEvent(false))
			{
				// we have to wait for a slot to open
				threadLocksQueue.Enqueue(newLock);
				newLock.WaitOne();
			}

			return this;
		}

		/// <summary>
		///     Release a permit, and release the hold on the next in line.
		/// </summary>
		public void ReleasePermit()
		{
			lock (lockObject)
			{
				// note the release
				currentRequests--;

				// give permission to the next in line
				if (threadLocksQueue.Any())
				{
					threadLocksQueue.Dequeue().Set();
				}
			}
		}
	}

	/// <summary>
	///     credits: http://joe-bq-wang.iteye.com/blog/1878940 <br />
	///		Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public sealed class QueuedLock : IDisposable
	{
		private readonly object innerLock;
		private volatile int ticketsCount;
		private volatile int ticketToRide;

		public QueuedLock()
		{
			innerLock = new object();
			ticketToRide = ticketsCount + 1;
		}

		public void Dispose()
		{
			Exit();
		}

		public QueuedLock Enter()
		{
			var myTicket = Interlocked.Increment(ref ticketsCount);
			Monitor.Enter(innerLock);

			while (true)
			{
				if (myTicket == ticketToRide)
				{
					return this;
				}

				Monitor.Wait(innerLock);
			}
		}

		public void Exit()
		{
			Interlocked.Increment(ref ticketToRide);
			Monitor.PulseAll(innerLock);
			Monitor.Exit(innerLock);
		}
	}

	/// <summary>
	///     credits: http://joe-bq-wang.iteye.com/blog/1878940<br />
	///		Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public class BlockingQueue<T> : BlockingCollection<T>
	{
		#region ctor(s)

		public BlockingQueue() : base(new ConcurrentQueue<T>())
		{ }

		public BlockingQueue(int maxSize) : base(new ConcurrentQueue<T>(), maxSize)
		{ }

		#endregion ctor(s)

		#region Methods

		/// <summary>
		///     Enqueue an Item
		/// </summary>
		/// <param name="item">Item to enqueue</param>
		/// <remarks>Blocks if the blocking queue is full</remarks>
		public void Enqueue(T item)
		{
			Add(item);
		}

		/// <summary>
		///     Dequeue an item
		/// </summary>
		/// <param name="timeout">[Optional] The number of milliseconds to timeout while waiting. Value of -1 is infinite wait.</param>
		/// <returns>Item dequeued</returns>
		/// <remarks>Blocks if the blocking queue is empty</remarks>
		/// <exception cref="TimeoutException">Timeout expired.</exception>
		public T Dequeue(TimeSpan? timeout = null)
		{
			if (timeout == null)
			{
				return Take();
			}

			try
			{
				return Take(new CancellationTokenSource(timeout.Value).Token);
			}
			catch (OperationCanceledException)
			{
				throw new TimeoutException($"Timeout while waiting for an item to be added to the queue (timeout: {timeout} ms).");
			}
		}

		public T Dequeue(CancellationTokenSource cancellationToken)
		{
			return Take(cancellationToken.Token);
		}

		/// <summary>
		///     Clears the queue of all items
		/// </summary>
		public void Clear()
		{
			while (this.Any())
			{
				Dequeue();
			}
		}

		#endregion Methods
	}

	/// <summary>
	///     Adds to the queue, up to the limit, after which it dequeues to keep the size within the limit.<br />
	///     credits: https://stackoverflow.com/a/5852926/1919456<br />
	///		Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public class FixedSizeQueue<T> : ICollection<T>, IEnumerable<T>, IEnumerable, ICollection
	{
		public virtual int Limit => limit;
		public virtual int Count => q.Count;
		public virtual object SyncRoot => throw new NotSupportedException();
		public virtual bool IsSynchronized => false;
		public virtual bool IsReadOnly => false;

		protected readonly ConcurrentQueue<T> q = new ConcurrentQueue<T>();
		protected int limit;

		public FixedSizeQueue(int limit)
		{
			limit.RequireAtLeast(1, nameof(limit));
			this.limit = limit;
		}

		public virtual void Enqueue(T obj)
		{
			q.Enqueue(obj);
			while (q.Count > limit && q.TryDequeue(out var _)) ;
		}

		public virtual T Dequeue()
		{
			q.TryDequeue(out var e);
			return e;
		}

		public virtual void Add(T item)
		{
			Enqueue(item);
		}

		public virtual void Clear()
		{
			while (q.Any())
			{
				Dequeue();
			}
		}

		public virtual bool Contains(T item)
		{
			return q.Contains(item);
		}

		public virtual void CopyTo(T[] array, int arrayIndex)
		{
			array.Require(nameof(array));
			q.CopyTo(array, arrayIndex);
		}

		public virtual bool Remove(T item)
		{
			throw new NotSupportedException();
		}

		public virtual void CopyTo(Array array, int index)
		{
			array.Require(nameof(array));
			this.ToArray().CopyTo(array, index);
		}

		public virtual IEnumerator<T> GetEnumerator()
		{
			return q.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}

	#endregion

	#region CRM Logger

	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	[DebuggerNonUserCode]
	public sealed class LogAttribute : Attribute
	{ }

	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	[DebuggerNonUserCode]
	public sealed class NoLogAttribute : Attribute
	{ }

	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	[DebuggerNonUserCode]
	public sealed class LogExecEndAttribute : Attribute
	{ }

	public enum ExecutionEndState
	{
		Success = 0,
		Failure = 1
	}

	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	[DebuggerNonUserCode]
	public class Log
	{
		public string Name { get; set; }
		public string Title { get; set; }
		public string Assembly { get; set; }
		public string EntryClass { get; set; }
		public string EntryFunction { get; set; }
		public DateTime? StartDate { get; set; }
		public Guid? UserId { get; set; }
		public ExecutionEndState? ExecutionEndState { get; set; }
		public string RegardingType { get; set; }
		public Guid? RegardingId { get; set; }
		public string RegardingName { get; set; }
	}

	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	[DebuggerNonUserCode]
	public class LogEntryAddedEventArgs : EventArgs
	{
		public ILogger Logger { get; set; }
		public Log Log { get; set; }
		public LogEntry LogEntry { get; set; }
	}

	/// <summary>
	///     Contains information related to the log entry.<br />
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	[DebuggerNonUserCode]
	public class LogEntry
	{
		public LogEntry(string message, LogLevel level = LogLevel.Info, string information = "")
			: this()
		{
			Message = message;
			Information = information;
			Level = level;
		}

		public LogEntry(Exception exception, string message = null, string information = "", LogLevel level = LogLevel.Error)
			: this()
		{
			Message = message;
			Exception = exception;
			Information = information;
			Level = level;
		}

		public LogEntry(string message, string information, LogLevel level = LogLevel.Info)
			: this(message, level, information)
		{ }

		private LogEntry()
		{
			Id = Guid.NewGuid();
		}

		public Guid Id { get; set; }

		public LogEntry ParentLogEntry { get; set; }

		public string Message { get; set; }

		public DateTime? StartDate { get; set; }

		public LogLevel Level { get; set; }

		public Guid? UserId { get; set; }

		public string RegardingType { get; set; }

		public Guid? RegardingId { get; set; }

		public string RegardingName { get; set; }

		public Exception Exception { get; set; }

		public bool ExceptionThrown { get; set; }

		public string Assembly { get; set; }

		public string StackTrace { get; set; }

		public string CallingClass { get; set; }

		public string CallingFunction { get; set; }

		public int? CallingLineNumber { get; set; }

		public string Information { get; set; }

		public int? CurrentEntryIndex { get; set; }

		public int? ElapsedTime { get; set; }
	}

	/// <summary>
	///     Logging functions.<br />
	///		Author: Ahmed Elsawalhy (Yagasoft.com)<br />
	/// </summary>
	public interface ILogger
	{
		/// <summary>
		///     Sets the 'regarding' fields in the parent log.
		/// </summary>
		/// <param name="regardingType">The logical name of the concerned entity.</param>
		/// <param name="regardingId">The ID of the regarding record.</param>
		/// <param name="regardingName">
		///     [OPTIONAL] The primary field value of the concerned entity (usually the 'xxx_name' field
		///     value).
		/// </param>
		void SetRegarding(string regardingType, Guid regardingId, string regardingName = "");

		/// <summary>
		///     Sets the 'regarding' fields in the parent log. It is recommended to fill the 'Name' property.
		/// </summary>
		/// <param name="regarding">The reference to the concerned entity.</param>
		void SetRegarding(EntityReference regarding);

		/// <summary>
		///     Sets the title field in the parent log.
		/// </summary>
		/// <param name="title">Title to set.</param>
		void SetTitle(string title);

		/// <summary>
		///     Sets the entry class of the parent log.
		/// </summary>
		void SetEntryClass(string entryClass = null);

		/// <summary>
		///     Logs the start of execution.
		/// </summary>
		/// <param name="message">The message to set in the log entry</param>
		void LogExecutionStart(string message, [CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0);

		/// <summary>
		///     Logs the start of execution.
		/// </summary>
		/// <param name="logEntry">[Optional] The log entry object that includes all relevant information</param>
		void LogExecutionStart(LogEntry logEntry = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0);

		/// <summary>
		///     Logs the start of a function.
		/// </summary>
		/// <param name="message">The message to set in the log entry</param>
		void LogFunctionStart(string message, [CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0);

		/// <summary>
		///     Logs the start of a function.
		/// </summary>
		/// <param name="logEntry">[Optional] The log entry object that includes all relevant information</param>
		void LogFunctionStart(LogEntry logEntry = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0);

		/// <summary>
		///     Logs the end of a function.
		/// </summary>
		/// <param name="message">The message to set in the log entry</param>
		void LogFunctionEnd(string message, [CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0);

		/// <summary>
		///     Logs the end of a function.
		/// </summary>
		/// <param name="logEntry">[Optional] The log entry object that includes all relevant information</param>
		void LogFunctionEnd(LogEntry logEntry = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0);

		/// <summary>
		///     Logs the end of execution.
		/// </summary>
		/// <param name="message">The message to set in the log entry</param>
		/// <param name="state">[Optional] The state at which the execution ended</param>
		void LogExecutionEnd(string message, ExecutionEndState state = ExecutionEndState.Success,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0);

		/// <summary>
		///     Logs the end of execution.
		/// </summary>
		/// <param name="state">[Optional] The state at which the execution ended</param>
		/// <param name="logEntry">[Optional] The log entry object that includes all relevant information</param>
		void LogExecutionEnd(LogEntry logEntry = null, ExecutionEndState state = ExecutionEndState.Success,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0);

		void LogError(string message, string information = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0);

		void LogError(Exception exception, [CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0);

		void LogWarning(string message, string information = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0);

		void LogInfo(string message, string information = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0);

		void LogDebug(string message, string information = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0);

		/// <summary>
		///     Logs an entry.
		/// </summary>
		/// <param name="message">The message to set in the log entry</param>
		/// <param name="level">[Optional] The logging level, above which, this entry will be skipped</param>
		void Log(string message, LogLevel level = LogLevel.Info, string information = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0);

		/// <summary>
		///     Logs an exception.
		/// </summary>
		/// <param name="exception">The exception that was thrown</param>
		/// <param name="information">
		///     [Optional] Extra information to add to the log entry. If not given, a default detailed message will be built.
		/// </param>
		void Log(Exception exception, string information = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0);

		/// <summary>
		///     Logs an entry.
		/// </summary>
		void Log(LogEntry logEntry, bool parent = false, int? elapsedTime = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0);

		void LogKeyValues(string title, IDictionary<string, object> parameters, LogLevel level = LogLevel.Info,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0);

		void LogKeyValues(string title, string[] paramNames, object[] paramValues, LogLevel level = LogLevel.Info,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0);

		void LogAttributeValues(Entity labelsRecord, AttributeCollection attributes = null, string entryTitle = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0);

		/// <summary>
		///     Logs the current execution line in the code. You do not need to pass any arguments for it to work.
		/// </summary>
		void LogLine([CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0);

		/// <summary>
		///     Sets the state at which the execution ended
		/// </summary>
		/// <param name="state">The state at which the execution ended</param>
		void SetExecutionState(ExecutionEndState state);

		/// <summary>
		///     Sets the state at which the execution ended as a failure
		/// </summary>
		void ExecutionFailed();
	}

	/// <summary>
	///     Basic logic for logging.<br />
	///		Author: Ahmed Elsawalhy (Yagasoft.com)<br />
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public abstract class LoggerBase : ILogger
	{
		/// <summary>
		///     The end states of the program that contains the logging object
		/// </summary>
		#region Instance variables

		public LogLevel MaxLogLevel { get; protected set; }

		public ExecutionEndState AssemblyExecutionState { get; protected set; }

		public int CurrentEntryIndex { get; protected set; }

		public DateTime LogStartDate { get; protected set; }

		public bool ExecutionStarted { get; protected set; }

		public virtual event EventHandler<LogEntryAddedEventArgs> LogEntryGiven;
		public virtual event EventHandler<LogEntryAddedEventArgs> LogEntryBuilt;
		public virtual event EventHandler<LogEntryAddedEventArgs> LogEntryProcessed;

		#endregion

		#region Fields

		protected readonly Log ParentLog;
		protected LogEntry ExceptionLogEntry;

		protected readonly Stack<LogEntry> ExecSeqStack;
		protected readonly Stack<Stopwatch> FunctionTimersStack;
		protected readonly Stack<int> DurationsStack;

		protected bool ExceptionThrown;
		protected Stopwatch ExecutionTimer;

		#endregion

		#region Constructors

		/// <summary>
		///     Constructor!
		/// </summary>
		/// <param name="maximumLevel">[Optional] The maximum logging level to use, above which, no logs will be saved</param>
		public LoggerBase(LogLevel? maximumLevel = null, [CallerMemberName] string callingFunction = "")
			: this(callingFunction)
		{
			MaxLogLevel = maximumLevel ?? LogLevel.Warning;
		}

		protected LoggerBase([CallerMemberName] string callingFunction = "")
		{
			ExecSeqStack = new Stack<LogEntry>();

			FunctionTimersStack = new Stack<Stopwatch>();
			DurationsStack = new Stack<int>();

			LogStartDate = DateTime.UtcNow;

			CurrentEntryIndex = 1;

			ParentLog =
				new Log
				{
					Name = $"Log-{LogStartDate.ToLocalTime():yyyy_MM_dd-HH_mm_ss_fff}",
					Assembly = Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common"),
					EntryClass = Helpers.GetClassName(-1, "Yagasoft.Libraries.Common"),
					EntryFunction = callingFunction,
					StartDate = LogStartDate,
					ExecutionEndState = ExecutionEndState.Success
				};
		}

		#endregion

		#region Init

		public virtual void SetRegarding(string regardingType, Guid regardingId, string regardingName = "")
		{
			ParentLog.RegardingType = regardingType;
			ParentLog.RegardingId = regardingId;
			ParentLog.RegardingName = regardingName;
		}

		public virtual void SetRegarding(EntityReference regarding)
		{
			regarding.Require(nameof(regarding));
			SetRegarding(regarding.LogicalName, regarding.Id, regarding.Name);
		}

		public virtual void SetTitle(string title)
		{
			ParentLog.Title = title;
		}

		public virtual void SetEntryClass(string entryClass = null)
		{
			ParentLog.EntryClass = entryClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common");
		}

		#endregion

		#region Function start/end logging

		public virtual void LogExecutionStart(string message, [CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			LogExecutionStart(new LogEntry(message), callingFunction, callingLineNumber);
		}

		public virtual void LogExecutionStart(LogEntry logEntry = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			if (MaxLogLevel == LogLevel.None || ExecutionStarted)
			{
				return;
			}

			ExecutionStarted = true;

			var defaultMessage = "Started execution: " + callingFunction;

			logEntry = logEntry ?? new LogEntry(defaultMessage);

			// log this at any level
			logEntry.Level = LogLevel.None;

			// set as root in call sequence
			ExecSeqStack.Push(logEntry); 

			if (logEntry.Message.IsEmpty())
			{
				logEntry.Message = defaultMessage;
			}

			// start measuring execution duration
			ExecutionTimer = Stopwatch.StartNew();

			// push a zero-based timestamp
			DurationsStack.Push(0);

			Log(logEntry, true, null, callingFunction, callingLineNumber);
		}

		public virtual void LogFunctionStart(string message, [CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			LogFunctionStart(new LogEntry(message), callingFunction, callingLineNumber);
		}

		public virtual void LogFunctionStart(LogEntry logEntry = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			if (MaxLogLevel == LogLevel.None)
			{
				return;
			}

			var defaultMessage = "Started: " + callingFunction;

			logEntry = logEntry ?? new LogEntry(defaultMessage);

			// set the parent as the previous in the stack, and set as parent in call sequence for next entries
			logEntry.ParentLogEntry = ExecSeqStack.Peek();
			ExecSeqStack.Push(logEntry);

			if (logEntry.Message.IsEmpty())
			{
				logEntry.Message = defaultMessage;
			}

			logEntry.Level = LogLevel.Debug;

			Log(logEntry, true, null, callingFunction, callingLineNumber);

			// start measuring function duration
			FunctionTimersStack.Push(Stopwatch.StartNew());
			ExecutionTimer = ExecutionTimer ?? FunctionTimersStack.Peek(); // keep the first timer to log execution time
			// push a zero-based timestamp
			DurationsStack.Push(0);
		}

		public virtual void LogFunctionEnd(string message, [CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			LogFunctionEnd(new LogEntry(message), callingFunction, callingLineNumber);
		}

		public virtual void LogFunctionEnd(LogEntry logEntry = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			if (MaxLogLevel == LogLevel.None)
			{
				return;
			}

			// stop function timer and get the elapsed time
			FunctionTimersStack.Peek().Stop();
			var elapsedTime = (int)FunctionTimersStack.Pop().ElapsedMilliseconds;

			// remove the duration reference of the function
			DurationsStack.Pop();

			var defaultMessage = "Finished: " + callingFunction;

			logEntry = logEntry ?? new LogEntry(defaultMessage);

			// log this at any level
			logEntry.Level = LogLevel.None;

			// set parent, then remove it from sequence of calls
			ExecSeqStack.Pop();

			if (ExecSeqStack.Any())
			{
				logEntry.ParentLogEntry = ExecSeqStack.Peek();
			}

			if (logEntry.Message.IsEmpty())
			{
				logEntry.Message = defaultMessage;
			}

			logEntry.Level = LogLevel.Debug;

			Log(logEntry, true, elapsedTime, callingFunction, callingLineNumber);
		}

		public virtual void LogExecutionEnd(string message, ExecutionEndState state = ExecutionEndState.Success,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			LogExecutionEnd(new LogEntry(message), state, callingFunction, callingLineNumber);
		}

		public virtual void LogExecutionEnd(LogEntry logEntry = null, ExecutionEndState state = ExecutionEndState.Success,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			if (MaxLogLevel == LogLevel.None)
			{
				return;
			}

			if (!ExecutionStarted)
			{
				LogExecutionStart((LogEntry)null, ParentLog.EntryFunction, 0);
			}

			// stop execution timer
			ExecutionTimer.Stop();

			// remove the duration reference of the function
			DurationsStack.Pop();

			AssemblyExecutionState = (AssemblyExecutionState == ExecutionEndState.Failure) ? AssemblyExecutionState : state;

			var defaultMessage = "Finished execution: " + callingFunction;

			logEntry = logEntry ?? new LogEntry(defaultMessage);

			// log this at any level
			logEntry.Level = LogLevel.None;

			// set parent, then remove it from sequence of calls
			if (ExecSeqStack.Any())
			{
				logEntry.ParentLogEntry = ExecSeqStack.Pop();
			}

			if (logEntry.Message.IsEmpty())
			{
				logEntry.Message = defaultMessage;
			}

			Log(logEntry, true, (int)ExecutionTimer.ElapsedMilliseconds, callingFunction, callingLineNumber);

			ExecutionStarted = false;
		}

		#endregion

		#region Logging Helpers

		public virtual void LogError(string message, string information = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			Log(message, LogLevel.Error, information, callingFunction, callingLineNumber);
		}

		public virtual void LogError(Exception exception, [CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			Log(exception, null, callingFunction, callingLineNumber);
		}

		public virtual void LogWarning(string message, string information = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			Log(message, LogLevel.Warning, information, callingFunction, callingLineNumber);
		}

		public virtual void LogInfo(string message, string information = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			Log(message, LogLevel.Info, information, callingFunction, callingLineNumber);
		}

		public virtual void LogDebug(string message, string information = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			Log(message, LogLevel.Debug, information, callingFunction, callingLineNumber);
		}

		#endregion

		#region Logging

		public virtual void Log(string message, LogLevel level = LogLevel.Info, string information = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			Log(new LogEntry(message, level, information), false, null, callingFunction, callingLineNumber);
		}

		public virtual void Log(Exception exception, string information = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			Log(new LogEntry(exception, exception.Message, information ?? exception.BuildExceptionMessage())
				{
					StackTrace = exception.StackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common")
				}, false, null,
				callingFunction, callingLineNumber);
		}

		public virtual void Log(LogEntry logEntry, bool parent = false, int? elapsedTime = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			OnLogEntryGiven(logEntry);

			if (MaxLogLevel == LogLevel.None)
			{
				return;
			}

			// set parent of this entry to top of the stack entry
			if (!parent)
			{
				logEntry.Require(nameof(logEntry));
				logEntry.ParentLogEntry = ExecSeqStack.Peek();
			}

			// calculate the duration between the last log entry in this function and this one
			if (logEntry.ElapsedTime == null)
			{
				// get the last recorded duration since function start
				var lastDuration = DurationsStack.Any() ? DurationsStack.Pop() : 0;

				// get the function timer
				var functionDuration = (int)(
					FunctionTimersStack.Any()
						? FunctionTimersStack.Peek().ElapsedMilliseconds
						: ExecutionTimer.ElapsedMilliseconds);

				// add a snapshot
				DurationsStack.Push(functionDuration);

				// calculate the time it took to get from the last recorded entry to this entry
				logEntry.ElapsedTime = functionDuration - lastDuration;
			}
			else
			{
				logEntry.ElapsedTime = elapsedTime;
			}

			logEntry.StartDate = DateTime.UtcNow.AddMilliseconds(-logEntry.ElapsedTime.GetValueOrDefault());

			// exception flag
			if (logEntry.Exception != null)
			{
				ExceptionThrown = true;
				logEntry.ExceptionThrown = true;

				var logEntryTemp = logEntry;

				while ((logEntryTemp = logEntryTemp.ParentLogEntry) != null)
				{
					logEntryTemp.ExceptionThrown = true;
				}
			}

			// increment the log entries index
			logEntry.CurrentEntryIndex = CurrentEntryIndex++;

			// code info
			logEntry.CallingClass = logEntry.CallingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common");
			logEntry.CallingFunction = logEntry.CallingFunction ?? callingFunction;
			logEntry.CallingLineNumber = logEntry.CallingLineNumber ?? callingLineNumber;

			// keep the first entry with an exception to show in root
			ExceptionLogEntry = logEntry.ExceptionThrown ? logEntry : ExceptionLogEntry;

			OnLogEntryBuilt(logEntry);

			ProcessLogEntry(logEntry);
			OnLogEntryProcessed(logEntry);
		}

		public virtual void LogKeyValues(string title, IDictionary<string, object> parameters, LogLevel level = LogLevel.Info,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			parameters.Require(nameof(parameters));
			LogKeyValues(title, parameters.Keys.ToArray(), parameters.Values.ToArray(), level, callingFunction, callingLineNumber);
		}

		public virtual void LogKeyValues(string title, string[] paramNames, object[] paramValues, LogLevel level = LogLevel.Info,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			paramNames.Require(nameof(paramNames));
			paramValues.Require(nameof(paramValues));

			var paramInfoBuilder = new StringBuilder();

			for (var i = 0; i < paramNames.Length; i++)
			{
				if (i != 0)
				{
					paramInfoBuilder.Append("\r\n");
				}

				paramInfoBuilder
					.Append(paramNames[i])
					.Append(" = ")
					.Append(Helpers.GetStringRepresentation(paramValues[i]));
			}

			Log(title, level, paramInfoBuilder.ToString(), callingFunction, callingLineNumber);
		}

		public void LogAttributeValues(Entity labelsRecord, AttributeCollection attributes = null, string entryTitle = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			labelsRecord.Require("labelsRecord");

			attributes = attributes ?? labelsRecord.Attributes;

			var attributesInfo = new StringBuilder();
			attributesInfo.Append("Attribute values (" + attributes.Count + "):");

			foreach (var attribute in attributes.OrderBy(pair => pair.Key))
			{
				attributesInfo.Append($"\r\n    \"{attribute.Key}\""
					+ $" => \"{CrmHelpers.GetAttributeName(attribute.Key, labelsRecord)}\""
					+ $" | \"{CrmHelpers.GetAttributeName(attribute.Value)}\".");
			}

			Log(entryTitle ?? "Entity Object Values", LogLevel.Debug, attributesInfo.ToString(),
				callingFunction, callingLineNumber);
		}

		public virtual void LogLine([CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			if (MaxLogLevel == LogLevel.None)
			{
				return;
			}

			Log("Execution reached line " + callingLineNumber, LogLevel.Debug, null, callingFunction, callingLineNumber);
		}

		public virtual void SetExecutionState(ExecutionEndState state)
		{
			AssemblyExecutionState = state;
		}

		public virtual void ExecutionFailed()
		{
			SetExecutionState(ExecutionEndState.Failure);
		}

		protected void PostBuildLogEntry(LogEntry logEntry)
		{}

		protected abstract void ProcessLogEntry(LogEntry logEntry);

		protected virtual void OnLogEntryGiven(LogEntry e)
		{
			LogEntryGiven?.Invoke(this, BuildEventArgs(e));
		}

		protected virtual void OnLogEntryBuilt(LogEntry e)
		{
			LogEntryBuilt?.Invoke(this, BuildEventArgs(e));
		}

		protected virtual void OnLogEntryProcessed(LogEntry e)
		{
			LogEntryProcessed?.Invoke(this, BuildEventArgs(e));
		}

		protected virtual LogEntryAddedEventArgs BuildEventArgs(LogEntry e)
		{
			return
				new LogEntryAddedEventArgs
				{
					Logger = this,
					Log = ParentLog,
					LogEntry = e
				};
		}

		#endregion
	}

	/// <summary>
	///     Plugin logging.<br />
	///		Author: Ahmed Elsawalhy (Yagasoft.com)<br />
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public class PluginLogger : LoggerBase
	{
		public Guid UserId { get; protected set; }
		public Guid OrganisationId { get; protected set; }

		public IOrganizationService Service { get; protected set; }
		public ITracingService TracingService { get; protected set; }
		public IExecutionContext Context { get; protected set; }
		public bool IsCrmLogEnabled { get; protected set; }

		private readonly Queue<LogEntry> logQueue = new Queue<LogEntry>();
		private string pluginExecInfo;
		private Entity logRecord;
		
		public PluginLogger(IServiceProvider serviceProvider, LogLevel? maximumLevel = null, [CallerMemberName] string callingFunction = "")
			: base(maximumLevel, callingFunction)
		{
			serviceProvider.Require(nameof(serviceProvider));

			Context = (IPluginExecutionContext)serviceProvider.GetService(typeof(IPluginExecutionContext));
			UserId = Context.InitiatingUserId;
			OrganisationId = Context.OrganizationId;

			Service = ((IOrganizationServiceFactory)serviceProvider.GetService(typeof(IOrganizationServiceFactory)))
				.CreateOrganizationService(null);
			TracingService = (ITracingService)serviceProvider.GetService(typeof(ITracingService));

			InitialiseLog(maximumLevel, callingFunction);
		}
		
		public PluginLogger(ActivityContext activityContext, LogLevel? maximumLevel = null, [CallerMemberName] string callingFunction = "")
			: base(maximumLevel, callingFunction)
		{
			activityContext.Require(nameof(activityContext));

			Context = activityContext.GetExtension<IWorkflowContext>();
			UserId = Context.InitiatingUserId;
			OrganisationId = Context.OrganizationId;

			Service = activityContext.GetExtension<IOrganizationServiceFactory>().CreateOrganizationService(null);
			TracingService = activityContext.GetExtension<ITracingService>();

			InitialiseLog(maximumLevel, callingFunction);
		}

		private void InitialiseLog(LogLevel? maximumLevel = null, [CallerMemberName] string callingFunction = "")
		{
			LogStartDate = DateTime.UtcNow;
			CurrentEntryIndex = 1;

			var config = GetConfiguration();

			IsCrmLogEnabled = config?.IsCrmLogEnabled == true;
			MaxLogLevel = maximumLevel ?? config?.LogLevel ?? LogLevel.Warning;

			if (!IsCrmLogEnabled)
			{
				TracingService?.Trace("CRM log disabled in Common Config.");
			}

			// if assembly is excluded, then turn off logging
			if (config?.AssemblyFilter.IsFilled() == true)
			{
				var isAssemblyIncluded = Regex
					.IsMatch(Helpers
						.GetAssemblyName(-1, "Yagasoft.Libraries.Common"), config.AssemblyFilter);
				MaxLogLevel = isAssemblyIncluded ? MaxLogLevel : LogLevel.None;
			}

			if (config?.AssemblyExclusion.IsFilled() == true)
			{
				var isAssemblyExcluded = Regex
					.IsMatch(Helpers
						.GetAssemblyName(-1, "Yagasoft.Libraries.Common"), config.AssemblyExclusion);
				MaxLogLevel = isAssemblyExcluded ? LogLevel.None : MaxLogLevel;
			}

			if (UserId == Guid.Empty && Service != null && MaxLogLevel != LogLevel.None)
			{
				UserId = ((WhoAmIResponse)Service.Execute(new WhoAmIRequest())).UserId;
			}

			ParentLog.UserId = UserId;

			if (Context != null && IsCrmLogEnabled)
			{
				LogExecutionStart((LogEntry)null, ParentLog.EntryFunction, 0);
			}

			InitLogRecord();

			LogEntryGiven +=
				(sender, args) =>
				{
					if (!ExecutionStarted)
					{
						LogExecutionStart((LogEntry)null, ParentLog.EntryFunction, 0);
					}
				};

			if (MaxLogLevel == LogLevel.None)
			{
				TracingService?.Trace($"Max log level has been determined as {MaxLogLevel}.");
			}
		}

		public override void SetExecutionState(ExecutionEndState state)
		{
			base.SetExecutionState(state);

			// plugin context
			if (pluginExecInfo == null && Context != null && IsCrmLogEnabled)
			{
				pluginExecInfo =
					state == ExecutionEndState.Failure && Service != null
						? PluginInfo.GetPluginExecutionInfo(Context, Service)
						: PluginInfo.GetPluginExecutionInfo(Context);
				Log("Plugin context info.", LogLevel.Debug, pluginExecInfo, ParentLog.EntryFunction, 0);
			}
		}

		public override void LogExecutionEnd(LogEntry logEntry = null, ExecutionEndState state = ExecutionEndState.Success,
			string callingFunction = "", int callingLineNumber = 0)
		{
			base.LogExecutionEnd(logEntry, state, callingFunction, callingLineNumber);
			FinaliseLogRecord();
			Flush();
		}

		private LogConfiguration GetConfiguration()
		{
			if (Service == null)
			{
				return null;
			}

			var config = CrmHelpers.GetGenericConfig(Service, OrganisationId);

			return config == null
				? null
				: new LogConfiguration
				  {
					  IsCrmLogEnabled = config.GetAttributeValue<bool?>("ys_iscrmlogenabled").GetValueOrDefault(),
					  LogLevel = (LogLevel)(config.GetAttributeValue<OptionSetValue>("ldv_loglevel")
						  ?? new OptionSetValue((int)LogLevel.Warning)).Value,
					  AssemblyFilter = config.GetAttributeValue<string>("ldv_assemblyfilter"),
					  AssemblyExclusion = config.GetAttributeValue<string>("ldv_assemblyexclusion")
				  };
		}

		private void InitLogRecord()
		{
			var stage = (Context as IPluginExecutionContext)?.Stage;

			logRecord =
				new Entity("ldv_log")
				{
					["ys_correlationid"] = Context?.CorrelationId.ToString().ToUpper(),
					["ys_businessunitid"] = Context?.BusinessUnitId.ToString().ToUpper(),
					["ys_depth"] = Context?.Depth,
					["ys_messagename"] = Context?.MessageName,
					["ys_isolationmodevalue"] = Context?.IsolationMode == null ? null : new OptionSetValue(Context.IsolationMode),
					["ys_stagevalue"] = stage == null ? null : new OptionSetValue(stage.Value),
					["ys_modevalue"] = Context?.Mode == null ? null : new OptionSetValue(Context.Mode),
					["ys_operationid"] = Context?.OperationId.ToString().ToUpper()
				};
		}

		private void FinaliseLogRecord()
		{
			logRecord["ldv_name"] = ParentLog.Name;
			logRecord["ldv_title"] = ParentLog.Title;
			logRecord["ldv_assembly"] = ParentLog.Assembly;
			logRecord["ldv_entryclass"] = ParentLog.EntryClass;
			logRecord["ldv_entryfunction"] = ParentLog.EntryFunction;
			logRecord["ldv_startdate"] = ParentLog.StartDate;
			logRecord["ldv_user"] = new EntityReference("systemuser", ParentLog.UserId.GetValueOrDefault());
			logRecord["ldv_executionendstate"] = new OptionSetValue((int)AssemblyExecutionState);
			logRecord["ldv_executionduration"] = (int)ExecutionTimer.ElapsedMilliseconds;
			logRecord["ldv_exceptionthrown"] = ExceptionThrown;
			logRecord["ldv_regardingtype"] = ParentLog.RegardingType ?? Context?.PrimaryEntityName;
			logRecord["ldv_regardingid"] = (ParentLog.RegardingId ?? Context?.PrimaryEntityId).ToString().ToUpper();
			logRecord["ldv_regardingname"] = ParentLog.RegardingName;
		}
		
		protected override void ProcessLogEntry(LogEntry logEntry)
		{
			if (logEntry.Level > LogLevel.None && logEntry.Level <= MaxLogLevel)
			{
				TracingService?.Trace(GetTraceServiceFormattedEntry(logEntry));
			}

			if (logEntry.ExceptionThrown)
			{
				ExceptionLogEntry = logEntry;
			}

			logQueue.Enqueue(logEntry);
		}

		private string GetTraceServiceFormattedEntry(LogEntry logEntry)
		{
			try
			{
				var stringBuilder = new StringBuilder();

				////stringBuilder.Append($"Start date: {logEntry.StartDate.GetValueOrDefault().ToLocalTime()}");
				////stringBuilder.AppendFormat("\r\nLog level: {0}", logEntry.Level);
				////stringBuilder.AppendFormat("\r\nDuration: {0} ms", logEntry.ElapsedTime);
				////stringBuilder.AppendFormat("\r\nClass: {0}", logEntry.CallingClass.Split('.').LastOrDefault());
				////stringBuilder.AppendFormat("\r\nMethod: {0}", logEntry.CallingFunction);
				////stringBuilder.AppendFormat("\r\nLine: {0}", logEntry.CallingLineNumber);

				if (logEntry.Exception == null)
				{
					if (logEntry.Level != LogLevel.Info)
					{
						stringBuilder.Append($"[{logEntry.Level}] ");
					}

					stringBuilder.Append($"{logEntry.Message}"
						+ $" | {logEntry.ElapsedTime} ms"
						+ $" | {logEntry.CallingClass?.Split('.').LastOrDefault()}"
						+ $".{logEntry.CallingFunction} at {logEntry.CallingLineNumber}");
				}
				else
				{
					stringBuilder.Append($"\r\n-- START ** EXCEPTION -"
						+ $"\r\n{logEntry.Exception.BuildExceptionMessage()}"
						+ $"\r\n-- END ** EXCEPTION -");
				}

				return stringBuilder.ToString();
			}
			catch (Exception e)
			{
				return $"Logger error:\r\n{e}";
			}
		}

		private void Flush()
		{
			TracingService?.Trace("Flushing log entries ...");

			if (!IsCrmLogEnabled || MaxLogLevel == LogLevel.None
				|| logQueue.All(entry => entry.Level == LogLevel.None)
				|| (logQueue.All(entry => entry.Level == LogLevel.None || entry.Level > MaxLogLevel)
					&& AssemblyExecutionState != ExecutionEndState.Failure))
			{
				TracingService?.Trace("No log entries.");
				return;
			}

			var requests = new List<OrganizationRequest>();
			var serialisedLogEntries = new StringBuilder();

			TracingService?.Trace($"{logQueue.Count} log entries.");

			while (logQueue.Count > 0)
			{
				var logEntry = logQueue.Dequeue();

				// if the log entry's level is above the maximum, then no need to log it
				// unless the execution failed
				if (logEntry.Level > MaxLogLevel
					&& AssemblyExecutionState != ExecutionEndState.Failure)
				{
					continue;
				}

				serialisedLogEntries.Append("<|||>").Append(EntitySerializer.SerializeObject(CreateEntryEntity(logEntry)));
			}

			logRecord["ldv_serialisedlogentries"] = serialisedLogEntries.ToString().Compress();
			requests.Add(new CreateRequest { Target = logRecord });
			var response = CrmHelpers.ExecuteBulk(Service, requests, true);
			var fault = response.Values.FirstOrDefault()?.Fault.BuildFaultMessage();

			if (fault.IsFilled())
			{
				TracingService?.Trace($"Failed to create log:");
				TracingService?.Trace(fault);
			}
		}

		/// <summary>
		///     Creates an entity containing the log entry data
		/// </summary>
		/// <param name="logEntry">The log entry.</param>
		/// <returns>The CRM entity object including all info in the log entry object</returns>
		private Entity CreateEntryEntity(LogEntry logEntry)
		{
			var target =
				new Entity("ldv_logentry")
				{
					Id = logEntry.Id,
					["ldv_name"] = BuildLogId(logEntry),
					["ldv_message"] = logEntry.Message,
					["ldv_entryindex"] = logEntry.CurrentEntryIndex,
					["ldv_startdate"] = logEntry.StartDate,
					["ldv_regardingtype"] = logEntry.RegardingType,
					["ldv_regardingname"] = logEntry.RegardingName,
					["ldv_stacktrace"] = logEntry.StackTrace
				};

			if (logEntry.Exception != null)
			{
				if (logEntry.Message.IsEmpty())
				{
					target["ldv_message"] = logEntry.Message = "Exception: " + logEntry.Exception.Message;
				}

				target["ldv_exception"] = logEntry.Exception.GetType().Name;
				target["ldv_exceptionsource"] = logEntry.Exception.Source;
				target["ldv_stacktrace"] = logEntry.Exception.StackTrace;

				if (logEntry.Exception.InnerException != null)
				{
					target["ldv_innerexception"] = logEntry.Exception.InnerException.GetType().Name;
					target["ldv_innerexceptionmessage"] = logEntry.Exception.InnerException.Message;
					target["ldv_innerexceptionsource"] = logEntry.Exception.InnerException.Source;
					target["ldv_innerexceptionstacktrace"] = logEntry.Exception.InnerException.StackTrace;
				}
			}

			target["ldv_exceptionthrown"] = logEntry.ExceptionThrown;

			target["ldv_level"] = new OptionSetValue((int)logEntry.Level);

			if (logEntry.UserId.HasValue)
			{
				target["ldv_user"] = new EntityReference("systemuser", logEntry.UserId.Value);
			}
			else if (UserId != Guid.Empty)
			{
				target["ldv_user"] = new EntityReference("systemuser", UserId);
			}

			target["ldv_assembly"] = logEntry.Assembly ?? Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common");
			target["ldv_class"] = logEntry.CallingClass;
			target["ldv_callingfunction"] = logEntry.CallingFunction;
			target["ldv_linenumber"] = logEntry.CallingLineNumber;

			if (logEntry.ElapsedTime > -1)
			{
				target["ldv_executionduration"] = logEntry.ElapsedTime;
			}

			target["ldv_information"] = logEntry.Information;

			if (logEntry.ParentLogEntry != null)
			{
				target["ldv_parentlogentryid"] = new EntityReference("ldv_logentry", logEntry.ParentLogEntry.Id);
			}

			return target;
		}

		private static string BuildLogId(LogEntry logEntry)
		{
			return $"LogEntry-{logEntry.StartDate?.ToLocalTime() ?? DateTime.Now:yyyy_MM_dd-HH_mm_ss_fff}";
		}

		private class LogConfiguration
		{
			internal bool IsCrmLogEnabled { get; set; }

			internal LogLevel LogLevel { get; set; }

			internal string AssemblyFilter { get; set; }

			internal string AssemblyExclusion { get; set; }
		}
	}

	#endregion

	#region Plugin classes

	public enum PluginStage
	{
		All,
		PreValidation = 10,
		PreOperation = 20,
		PostOperation = 40
	}

	public enum PluginMode
	{
		Synchronous = 0,
		Asynchronous = 1,
		Both = 2
	}

	public enum PluginIsolationMode
	{
		None = 1,
		Sandbox = 2,
		External = 3
	}

	/// <summary>
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public interface IPluginContext
	{
		IPlugin Plugin { get; }
		CodeActivity CodeActivity { get; }

		IServiceProvider ServiceProvider { get; }
		CodeActivityContext ExecutionContext { get; }

		IExecutionContext Context { get; }
		IOrganizationServiceFactory ServiceFactory { get; }
		ITracingService TracingService { get; }
		IOrganizationService Service { get; }
		IOrganizationService EscalatedService { get; }

		string Message { get; }
		PluginStage Stage { get; }
		Guid UserId { get; }

		Guid EscalationUserId { get; }

		string Entity { get; }
		Guid Id { get; }

		ILogger Log { get; }

		Entity PreImage { get; }
		Entity Target { get; }
		Entity PostImage { get; }
	}

	/// <summary>
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public abstract class PluginLogic<TPlugin> : IPluginContext
		where TPlugin : IPlugin
	{
		public virtual IPlugin Plugin => plugin;
		public virtual CodeActivity CodeActivity => throw new NotSupportedException("Not supported in IPlugins.");
		public virtual CodeActivityContext ExecutionContext => throw new NotSupportedException("Not supported in IPlugins.");

		public virtual IServiceProvider ServiceProvider
		{
			get
			{
				serviceProvider.Require(nameof(serviceProvider));
				return serviceProvider;
			}
		}

		public virtual IExecutionContext Context => context
			?? (context = (IPluginExecutionContext)ServiceProvider.GetService(typeof(IPluginExecutionContext)));
		public virtual IOrganizationServiceFactory ServiceFactory => serviceFactory
			?? (serviceFactory = (IOrganizationServiceFactory)ServiceProvider.GetService(typeof(IOrganizationServiceFactory)));
		public virtual ITracingService TracingService => tracingService
			?? (tracingService = (ITracingService)ServiceProvider.GetService(typeof(ITracingService)));

		public virtual IOrganizationService Service => service ?? (service = ServiceFactory.CreateOrganizationService(UserId));
		public virtual IOrganizationService EscalatedService => escalatedService
			?? (escalatedService = ServiceFactory.CreateOrganizationService(EscalationUserId));

		public virtual string Message => Context.MessageName;
		public virtual PluginStage Stage => (PluginStage)((IPluginExecutionContext)Context).Stage;
		public virtual Guid UserId => userId ?? Context.UserId;

		public virtual Guid EscalationUserId => escalationUserId
			?? (escalationUserId = CrmHelpers.GetGenericConfig(Service, Context.OrganizationId)
				.GetAttributeValue<EntityReference>("ys_escalationuserid")?.Id)
				?? throw new ArgumentNullException(nameof(EscalationUserId), "Escalation User is not set in Common Configuration.");

		public virtual string Entity => Context.PrimaryEntityName;
		public virtual Guid Id => Context.PrimaryEntityId;

		public virtual ILogger Log => log;

		public virtual Entity PreImage => preImage ?? (preImage = GetPreImage<Entity>());
		public virtual Entity Target => target ?? (target = GetTarget<Entity>());
		public virtual Entity PostImage
		{
			get
			{
				try
				{
					return postImage ?? (postImage = GetPostImage<Entity>());
				}
				catch
				{
					try
					{
						return postImage ?? (postImage = BuildPostFromPreImage<Entity>());
					}
					catch
					{
						throw new InvalidPluginExecutionException("Missing a post-image for this step.");
					}
				}
			}
		}

		protected readonly string intendedPluginMessage;
		protected readonly PluginStage intendedPluginStage;
		protected readonly string intendedEntity;

		private TPlugin plugin;

		private IServiceProvider serviceProvider;
		private IPluginExecutionContext context;
		private IOrganizationServiceFactory serviceFactory;
		private ITracingService tracingService;
		private IOrganizationService service;
		private IOrganizationService escalatedService;

		private Guid? userId;
		private Guid? escalationUserId;

		protected ILogger log;

		private Entity preImage;
		private Entity target;
		private Entity postImage;

		protected PluginLogic(string intendedPluginMessage, PluginStage intendedPluginStage, string intendedEntity = null)
		{
			this.intendedPluginMessage = intendedPluginMessage;
			this.intendedPluginStage = intendedPluginStage;
			this.intendedEntity = intendedEntity;
		}

		public virtual void Execute(TPlugin plugin, IServiceProvider serviceProvider)
		{
			Execute(plugin, serviceProvider, PluginUser.System);
		}

		public virtual void Execute(TPlugin plugin, IServiceProvider serviceProvider, bool isLogEnabled)
		{
			Execute(plugin, serviceProvider, PluginUser.System, null, isLogEnabled);
		}

		public virtual void Execute(TPlugin plugin, IServiceProvider serviceProvider, Guid? userId,
			bool isLogEnabled = true)
		{
			Execute(plugin, serviceProvider, PluginUser.Custom, userId, isLogEnabled);
		}

		public virtual void Execute(TPlugin plugin, IServiceProvider serviceProvider, PluginUser user,
			bool isLogEnabled = true)
		{
			Execute(plugin, serviceProvider, user, null, isLogEnabled);
		}

		public virtual void Execute(TPlugin plugin, IServiceProvider serviceProvider, PluginUser user, Guid? userId,
			bool isLogEnabled = true)
		{
			this.plugin = plugin;
			this.serviceProvider = serviceProvider;
			this.userId = userId;

			InitialisePlugin(user);

			try
			{
				TracingService.Trace("Initialising CRM Log ...");
				log = new PluginLogger(serviceProvider);

				if (isLogEnabled)
				{
					TracingService.Trace("Log is enabled in the code.");

					Log.SetEntryClass(typeof(TPlugin).FullName);

					if (Context.PrimaryEntityName != null && Context.PrimaryEntityName != "none"
						&& Context.PrimaryEntityId != Guid.Empty)
					{
						Log.SetRegarding(Context.PrimaryEntityName, Context.PrimaryEntityId);
					}
				}
				else
				{
					TracingService.Trace("Log is disabled in the code.");
				}
			}
			catch (Exception ex)
			{
				TracingService.Trace("Failed to init log.");
				TracingService.Trace(CrmHelpers.BuildExceptionMessage(ex));
				throw new InvalidPluginExecutionException("Failed to init log => " + ex.Message, ex);
			}

			try
			{
				if (isLogEnabled)
				{
					Log.LogExecutionStart();
				}

				TracingService.Trace("Executing plugin logic ...");
				ExecuteLogic();
				TracingService.Trace("Finished executing plugin logic.");
			}
			catch (Exception ex)
			{
				TracingService.Trace($"Exception occurred: {ex.Message}.");

				if (isLogEnabled)
				{
					Log.ExecutionFailed();
					Log.Log(ex);
				}
				else
				{
					TracingService.Trace(CrmHelpers.BuildExceptionMessage(ex));
				}

				throw new InvalidPluginExecutionException(ex.Message, ex);
			}
			finally
			{
				if (isLogEnabled)
				{
					TracingService.Trace("Logging execution end ...");

					try
					{
						Log.LogExecutionEnd();
					}
					catch (Exception e)
					{
						TracingService.Trace(CrmHelpers.BuildExceptionMessage(e));
						throw;
					}
				}

				TracingService.Trace("Finished executing plugin.");
			}
		}

		protected abstract void ExecuteLogic();

		protected TEntity GetPreImage<TEntity>() where TEntity : Entity
		{
			var image = Message == "Create" ? Target : Context.PreEntityImages.FirstOrDefault().Value;

			if (image == null)
			{
				throw new InvalidPluginExecutionException("Missing a pre-image for this step.");
			}

			return image.ToEntity<TEntity>();
		}

		protected TEntity GetTarget<TEntity>() where TEntity : Entity
		{
			if (Context.InputParameters.TryGetValue("Target", out var target) && target is Entity targetEntity)
			{
				return targetEntity.ToEntity<TEntity>();
			}

			throw new InvalidPluginExecutionException("Missing Target in the plugin input, or not of type Entity.");
		}

		protected EntityReference GetTargetReference()
		{
			if (Context.InputParameters.TryGetValue("Target", out var target) && target is EntityReference targetEntityRef)
			{
				return targetEntityRef;
			}

			throw new InvalidPluginExecutionException("Missing Target in the plugin input, or not of type EntityReference.");
		}

		protected TEntity BuildPostFromPreImage<TEntity>() where TEntity : Entity
		{
			var preImage = GetPreImage<TEntity>();
			var target = GetTarget<TEntity>();
			var postImage = new Entity(target.LogicalName, target.Id);

			foreach (var pair in preImage.Attributes)
			{
				postImage[pair.Key] = pair.Value;
			}

			foreach (var pair in preImage.FormattedValues)
			{
				postImage.FormattedValues[pair.Key] = pair.Value;
			}

			foreach (var pair in target.Attributes)
			{
				postImage[pair.Key] = pair.Value;
			}

			foreach (var pair in target.FormattedValues)
			{
				postImage.FormattedValues[pair.Key] = pair.Value;
			}

			return postImage.ToEntity<TEntity>();
		}

		protected TEntity GetPostImage<TEntity>() where TEntity : Entity
		{
			var image = Message == "Create"
				? Target
				: Message == "Delete"
					? GetPreImage<TEntity>()
					: context.Stage == (int)PluginStage.PostOperation
						? Context.PostEntityImages.FirstOrDefault().Value
						: BuildPostFromPreImage<TEntity>();

			if (image == null)
			{
				throw new InvalidPluginExecutionException("Missing a post-image for this step.");
			}

			return image.ToEntity<TEntity>();
		}

		protected virtual bool IsContextValid()
		{
			return true;
		}

		protected virtual void ValidateRegistration()
		{
			if (!string.IsNullOrWhiteSpace(intendedEntity) && Context.PrimaryEntityName != intendedEntity)
			{
				throw new InvalidPluginExecutionException(
					$"Step registered on wrong entity: {Context.PrimaryEntityName}, "
						+ $"expected: {intendedEntity}");
			}

			if (!string.IsNullOrWhiteSpace(intendedPluginMessage) && Context.MessageName != intendedPluginMessage)
			{
				throw new InvalidPluginExecutionException(
					$"Step registered on wrong message: {Context.MessageName}, "
						+ $"expected: {intendedPluginMessage}.");
			}

			var pluginContext = (IPluginExecutionContext)Context;

			if (intendedPluginStage != PluginStage.All && pluginContext.Stage != (int)intendedPluginStage)
			{
				throw new InvalidPluginExecutionException(
					$"Step registered on wrong stage: {pluginContext.Stage}, "
						+ $"expected: {intendedPluginStage}");
			}
		}

		protected void InitialisePlugin(PluginUser user = PluginUser.System)
		{
			tracingService = (ITracingService)ServiceProvider.GetService(typeof(ITracingService));

			TracingService.Trace("Getting context ...");
			context = (IPluginExecutionContext)ServiceProvider.GetService(typeof(IPluginExecutionContext));
			ValidateRegistration();

			TracingService.Trace("Getting factory ...");
			serviceFactory = (IOrganizationServiceFactory)ServiceProvider.GetService(typeof(IOrganizationServiceFactory));

			switch (user)
			{
				case PluginUser.ContextUser:
					TracingService.Trace("Running as ContextUser.");
					userId = Context.UserId;
					break;

				case PluginUser.InitiatingUser:
					TracingService.Trace("Running as InitiatingUserId.");
					userId = Context.InitiatingUserId;
					break;

				case PluginUser.System:
					TracingService.Trace("Running as System.");
					userId = null;
					break;

				case PluginUser.Custom:
					TracingService.Trace($"Running as {userId}.");
					break;

				default:
					throw new ArgumentOutOfRangeException("user", user, "Plugin user type is out of range.");
			}

			TracingService.Trace("Getting service ...");
			service = ServiceFactory.CreateOrganizationService(userId);

			if (!IsContextValid())
			{
				throw new InvalidPluginExecutionException("Failed to initialise plugin due to invalid context.");
			}

			TracingService.Trace($"Initialised plugin.");
		}
	}

	/// <summary>
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public abstract class StepLogic<TCodeActivity> : IPluginContext
		where TCodeActivity : CodeActivity
	{
		public virtual IPlugin Plugin => throw new NotSupportedException("Not supported in Code Activities.");
		public virtual CodeActivity CodeActivity => codeActivity;

		public virtual IServiceProvider ServiceProvider => throw new NotSupportedException("Not supported in Code Activities.");

		public virtual CodeActivityContext ExecutionContext
		{
			get
			{
				executionContext.Require(nameof(executionContext));
				return executionContext;
			}
		}

		public virtual IExecutionContext Context => context ?? (context = ExecutionContext.GetExtension<IWorkflowContext>());
		public virtual IOrganizationServiceFactory ServiceFactory => serviceFactory
			?? (serviceFactory = ExecutionContext.GetExtension<IOrganizationServiceFactory>());
		public virtual ITracingService TracingService => tracingService
			?? (tracingService = ExecutionContext.GetExtension<ITracingService>());

		public virtual IOrganizationService Service => service ?? (service = ServiceFactory.CreateOrganizationService(UserId));
		public virtual IOrganizationService EscalatedService => escalatedService
			?? (escalatedService = ServiceFactory.CreateOrganizationService(EscalationUserId));

		public virtual string Message => Context.MessageName;
		public virtual PluginStage Stage => throw new NotSupportedException("Not supported in Code Activities.");
		public virtual Guid UserId => userId ?? Context.UserId;

		public virtual Guid EscalationUserId => escalationUserId
			?? (escalationUserId = CrmHelpers.GetGenericConfig(Service, Context.OrganizationId)
				.GetAttributeValue<EntityReference>("ys_escalationuserid")?.Id)
				?? throw new ArgumentNullException(nameof(EscalationUserId), "Escalation User is not set in Common Configuration.");
		
		public virtual string Entity => Context.PrimaryEntityName;
		public virtual Guid Id => Context.PrimaryEntityId;

		public virtual ILogger Log => log;

		public virtual Entity PreImage => preImage ?? (preImage = GetPreImage<Entity>());
		public virtual Entity Target => target ?? (target = GetTarget<Entity>());
		public virtual Entity PostImage
		{
			get
			{
				try
				{
					return postImage ?? (postImage = GetPostImage<Entity>(true));
				}
				catch
				{
					throw new InvalidPluginExecutionException("Missing a post-image for this step.");
				}
			}
		}

		protected TCodeActivity codeActivity;

		private CodeActivityContext executionContext;
		private IWorkflowContext context;
		private IOrganizationServiceFactory serviceFactory;
		private ITracingService tracingService;
		private IOrganizationService service;
		private IOrganizationService escalatedService;

		private Guid? userId;
		private Guid? escalationUserId;

		protected ILogger log;

		private Entity preImage;
		private Entity target;
		private Entity postImage;

		public virtual void Execute(TCodeActivity codeActivity, CodeActivityContext executionContext)
		{
			Execute(codeActivity, executionContext, PluginUser.System);
		}

		public virtual void Execute(TCodeActivity codeActivity, CodeActivityContext executionContext,
			bool isLogEnabled)
		{
			Execute(codeActivity, executionContext, PluginUser.System, null, isLogEnabled);
		}

		public virtual void Execute(TCodeActivity codeActivity, CodeActivityContext executionContext,
			Guid? userId, bool isLogEnabled = true)
		{
			Execute(codeActivity, executionContext, PluginUser.Custom, userId, isLogEnabled);
		}

		public virtual void Execute(TCodeActivity codeActivity, CodeActivityContext executionContext,
			PluginUser user, bool isLogEnabled = true)
		{
			Execute(codeActivity, executionContext, user, null, isLogEnabled);
		}

		public virtual void Execute(TCodeActivity codeActivity, CodeActivityContext executionContext,
			PluginUser user, Guid? userId, bool isLogEnabled = true)
		{
			this.codeActivity = codeActivity;
			this.executionContext = executionContext;
			this.userId = userId;

			InitialiseCodeActivity(user);

			try
			{
				TracingService.Trace("Initialising CRM Log ...");
				log = new PluginLogger(ExecutionContext);

				if (isLogEnabled)
				{
					TracingService.Trace("Log enabled.");

					Log.SetEntryClass(typeof(TCodeActivity).FullName);

					if (Context.PrimaryEntityName != null && Context.PrimaryEntityName != "none"
						&& Context.PrimaryEntityId != Guid.Empty)
					{
						Log.SetRegarding(Context.PrimaryEntityName, Context.PrimaryEntityId);
					}
				}
			}
			catch (Exception ex)
			{
				TracingService.Trace("Failed to init log.");
				TracingService.Trace(CrmHelpers.BuildExceptionMessage(ex));
				throw new InvalidPluginExecutionException("Failed to init Log => " + ex.Message, ex);
			}

			try
			{
				if (isLogEnabled)
				{
					Log.LogExecutionStart();
				}

				TracingService.Trace("Executing step logic ...");
				ExecuteLogic();
				TracingService.Trace("Finished executing step.");
			}
			catch (Exception ex)
			{
				TracingService.Trace($"Exception occurred: {ex.Message}.");

				if (isLogEnabled)
				{
					Log.ExecutionFailed();
					Log.Log(ex);
				}
				else
				{
					TracingService.Trace(CrmHelpers.BuildExceptionMessage(ex));
				}

				throw new InvalidPluginExecutionException(ex.Message, ex);
			}
			finally
			{
				if (isLogEnabled)
				{
					TracingService.Trace("Logging execution end ...");

					try
					{
						Log.LogExecutionEnd();
					}
					catch (Exception e)
					{
						TracingService.Trace(CrmHelpers.BuildExceptionMessage(e));
						throw;
					}
				}

				TracingService.Trace("Finished executing step.");
			}
		}

		protected abstract void ExecuteLogic();

		protected TEntity GetPreImage<TEntity>() where TEntity : Entity
		{
			if (Context.PreEntityImages.TryGetValue("PreBusinessEntity", out var image))
			{
				return image.ToEntity<TEntity>();
			}

			throw new InvalidPluginExecutionException("Missing a pre-image for this step.");
		}

		protected TEntity GetTarget<TEntity>() where TEntity : Entity
		{
			throw new InvalidPluginExecutionException("The Target parameter should not be accessed in a step.");
		}

		protected TEntity GetPostImage<TEntity>(bool retrieveIfMissing = false, ColumnSet columns = null) where TEntity : Entity
		{
			if (Context.PostEntityImages.TryGetValue("PostBusinessEntity", out var image))
			{
				return image.ToEntity<TEntity>();
			}

			if (retrieveIfMissing)
			{
				return service.Retrieve(Context.PrimaryEntityName, Context.PrimaryEntityId, columns == null ? new ColumnSet(true) : columns)
					.ToEntity<TEntity>();
			}

			throw new InvalidPluginExecutionException("Missing a post-image for this step.");
		}

		protected TEntity GetPostPreImage<TEntity>(bool retrieveIfMissing = false, ColumnSet columns = null) where TEntity : Entity
		{
			if (Context.PostEntityImages.TryGetValue("PostBusinessEntity", out var image))
			{
				return image.ToEntity<TEntity>();
			}

			if (Context.PreEntityImages.TryGetValue("PreBusinessEntity", out image))
			{
				return image.ToEntity<TEntity>();
			}

			if (retrieveIfMissing)
			{
				return service.Retrieve(Context.PrimaryEntityName, Context.PrimaryEntityId, columns == null ? new ColumnSet(true) : columns)
					.ToEntity<TEntity>();
			}

			throw new InvalidPluginExecutionException("Missing a post or pre-image for this step.");
		}

		protected virtual bool IsContextValid()
		{
			return true;
		}

		protected void InitialiseCodeActivity(PluginUser user = PluginUser.System)
		{
			tracingService = ExecutionContext.GetExtension<ITracingService>();
			context = ExecutionContext.GetExtension<IWorkflowContext>();
			TracingService.Trace("Got context.");
			serviceFactory = ExecutionContext.GetExtension<IOrganizationServiceFactory>();
			TracingService.Trace("Got factory.");

			switch (user)
			{
				case PluginUser.ContextUser:
					userId = context.UserId;
					TracingService.Trace("Running as ContextUser.");
					break;

				case PluginUser.InitiatingUser:
					userId = context.InitiatingUserId;
					TracingService.Trace("Running as InitiatingUserId.");
					break;

				case PluginUser.System:
					userId = null;
					TracingService.Trace("Running as System.");
					break;

				case PluginUser.Custom:
					TracingService.Trace($"Running as {userId}.");
					break;

				default:
					throw new ArgumentOutOfRangeException("user", user, "Step user type is out of range.");
			}

			service = ServiceFactory.CreateOrganizationService(userId);
			TracingService.Trace("Got service.");

			if (!IsContextValid())
			{
				throw new InvalidPluginExecutionException("Failed to initialise workflow step due to invalid context.");
			}

			TracingService.Trace($"Initialised step.");
		}
	}

	#endregion
}

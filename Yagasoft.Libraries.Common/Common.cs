// This file isn't generated, but this comment is necessary to exclude it from StyleCop analysis.
// Author: Ahmed Elsawalhy (Yagasoft.com)
// Version: 5.2.1
// <auto-generated />

#region Imports

using System;
using System.Activities;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Data;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Reflection;
using System.Runtime.Caching;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using System.Runtime.Serialization.Json;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using System.Xml;
using System.Xml.Serialization;
using Microsoft.Crm.Sdk.Messages;
using Microsoft.Xrm.Sdk;
using Microsoft.Xrm.Sdk.Client;
using Microsoft.Xrm.Sdk.Messages;
using Microsoft.Xrm.Sdk.Metadata;
using Microsoft.Xrm.Sdk.Metadata.Query;
using Microsoft.Xrm.Sdk.Query;
using Microsoft.Xrm.Sdk.Workflow;
using Match = System.Text.RegularExpressions.Match;
using RelationshipType = Microsoft.Xrm.Sdk.Metadata.RelationshipType;

#endregion

namespace Yagasoft.Libraries.Common
{

	#region Enums

	/// <summary>
	///     The log levels
	/// </summary>
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public enum LogLevel
	{
		None = 0,
		Error = 10,
		Warning = 20,
		Info = 30,
		Debug = 40
	}

	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public enum LogMode
	{
		Crm = 10,
		File = 20,
		Both = 30
	}

	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public enum SplitMode
	{
		Size = 10,
		Date = 20,
		Both = 30
	}

	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public enum SplitFrequency
	{
		Hourly = 10,
		Daily = 20,
		Monthly = 30,
		Yearly = 40
	}

	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public enum PluginUser
	{
		ContextUser,
		InitiatingUser,
		System,
		Custom
	}

	#endregion

	#region Extensions

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static partial class Extensions
	{
		private const string StringExceptionMsg = "String value cannot be empty.";
		private const string DefaultStringFormatExceptionMsg = "String format is invalid.";
		private const string DefaultNullExceptionMessage = "Value cannot be null.";
		private const string DefaultRangeMessage = "Parameter value out of range.";
		private const string DefaultArrayMemberMessage = "Array member can't be null.";
		private const string DefaultParameterName = "Unknown";
		private const string RegexEscapes = @"[\a\b\f\n\r\t\v\\""]";

		/// <summary>
		/// Return the distinct values of the source collection using the key returned by a selector function.<br />
		/// Credit: https://stackoverflow.com/a/24823445/1919456<br />
		/// </summary>
		public static IEnumerable<TSource> DistinctBy<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> selector)
		{
			var set = new HashSet<TResult>();

			foreach (var item in source)
			{
				var selectedValue = selector(item);

				if (set.Add(selectedValue))
				{
					yield return item;
				}
			}
		}

		#region Dates

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static DateTime ConvertToCrmUserTimeZone(this DateTime dateTime, IOrganizationService service, Guid userId)
		{
			var bias = CrmHelpers.GetUserTimeZoneBiasMinutes(service, userId);
			var biasedDate = dateTime.AddMinutes(bias);

			return DateTime.SpecifyKind(biasedDate, DateTimeKind.Local);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static DateTime ConvertToCrmUtcTimeZone(this DateTime dateTime, IOrganizationService service, Guid userId)
		{
			var bias = CrmHelpers.GetUserTimeZoneBiasMinutes(service, userId);
			var biasedDate = dateTime.AddMinutes(-bias);

			return DateTime.SpecifyKind(biasedDate, DateTimeKind.Utc);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static DateTime ConvertBetweenCrmUsersTimeZone(this DateTime dateTime, IOrganizationService service,
			Guid user1Id, Guid user2Id)
		{
			var biases = CrmHelpers.GetUsersTimeZoneBiasMinutes(service, user1Id, user2Id);
			var bias1 = biases[user1Id];
			var bias2 = biases[user2Id];

			var biasedDate = dateTime.AddMinutes(-bias1).AddMinutes(bias2);

			return DateTime.SpecifyKind(biasedDate, DateTimeKind.Local);
		}

		#endregion

		// Credit: http://www.codeproject.com/Articles/290695/Extension-methods-to-simplify-null-argument-check

		#region Param checks

		#region NULL CHECK FOR OBJECT OF ANY CLASS

		/// <summary>
		///     Generic extension method that throws ArgumentNullException if target object is null.
		///     The method is constrained to objects of class type. The method is intended to be used
		///     for null parameter check.
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <typeparam name="T">Type of parameter</typeparam>
		/// <param name="obj">Target object of type T</param>
		/// <param name="paramName">
		///     Name of the parameter.If paramName name is null empty or whitespace default value will be
		///     paramNmae = "Unknown".
		/// </param>
		/// <param name="message">Exception message.If not provided default value is "Value can not be null."</param>
		public static void Require<T>(this T obj, string paramName = DefaultParameterName,
			string message = DefaultNullExceptionMessage)
			where T : class
		{
			if (obj == null)
			{
				ThrowArgumentNullException(ref paramName, ref message);
			}
		}

		#endregion NULL CHECK FOR OBJECT OF ANY CLASS

		#region NULL CHECK FOR OBJECT OF NULLABLE TYPE

		/// <summary>
		///     Generic extension method that throws ArgumentNullException if target object is null.
		///     The method is constrained to objects of class type. The method is intended to be used
		///     for null parameter check.
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <typeparam name="T">Type of parameter</typeparam>
		/// <param name="obj">Target object of type T</param>
		/// <param name="paramName">
		///     Name of the parameter.If paramName name is null empty or whitespace default value will be
		///     paramNmae = "Unknown".
		/// </param>
		/// <param name="message">Exception message.If not provided default value is "Value can not be null."</param>
		public static void Require<T>(this T? obj, string paramName = DefaultParameterName,
			string message = DefaultNullExceptionMessage)
			where T : struct
		{
			if (obj == null)
			{
				ThrowArgumentNullException(ref paramName, ref message);
			}
		}

		/// <summary>
		///     Generic extension method that throws ArgumentNullException if type value is null.
		///     The method is constrained to objects of Nullable struct type. The method is intended to be used
		///     for null parameter check.
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <typeparam name="T">Type of target object</typeparam>
		/// <param name="obj">Target object of type T.</param>
		/// <param name="paramName">
		///     Name of the parameter.if pramName is null empty or whitespace default paramName = "Unknown"
		///     will be used.
		/// </param>
		/// <param name="message">Exception message.If not provoided default value is "Value can not be null."</param>
		public static void RequireValue<T>(this T obj, string paramName = DefaultParameterName,
			string message = DefaultNullExceptionMessage)
			where T : struct
		{
			if (obj.Equals(default(T)))
			{
				ThrowArgumentNullException(ref paramName, ref message);
			}
		}

		#endregion NULL CHECK FOR OBJECT OF NULLABLE TYPE

		#region NULL CHECK FOR OBJECT ARRAY

		/// <summary>
		///     Method throws ArgumentNullException if any of object reference in array is null.
		///     Note : Using value types in array may result in unnecessary boxing.
		///     Use only when you do not care about message , parameter name and empty/whitespace string.
		///     Certainly not enough for production quality code.
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="value">Object array containing target object references.</param>
		/// <param name="paramName"></param>
		/// <param name="message"></param>
		public static void RequireElements<TV>(this IEnumerable<TV> value, string paramName = DefaultParameterName,
			string message = DefaultArrayMemberMessage)
		{
			value.Require(paramName);

			if (value.Any(param => param == null))
			{
				ThrowArgumentNullException(ref paramName, ref message);
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireCountBelow<T>(this T collection, int max, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : ICollection
		{
			if (collection == null)
			{
				var messageTemp = string.Intern(DefaultNullExceptionMessage);
				ThrowArgumentNullException(ref paramName, ref messageTemp);
				return;
			}

			if (collection.Count >= max)
			{
				message = $@"Collection count must be less than ""{max}"".";
				ThrowArgumentOutOfRangeException(ref paramName, collection, ref message, collection.Count);
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireCountAtMost<T>(this T collection, int max, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : ICollection
		{
			if (collection == null)
			{
				var messageTemp = string.Intern(DefaultNullExceptionMessage);
				ThrowArgumentNullException(ref paramName, ref messageTemp);
				return;
			}

			if (collection.Count > max)
			{
				message = string.Format(@"Collection count must be less than or equal to ""{0}"".", max);
				ThrowArgumentOutOfRangeException(ref paramName, collection, ref message, collection.Count);
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireCountAbove<T>(this T collection, int min, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : ICollection
		{
			if (collection == null)
			{
				var messageTemp = string.Intern(DefaultNullExceptionMessage);
				ThrowArgumentNullException(ref paramName, ref messageTemp);
				return;
			}

			if (collection.Count <= min)
			{
				message = $@"Collection count must be greater than ""{min}"".";
				ThrowArgumentOutOfRangeException(ref paramName, collection, ref message, collection.Count);
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireCountAtLeast<T>(this T collection, int min, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : ICollection
		{
			if (collection == null)
			{
				var messageTemp = string.Intern(DefaultNullExceptionMessage);
				ThrowArgumentNullException(ref paramName, ref messageTemp);
				return;
			}

			if (collection.Count < min)
			{
				message = $@"Collection count must be greater than or equal to ""{min}"".";
				ThrowArgumentOutOfRangeException(ref paramName, collection, ref message, collection.Count);
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireCountInRange<T>(this T collection, int min, int max,
			string paramName = DefaultParameterName, string message = DefaultRangeMessage)
			where T : ICollection
		{
			if (collection == null)
			{
				var messageTemp = string.Intern(DefaultNullExceptionMessage);
				ThrowArgumentNullException(ref paramName, ref messageTemp);
				return;
			}

			if (collection.Count > max && collection.Count < min)
			{
				message = $@"Collection count must be between ""{min}"" and ""{max}"" inclusive.";
				ThrowArgumentOutOfRangeException(ref paramName, collection, ref message, collection.Count);
			}
		}

		#endregion NULL CHECK FOR OBJECT ARRAY

		#region Null, format, and empty check for strings

		/// <summary>
		///     Extension method that throws ArgumentNullException if target string is null , empty or whitespace.
		///     The method is constrained to objects of string type. The method is intended to be used
		///     for null parameter check.
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="value">Target string object</param>
		/// <param name="paramName">
		///     Name of the parameter.if pramName is null empty or whitespace default paramName = "Unknown"
		///     will be used.
		/// </param>
		/// <param name="message">
		///     Exception message.If not provided default value is "String value can not be null , empty of white
		///     space."
		/// </param>
		public static void Require(this string value, string paramName = DefaultParameterName,
			string message = DefaultNullExceptionMessage)
		{
			if (value == null)
			{
				ThrowArgumentNullException(ref paramName, ref message);
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireFilled(this string value, string paramName = DefaultParameterName,
			string message = StringExceptionMsg)
		{
			value.RequireNotEmpty(paramName, message);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireNotEmpty(this string value, string paramName = DefaultParameterName,
			string message = StringExceptionMsg)
		{
			value.Require(paramName);

			if (string.IsNullOrWhiteSpace(value))
			{
				ThrowArgumentNullException(ref paramName, ref message);
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireFormat(this string value, string regex, string paramName = DefaultParameterName,
			string message = DefaultStringFormatExceptionMsg)
		{
			value.Require(paramName);

			if (!Regex.IsMatch(value, regex))
			{
				ThrowArgumentFormatException(ref message, ref paramName, ref regex);
			}
		}

		#endregion

		#region Range check for comparables

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireBelow<T>(this T number, T max, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : IComparable
		{
			if (number.CompareTo(max) >= 0)
			{
				message = $@"Parameter must be less than ""{max}"".";
				ThrowArgumentOutOfRangeException(ref paramName, number, ref message);
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireAtMost<T>(this T number, T max, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : IComparable
		{
			if (number.CompareTo(max) > 0)
			{
				message = $@"Parameter must be less than or equal to ""{max}"".";
				ThrowArgumentOutOfRangeException(ref paramName, number, ref message);
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireAbove<T>(this T number, T min, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : IComparable
		{
			if (number.CompareTo(min) <= 0)
			{
				message = $@"Parameter must be greater than ""{min}"".";
				ThrowArgumentOutOfRangeException(ref paramName, number, ref message);
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireAtLeast<T>(this T number, T min, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : IComparable
		{
			if (number.CompareTo(min) < 0)
			{
				message = $@"Parameter must be greater than or equal to ""{min}"".";
				ThrowArgumentOutOfRangeException(ref paramName, number, ref message);
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RequireInRange<T>(this T number, T min, T max, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : IComparable
		{
			if (number.CompareTo(min) < 0 || number.CompareTo(max) > 0)
			{
				message = $@"Parameter must be between ""{min}"" and ""{max}"" inclusive.";
				ThrowArgumentOutOfRangeException(ref paramName, number, ref message);
			}
		}

		#endregion

		#endregion

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsEmpty(this IEnumerable e)
		{
			return !e.IsFilled();
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsFilled(this IEnumerable e)
		{
			return e?.Cast<object>().Any() == true;
		}

		#region Strings

		/// <summary>
		///     Credit: http://stackoverflow.com/a/6724896/1919456 <br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string Truncate(this string value, int maxChars, string replacement)
		{
			return value.Length <= maxChars ? value : value.Substring(0, maxChars) + replacement;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsEmpty(this string str)
		{
			return string.IsNullOrWhiteSpace(str);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsFilled(this string str)
		{
			return !str.IsEmpty();
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsNotEmpty(this string str)
		{
			return str.IsFilled();
		}

		/// <summary>
		///     Credit: http://stackoverflow.com/a/323670/1919456 <br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string StringLiteral(this string value)
		{
			var replaceDict =
				new Dictionary<string, string>
				{
					["\a"] = @"\a",
					["\b"] = @"\b",
					["\f"] = @"\f",
					["\n"] = @"\n",
					["\r"] = @"\r",
					["\t"] = @"\t",
					["\v"] = @"\v",
					["\0"] = @"\0",
					["\""] = @"\""",
					["\\"] = @"\\"
				};

			return replaceDict.Keys.Aggregate(value, (current, key) => current.Replace(key, replaceDict[key]));
		}

		/// <summary>
		///     Credit: http://stackoverflow.com/a/323670/1919456 <br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string StringUnliteral(this string value)
		{
			var replaceDict =
				new Dictionary<string, string>
				{
					[@"\a"] = "\a",
					[@"\b"] = "\b",
					[@"\f"] = "\f",
					[@"\n"] = "\n",
					[@"\r"] = "\r",
					[@"\t"] = "\t",
					[@"\v"] = "\v",
					[@"\0"] = "\0",
					[@"\"""] = "\"",
					[@"\\"] = "\\"
				};

			return replaceDict.Keys.Aggregate(value, (current, key) => current.Replace(key, replaceDict[key]));
		}

		/// <summary>
		///     Compresses a string and returns a deflate compressed, Base64 encoded string.<br />
		///     Credit: https://stackoverflow.com/a/43357353/1919456<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="uncompressedValue">String to compress</param>
		public static string Compress(this string uncompressedValue)
		{
			using (var compressedStream = new MemoryStream())
			{
				using (var uncompressedStream = new MemoryStream(Encoding.UTF8.GetBytes(uncompressedValue)))
				{
					using (var compressorStream = new DeflateStream(compressedStream, CompressionLevel.Optimal, false))
					{
						uncompressedStream.CopyTo(compressorStream);
					}
				}

				return Convert.ToBase64String(compressedStream.ToArray());
			}
		}

		/// <summary>
		///     Decompresses a deflate compressed, Base64 encoded string and returns an uncompressed string.<br />
		///     Credit: https://stackoverflow.com/a/43357353/1919456<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="compressedValue">String to decompress.</param>
		public static string Decompress(this string compressedValue)
		{
			using (var decompressedStream = new MemoryStream())
			{
				using (var compressedStream = new MemoryStream(Convert.FromBase64String(compressedValue)))
				{
					using (var decompressorStream = new DeflateStream(compressedStream, CompressionMode.Decompress))
					{
						decompressorStream.CopyTo(decompressedStream);
						return Encoding.UTF8.GetString(decompressedStream.ToArray());
					}
				}
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string CharLiteral(this char c)
		{
			return c == '\'' ? @"'\''" : string.Format("'{0}'", c);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string XmlEscape(this string unescaped)
		{
			var doc = new XmlDocument();
			XmlNode node = doc.CreateElement("root");
			node.InnerText = unescaped;
			return node.InnerXml;
		}

		#endregion

		#region METHOD THAT ACTUALLY THROWS EXCEPTION

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		private static void ThrowArgumentNullException(ref string paramName, ref string message)
		{
			throw new ArgumentNullException(paramName, message);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		private static void ThrowArgumentOutOfRangeException(ref string paramName, object number, ref string message,
			int currentCount = -1)
		{
			throw new ArgumentOutOfRangeException(paramName, number,
				message + ((currentCount >= 0) ? " Current size is " + currentCount : string.Empty));
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		private static void ThrowArgumentFormatException(ref string paramName, ref string message, ref string regex)
		{
			throw new ArgumentException(message + " Format: " + regex, paramName);
		}

		#endregion METHOD THAT ACTUALLY THROWS EXCEPTION

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsNumeric(this object obj)
		{
			switch (Type.GetTypeCode(obj.GetType()))
			{
				case TypeCode.Byte:
				case TypeCode.SByte:
				case TypeCode.UInt16:
				case TypeCode.UInt32:
				case TypeCode.UInt64:
				case TypeCode.Int16:
				case TypeCode.Int32:
				case TypeCode.Int64:
				case TypeCode.Decimal:
				case TypeCode.Double:
				case TypeCode.Single:
					return true;
				default:
					return false;
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsDateTime(this object obj)
		{
			return Type.GetTypeCode(obj.GetType()) == TypeCode.DateTime;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string StringAggregate<TV>(this IEnumerable<TV> collection, string separator = ",")
		{
			if (collection?.Any() != true)
			{
				return string.Empty;
			}

			return collection.Select(e => e is string eString ? eString : e.ToString()).Aggregate((e1, e2) => $"{e1}{separator}{e2}");
		}

		/// <summary>
		/// Credit: Microsoft.Xrm.Client assembly
		/// </summary>
		public static TValue FirstNotNullOrDefault<TKey, TValue>(this IDictionary<TKey, TValue> dictionary, params TKey[] keys)
			=> keys
				.Where(dictionary.ContainsKey)
				.Select(key => dictionary[key])
				.FirstOrDefault();

		/// <summary>
		/// Credit: Microsoft.Xrm.Client assembly
		/// </summary>
		public static string FirstNotNullOrEmpty<TKey>(this IDictionary<TKey, string> dictionary, params TKey[] keys)
			=> (keys)
				.Where(key => dictionary.ContainsKey(key) && !string.IsNullOrEmpty(dictionary[key]))
				.Select(key => dictionary[key])
				.FirstOrDefault();
	}

	#endregion

	// -----------------------------------------------------------------------------------------------------------------------------------------------------------------
	//
	// Copyright (c) 2016 Bas van de Sande - JourneyIntoCRM - http://journeyintocrm.com
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
	// to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
	// and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	//
	// -----------------------------------------------------------------------------------------------------------------------------------------------------------------
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class EntitySerializer
	{
		public static string SerializeObject(Entity entity)
		{
			var ds = new DataSet("XmlData");
			var dt = new DataTable(entity.LogicalName);
			ConvertEntityToDataTable(dt, entity);
			ds.Tables.Add(dt);

			return ds.GetXml();
		}

		public static Entity DeserializeObject(string xml)
		{
			var dataSet = new DataSet();

			var xmlBytes = Encoding.UTF8.GetBytes(xml);

			using (var ms = new MemoryStream(xmlBytes))
			{
				dataSet.ReadXml(ms);
			}

			if (dataSet.Tables.Count <= 0)
			{
				return null;
			}

			var dt = dataSet.Tables[0];

			if (dt.Rows.Count <= 0)
			{
				return null;
			}

			var entity = new Entity(dt.TableName);
			var row = dt.Rows[0];

			foreach (DataColumn column in dt.Columns)
			{
				if (column.ColumnName == "Id")
				{
					entity.Id = (Guid?)SetAttributeValue(row[column.ColumnName]) ?? Guid.Empty;
				}
				else
				{
					entity[column.ColumnName] = SetAttributeValue(row[column.ColumnName]);
				}
			}

			return entity;
		}

		private static void ConvertEntityToDataTable(DataTable dataTable, Entity entity)
		{
			var row = dataTable.NewRow();
			dataTable.Columns.Add("Id");
			row["Id"] = GetAttributeValue(entity.Id);

			foreach (var attribute in entity.Attributes.Where(a => a.Value != null))
			{
				if (!dataTable.Columns.Contains(attribute.Key))
				{
					dataTable.Columns.Add(attribute.Key);
				}

				row[attribute.Key] = GetAttributeValue(attribute.Value);
			}

			foreach (var fv in entity.FormattedValues)
			{
				if (!dataTable.Columns.Contains(fv.Key + "name"))
				{
					dataTable.Columns.Add(fv.Key + "name");
				}

				row[fv.Key + "name"] = fv.Value;
			}

			dataTable.Rows.Add(row);
		}

		private static string GetAttributeValue(object entityValue)
		{
			string objectValue;
			var objectReference = "";
			var objectType = entityValue.GetType().FullName;

			if (entityValue is EntityReference)
			{
				objectValue = ((EntityReference)entityValue).Id.ToString();
				objectReference = ((EntityReference)entityValue).LogicalName;
			}
			else if (entityValue is OptionSetValue)
			{
				objectValue = ((OptionSetValue)entityValue).Value.ToString();
			}
			else if (entityValue is Money)
			{
				objectValue = Convert.ToString(((Money)entityValue).Value, CultureInfo.InvariantCulture.NumberFormat);
			}
			else if (entityValue is AliasedValue)
			{
				var av = (AliasedValue)entityValue;
				objectValue = GetAttributeValue(av.Value);
				objectReference = $"{av.EntityLogicalName},{av.AttributeLogicalName}";
			}
			else if (entityValue is Guid)
			{
				objectValue = entityValue.ToString();
			}
			else
			{
				if (entityValue.IsNumeric())
				{
					objectValue = Convert.ToString(entityValue, CultureInfo.InvariantCulture.NumberFormat);
				}
				else if (entityValue.IsDateTime())
				{
					objectValue = ((DateTime)entityValue).ToUniversalTime().ToString("u");
				}
				else
				{
					objectValue = entityValue.ToString();
				}
			}

			if (!string.IsNullOrWhiteSpace(objectReference))
			{
				objectReference += ",";
			}

			return $"{objectType}|{objectReference}{objectValue}";
		}

		private static object SetAttributeValue(object val)
		{
			if (val == null)
			{
				return null;
			}

			var input = val.ToString();
			var tokens = input.Split('|');

			if (tokens.Length != 2)
			{
				return null;
			}

			if (tokens[0].Equals(typeof(EntityReference).FullName))
			{
				var er = tokens[1].Split(',');
				if (er.Length == 2)
				{
					return new EntityReference(er[0], new Guid(er[1]));
				}
			}
			else if (tokens[0].Equals(typeof(OptionSetValue).FullName))
			{
				int i;
				int.TryParse(tokens[1], out i);
				if (i != int.MinValue)
				{
					return new OptionSetValue(i);
				}
			}
			else if (tokens[0].Equals(typeof(Money).FullName))
			{
				decimal d;
				decimal.TryParse(tokens[1], NumberStyles.AllowDecimalPoint, NumberFormatInfo.InvariantInfo, out d);
				if (d != decimal.MinValue)
				{
					return new Money(d);
				}
			}
			else if (tokens[0].Equals(typeof(AliasedValue).FullName))
			{
				var av = tokens[1].Split(',');
				if (av.Length == 3)
				{
					return new AliasedValue(av[0], av[1], SetAttributeValue(av[2]));
				}
			}
			else if (tokens[0].Equals(typeof(Guid).FullName))
			{
				Guid g;
				Guid.TryParse(tokens[1], out g);
				if (g != Guid.Empty)
				{
					return g;
				}
			}
			else if (tokens[0].Equals(typeof(DateTime).FullName))
			{
				DateTime dt;
				DateTime.TryParse(tokens[1], out dt);
				if (dt != DateTime.MinValue)
				{
					return dt.ToUniversalTime();
				}
			}
			else if (tokens[0].Equals(typeof(int).FullName))
			{
				int i32;
				int.TryParse(tokens[1], out i32);
				if (i32 != int.MinValue)
				{
					return i32;
				}
			}
			else if (tokens[0].Equals(typeof(bool).FullName))
			{
				return (tokens[1].ToUpper() == "TRUE");
			}
			else if (tokens[0].Equals(typeof(decimal).FullName))
			{
				decimal sd;
				decimal.TryParse(tokens[1], NumberStyles.AllowDecimalPoint, NumberFormatInfo.InvariantInfo, out sd);
				if (sd != decimal.MinValue)
				{
					return sd;
				}
			}
			else
			{
				// all other values
				return tokens[1];
			}

			return null;
		}
	}

	/// <summary>
	///     Reference Article http://www.codeproject.com/KB/tips/SerializedObjectCloner.aspx
	///     Provides a method for performing a deep copy of an object.
	///     Binary Serialization is used to perform the copy.
	///		Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class ObjectCopier
	{
		/// <summary>
		///     Perform a deep Copy of the object.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <typeparam name="T">The type of object being copied.</typeparam>
		/// <param name="source">The object instance to copy.</param>
		/// <returns>The copied object.</returns>
		public static T Clone<T>(this T source) where T : ISerializable
		{
			if (source == null)
			{
				return default(T);
			}

			IFormatter formatter = new BinaryFormatter();
			Stream stream = new MemoryStream();

			using (stream)
			{
				formatter.Serialize(stream, source);
				stream.Seek(0, SeekOrigin.Begin);
				return (T)formatter.Deserialize(stream);
			}
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class ObjectExtensions
	{
		private static readonly MethodInfo cloneMethod = typeof(object).GetMethod("MemberwiseClone",
			BindingFlags.NonPublic | BindingFlags.Instance);

		public static bool IsPrimitive(this Type type)
		{
			if (type == typeof(string))
			{
				return true;
			}

			return type.IsValueType & type.IsPrimitive;
		}

		public static T Copy<T>(this T original)
		{
			return (T)Copy((object)original);
		}

		private static object Copy(object originalObject)
		{
			return InternalCopy(originalObject, new Dictionary<object, object>(new ReferenceEqualityComparer()));
		}

		private static object InternalCopy(object originalObject, IDictionary<object, object> visited)
		{
			if (originalObject == null)
			{
				return null;
			}

			var typeToReflect = originalObject.GetType();

			if (IsPrimitive(typeToReflect))
			{
				return originalObject;
			}

			if (visited.ContainsKey(originalObject))
			{
				return visited[originalObject];
			}

			if (typeof(Delegate).IsAssignableFrom(typeToReflect))
			{
				return null;
			}

			var cloneObject = cloneMethod.Invoke(originalObject, null);

			if (typeToReflect.IsArray)
			{
				var arrayType = typeToReflect.GetElementType();

				if (IsPrimitive(arrayType) == false)
				{
					var clonedArray = (Array)cloneObject;
					clonedArray.ForEach((array, indices) => array.SetValue(InternalCopy(clonedArray.GetValue(indices), visited), indices));
				}
			}

			visited.Add(originalObject, cloneObject);
			CopyFields(originalObject, visited, cloneObject, typeToReflect);
			RecursiveCopyBaseTypePrivateFields(originalObject, visited, cloneObject, typeToReflect);

			return cloneObject;
		}

		private static void RecursiveCopyBaseTypePrivateFields(object originalObject, IDictionary<object, object> visited,
			object cloneObject, Type typeToReflect)
		{
			if (typeToReflect.BaseType == null)
			{
				return;
			}

			RecursiveCopyBaseTypePrivateFields(originalObject, visited, cloneObject, typeToReflect.BaseType);
			CopyFields(originalObject, visited, cloneObject, typeToReflect.BaseType,
				BindingFlags.Instance | BindingFlags.NonPublic, info => info.IsPrivate);
		}

		private static void CopyFields(object originalObject, IDictionary<object, object> visited, object cloneObject,
			IReflect typeToReflect,
			BindingFlags bindingFlags =
				BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.FlattenHierarchy,
			Func<FieldInfo, bool> filter = null)
		{
			foreach (var fieldInfo in typeToReflect.GetFields(bindingFlags))
			{
				if (filter != null && filter(fieldInfo) == false)
				{
					continue;
				}

				if (IsPrimitive(fieldInfo.FieldType))
				{
					continue;
				}

				var originalFieldValue = fieldInfo.GetValue(originalObject);
				var clonedFieldValue = InternalCopy(originalFieldValue, visited);
				fieldInfo.SetValue(cloneObject, clonedFieldValue);
			}
		}

		public static void CopyValuesFrom(this object self, object parent, bool isDeepCopy = false)
		{
			var bindingFlags = BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.FlattenHierarchy;
			var fromFields = parent.GetType().GetFields(bindingFlags);
			var toFields = self.GetType().GetFields(bindingFlags);

			foreach (var fromField in fromFields)
			{
				var toField = toFields.FirstOrDefault(f => fromField.Name == f.Name && fromField.FieldType == f.FieldType);
				var value = fromField.GetValue(parent);
				toField?.SetValue(self, isDeepCopy ? value.Copy() : value);
			}
		}
	}

	#region Helpers

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public class GenericEqualityComparer<T> : EqualityComparer<T>
	{
		private readonly Func<T, T, bool> equator;
		private readonly Func<T, int> hasher;

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public GenericEqualityComparer(Func<T, T,bool> equator, Func<T, int> hasher = null)
		{
			equator.Require(nameof(equator));
			this.equator = equator;
			this.hasher = hasher;
		}

		public override bool Equals(T x, T y)
		{
			return equator(x, y);
		}

		public override int GetHashCode(T obj)
		{
			return hasher == null ? obj.GetHashCode() : hasher(obj);
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public class ReferenceEqualityComparer : EqualityComparer<object>
	{
		public override bool Equals(object x, object y)
		{
			return ReferenceEquals(x, y);
		}

		public override int GetHashCode(object obj)
		{
			return obj.GetHashCode();
		}
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class ArrayExtensions
	{
		public static void ForEach(this Array array, Action<Array, int[]> action)
		{
			if (array.LongLength == 0)
			{
				return;
			}

			var walker = new ArrayTraverse(array);

			do
			{
				action(array, walker.Position);
			}
			while (walker.Step());
		}

		private class ArrayTraverse
		{
			public int[] Position;
			private readonly int[] maxLengths;

			public ArrayTraverse(Array array)
			{
				maxLengths = new int[array.Rank];

				for (var i = 0; i < array.Rank; ++i)
				{
					maxLengths[i] = array.GetLength(i) - 1;
				}

				Position = new int[array.Rank];
			}

			public bool Step()
			{
				for (var i = 0; i < Position.Length; ++i)
				{
					if (Position[i] >= maxLengths[i])
					{
						continue;
					}

					Position[i]++;

					for (var j = 0; j < i; j++)
					{
						Position[j] = 0;
					}

					return true;
				}
				return false;
			}
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class StringHelpers
	{
		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string ToSentenceCase(this string input)
		{
			return Regex.Replace(
				input,
				@"(?<=(^|\.\s+))[a-z](?=[^A-Z]*(\.$|$|\.\s+|\s))",
				m => m.Value.ToUpper());
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string ToTitleCase(this string input)
		{
			return Regex.Replace(
				input,
				@"(?:^[a-z]|\.\s*[a-z]|\b(?!a|aboard|about|above|across|after|against|along|although|amid|among|an|and|anti|around|as|at|because|before|behind|below|beneath|beside|besides|between|beyond|both|but|by|concerning|consequently|considering|despite|down|during|either|even|except|excepting|excluding|finally|following|for|from|furthermore|hardly|hence|however|if|in|incidentally|indeed|inside|instead|into|lest|like|likewise|meanwhile|minus|near|neither|nor|now|of|off|on|once|onto|opposite|or|outside|over|past|per|plus|provided|rather|regarding|round|save|since|so|such|supposing|than|that|the|though|through|till|to|toward|towards|under|underneath|unless|unlike|until|up|upon|versus|via|when|whenever|where|whereas|wherever|whether|which|while|who|whoever|why|with|within|without|yet)[a-z])",
				m => m.Value.ToUpper());
		}

		/// <summary>
		/// Credit: https://stackoverflow.com/a/25513964/1919456
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string ReplaceGroup(this string input, string pattern, string replacement, RegexOptions? options = null)
		{
			return input.ReplaceGroups(pattern, _ => replacement, options);
		}

		/// <summary>
		/// Credit: https://stackoverflow.com/a/25513964/1919456
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string ReplaceGroup(this string input, string pattern, string groupName, string replacement, RegexOptions? options = null)
		{
			return input.ReplaceGroups(pattern, new Dictionary<string, string> { { groupName, replacement } }, options);
		}

		/// <summary>
		/// Credit: https://stackoverflow.com/a/25513964/1919456
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="replacementMap">Key-value pairs of group name and replacement</param>
		public static string ReplaceGroups(this string input, string pattern, IDictionary<string, string> replacementMap,
			RegexOptions? options = null)
		{
			return input.ReplaceGroups(pattern, replacementMap.ToDictionary(p => p.Key, p => new Func<string, string>(s => p.Value)));
		}

		/// <summary>
		/// Credit: https://stackoverflow.com/a/25513964/1919456
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string ReplaceGroups(this string input, string pattern, Func<string, string> replacementAction, RegexOptions? options = null)
		{
			var match = Regex.Match(input, pattern, options ?? RegexOptions.None);

			if (!match.Success)
			{
				return input;
			}

			var replacementMap = (match.Groups.Count > 1 ? match.Groups.Cast<Group>().Skip(1) : match.Groups.Cast<Group>())
				.ToDictionary(g => g.Index.ToString(), _ => replacementAction);

			return input.ReplaceGroups(pattern, replacementMap, options);
		}

		/// <summary>
		/// Credit: https://stackoverflow.com/a/25513964/1919456
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="replacementMap">Key-value pairs of group name and replacement</param>
		public static string ReplaceGroups(this string input, string pattern, IDictionary<string, Func<string, string>> replacementMap,
			RegexOptions? options = null)
		{
			return Regex
				.Replace(
					input,
					pattern,
					m =>
					{
						var sb = new StringBuilder();

						var groupMap = replacementMap
							.Select(g => new { group = g.Key == "-1" ? m.Groups[0] : m.Groups[g.Key], replacement = g.Value })
							.Where(g => g.group != null)
							.OrderBy(g => g.group.Index);

						var previousCaptureEnd = 0;

						foreach (var groupMapping in groupMap)
						{
							var group = groupMapping.group;
							var replacement = groupMapping.replacement;

							foreach (var capture in group.Captures.Cast<Capture>())
							{
								var currentCaptureEnd = capture.Index + capture.Length - m.Index;
								var currentCaptureLength = capture.Index - m.Index - previousCaptureEnd;
								sb.Append(m.Value.Substring(previousCaptureEnd, currentCaptureLength));
								sb.Append(replacement(capture.Value));
								previousCaptureEnd = currentCaptureEnd;
							}
						}

						sb.Append(m.Value.Substring(previousCaptureEnd));

						return sb.ToString();
					}, options ?? RegexOptions.None);
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class RegexHelpers
	{
		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IEnumerable<string> ExtractCaptures(this Group group)
		{
			return group.Captures.OfType<Capture>().Select(c => c.Value);
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class CollectionHelpers
	{
		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IEnumerable<TV> FilterNull<TV>(this IEnumerable<TV> collection)
		{
			return collection?.Where(e => e != null);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IEnumerable<TV> FilterEmpty<TV>(this IEnumerable<TV> collection)
		{
			return collection?
				.FilterNull()
				.Where(e => (!(e is string stringValue) || stringValue.IsFilled())
					&& (!(e is IEnumerable ee) || ee.IsFilled()));
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IDictionary<TU, TV> FilterNull<TU, TV>(this IDictionary<TU, TV> dictionary)
		{
			return dictionary?.Where(e => e.Value != null).ToDictionary(p => p.Key, p => p.Value);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IDictionary<TU, TV> FilterEmpty<TU, TV>(this IDictionary<TU, TV> dictionary)
		{
			return dictionary?
				.Where(e => (!(e.Value is string stringValue) || stringValue.IsFilled())
					&& (!(e.Value is IEnumerable ee) || ee.IsFilled()))
				.ToDictionary(p => p.Key, p => p.Value);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool In<TObject>(this TObject obj, IEnumerable<TObject> collection)
			where TObject : class
		{
			return collection != null && collection.Contains(obj);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool ValueIn<TObject>(this TObject obj, IEnumerable<TObject> collection)
			where TObject : struct
		{
			return collection != null && collection.Contains(obj);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool In<TObject, TKey>(this TObject obj, IDictionary<TKey, TObject> dictionary)
			where TObject : class
		{
			return obj.In(dictionary.Values);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool ValueIn<TObject, TKey>(this TObject obj, IDictionary<TKey, TObject> dictionary)
			where TObject : struct
		{
			return obj.ValueIn(dictionary.Values);
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class TypeHelpers
	{
		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static Type[] GetHierarchyTree(this Type type)
		{
			return
				CacheHelpers
					.GetFromMemCacheAdd(
						$"Yagasoft.Common.TypeHelpers.GetHierarchyTree|{type?.FullName}",
						() => AppDomain.CurrentDomain.GetAssemblies().SelectMany(e => e.GetTypes())
							.Where(t => type.IsAssignableFrom(t) && !t.IsGenericTypeDefinition).ToArray());
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static Type GetType(string name, Type assemblyScope = null)
		{
			return
				CacheHelpers
					.GetFromMemCacheAdd(
						$"Yagasoft.Common.TypeHelpers.GetType|{name}|{assemblyScope?.FullName}",
						() => assemblyScope == null
							? AppDomain.CurrentDomain.GetAssemblies().SelectMany(a => a.GetTypes())
								.FirstOrDefault(e => e.AssemblyQualifiedName == name || e.FullName == name || e.Name == name)
							: assemblyScope.Assembly.GetTypes()
								.FirstOrDefault(e => e.AssemblyQualifiedName == name || e.FullName == name || e.Name == name));
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static Type GetType(string name, params Assembly[] assembliesScope)
		{
			return
				CacheHelpers
					.GetFromMemCacheAdd(
						$"Yagasoft.Common.TypeHelpers.GetType|{name}|{assembliesScope?.Select(e => e?.FullName).StringAggregate()}",
						() => assembliesScope == null
							? AppDomain.CurrentDomain.GetAssemblies().SelectMany(a => a.GetTypes())
								.FirstOrDefault(e => e.AssemblyQualifiedName == name || e.FullName == name || e.Name == name)
							: assembliesScope.SelectMany(a => a.GetTypes())
								.FirstOrDefault(e => e.AssemblyQualifiedName == name || e.FullName == name || e.Name == name));
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static Type[] GetTypes<TAttribute>(Type assemblyScope = null) where TAttribute : Attribute
		{
			return 
				CacheHelpers
				.GetFromMemCacheAdd(
					$"Yagasoft.Common.TypeHelpers.GetTypes<{typeof(TAttribute).FullName}>|{assemblyScope?.FullName}",
					() => CacheHelpers
						.GetFromMemCacheAdd(
							$"Yagasoft.Common.TypeHelpers.GetTypes<TAttribute>|{assemblyScope?.FullName}",
							() => assemblyScope?.Assembly.GetTypes()
								?? AppDomain.CurrentDomain.GetAssemblies().SelectMany(a => a.GetTypes()).ToArray())
						.Where(e => e.GetCustomAttribute<TAttribute>() != null).ToArray());
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static Type GetType<TAttribute>(Func<TAttribute, bool> predicate, Type assemblyScope = null) where TAttribute : Attribute
		{
			return CacheHelpers
				.GetFromMemCacheAdd(
					$"Yagasoft.Common.TypeHelpers.GetType<{typeof(TAttribute).FullName}>|{assemblyScope?.FullName}",
					() => assemblyScope?.Assembly.GetTypes()
						?? AppDomain.CurrentDomain.GetAssemblies().SelectMany(a => a.GetTypes()).ToArray())
				.FirstOrDefault(e => predicate(e.GetCustomAttribute<TAttribute>()));
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static TAttribute GetAttribute<TAttribute>(this Type type) where TAttribute : Attribute
		{
			return CacheHelpers
				.GetFromMemCacheAdd(
					$"Yagasoft.Common.TypeHelpers.GetAttribute<{typeof(TAttribute).FullName}>|{type.FullName}",
					type.GetCustomAttribute<TAttribute>);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static TAttribute GetAttribute<TAttribute>(this object obj) where TAttribute : Attribute
		{
			return obj.GetType().GetAttribute<TAttribute>();
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsTypeMarked<TAttribute>(this Type type, Func<TAttribute, bool> predicate = null)
			where TAttribute : Attribute
		{
			var attribute = type.GetAttribute<TAttribute>();
			return attribute != null && (predicate == null || predicate(type.GetCustomAttribute<TAttribute>()));
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsTypeMarked<TAttribute>(this object obj, Func<TAttribute, bool> predicate = null)
			where TAttribute : Attribute
		{
			return obj.GetType().IsTypeMarked(predicate);
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static partial class Helpers
	{
		private static readonly IDictionary<Type, Func<object, string>> StringRepresentationsMap =
			new ConcurrentDictionary<Type, Func<object, string>>();

		/// <summary>
		///     Gets the name of the assembly by going back frames in the stack trace.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="skipFrames">
		///     [Optional] The number of frames to go back.<br />
		///     If not specified, it will get the first assembly in the stack that does not equal this one.
		/// </param>
		/// <param name="skipAssemblyName">[Optional] The name of the assembly to skip if frames are set to '-1'.</param>
		/// <returns>The name of the assembly</returns>
		public static string GetAssemblyName(int skipFrames = -1, string skipAssemblyName = null)
		{
			var currentAssembly = new StackFrame().GetMethod().ReflectedType?.AssemblyQualifiedName;
			skipAssemblyName = string.IsNullOrWhiteSpace(skipAssemblyName) ? currentAssembly : skipAssemblyName;

			if (skipFrames < 0 && !string.IsNullOrWhiteSpace(skipAssemblyName))
			{
				for (var i = 1; i < 100; i++)
				{
					var method = new StackFrame(i).GetMethod();

					if (method == null)
					{
						break;
					}

					currentAssembly = method.ReflectedType?.AssemblyQualifiedName;

					if (currentAssembly?.Contains(skipAssemblyName) == true)
					{
						continue;
					}

					break;
				}
			}
			else if (skipFrames >= 0)
			{
				currentAssembly = new StackFrame(skipFrames + 1).GetMethod().ReflectedType?.AssemblyQualifiedName;
			}

			return currentAssembly;
		}

		/// <summary>
		///     Gets the name of the class by going back frames in the stack trace.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="skipFrames">
		///     [Optional] The number of frames to go back.<br />
		///     If not specified, it will get the first class in the stack that does not equal this one.
		/// </param>
		/// <param name="skipClassNamesParams">
		///     [Optional] The name of the classes to skip if frames are set to '-1'. Must be full
		///     name.
		/// </param>
		/// <returns>The name of the class</returns>
		public static string GetClassName(int skipFrames = -1, params string[] skipClassNamesParams)
		{
			Type declaringType = null;
			var currentClass = new StackFrame().GetMethod().ReflectedType;

			var skipClasses = skipClassNamesParams.ToList();
			skipClasses.Add(currentClass?.FullName);

			if (skipFrames < 0)
			{
				for (var i = 1; i < 100; i++)
				{
					var method = new StackFrame(i).GetMethod();

					if (method == null)
					{
						break;
					}

					declaringType = method.ReflectedType;
					var className = declaringType?.FullName ?? string.Empty;

					if (skipClasses.Contains(className))
					{
						continue;
					}

					break;
				}
			}
			else
			{
				declaringType = new StackFrame(skipFrames + 1).GetMethod().ReflectedType;
			}

			return declaringType?.FullName ?? string.Empty;
		}

		/// <summary>
		///     Gets the stack trace of the current execution path.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="skipFrames">
		///     [Optional] The number of frames to go back.<br />
		///     If not specified, it will get the first class in the stack that does not equal this one.
		/// </param>
		/// <param name="skipClassName">
		///     [Optional] The name of the class to skip if frame are set to '-1'. Must be full
		///     name.
		/// </param>
		/// <returns>The stack trace</returns>
		public static string GetStackTrace(int skipFrames = -1, string skipClassName = null)
		{
			var currentClass = new StackFrame().GetMethod().DeclaringType;
			skipClassName = string.IsNullOrWhiteSpace(skipClassName) ? currentClass?.FullName : skipClassName;

			if (skipFrames < 0 && !string.IsNullOrWhiteSpace(skipClassName))
			{
				for (var i = 1; i < 100; i++)
				{
					var method = new StackFrame(i).GetMethod();

					if (method == null)
					{
						break;
					}

					var declaringType = method.DeclaringType;
					var className = declaringType == null ? string.Empty : declaringType.FullName;

					if (className?.Contains(skipClassName) == true)
					{
						continue;
					}

					skipFrames = i - 1;
					break;
				}
			}
			else if (skipFrames < 0)
			{
				skipFrames = 0;
			}

			return new StackTrace(skipFrames + 1).ToString();
		}

		/// <summary>
		///     Add a function that returns a string representing the given type's values to the pool in memory.<br />
		///     This function will be searched for when 'GetStringRepresentation' is called.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="evaluator">
		///     A function that takes an object of the given type
		///     and returns a string representation of the values of that type.
		/// </param>
		public static void AddStringRepresentationFunction<T>(Func<T, string> evaluator)
		{
			evaluator.Require();
			StringRepresentationsMap[typeof(T)] = obj => obj is T ? evaluator((T)obj) : null;
		}

		/// <summary>
		///     Gets the function that returns a string representing the given type's values from the pool in memory.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static Func<object, string> GetStringRepresentationFunction(Type objectType)
		{
			if (objectType == null)
			{
				return null;
			}

			Func<object, string> evaluator;
			StringRepresentationsMap.TryGetValue(objectType, out evaluator);
			return evaluator ?? GetStringRepresentationFunction(objectType.BaseType);
		}

		public static bool IsAlwaysUseDefaultEvaluator;
		public static Func<object, string> DefaultEvaluator;

		/// <summary>
		///     Returns a string representing the given object's value.<br />
		///     This can be used in place of 'ToString'.<br />
		///     Custom functions can be defined and added to the pool using 'AddTypeStringRepresentation'.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetStringRepresentation(object value)
		{
			if (value == null)
			{
				return "null";
			}

			if (IsAlwaysUseDefaultEvaluator)
			{
				return DefaultEvaluator(value);
			}

			StringBuilder builder;

			if (value is ICollection)
			{
				var collection = (ICollection)value;
				var enumerator = collection.GetEnumerator();
				builder = new StringBuilder();

				var jumpSize = (int)Math.Ceiling(collection.Count / 5.0);
				var index = 0;
				var skipped = false;

				builder.Append("[");

				while (enumerator.MoveNext())
				{
					if (index % jumpSize == 0 || index == 0)
					{
						if (index > 0)
						{
							builder.Append(",");

							if (skipped)
							{
								builder.Append("..,");
							}
						}

						builder.Append($"{GetStringRepresentation(enumerator.Current)}");
					}
					else
					{
						skipped = true;
					}

					index++;
				}

				builder.Append("]");

				return builder.ToString();
			}

			if (value is EntityReference)
			{
				var reference = (EntityReference)value;
				builder = new StringBuilder();

				builder.Append($"{{Logical name = {reference.LogicalName}, Id = {reference.Id}");

				if (!string.IsNullOrWhiteSpace(reference.Name))
				{
					builder.Append($", Name = {reference.Name}");
				}

				builder.Append("}");

				return builder.ToString();
			}

			if (value is Entity)
			{
				var reference = (Entity)value;
				return $"{{Logical name = {reference.LogicalName}, Id = {reference.Id}}}";
			}

			if (value.ToString() != value.GetType().ToString())
			{
				return value.ToString();
			}

			var function = GetStringRepresentationFunction(value.GetType());
			return function == null ? DefaultEvaluator(value) : function(value);
		}

		/// <summary>
		/// Credit: https://stackoverflow.com/a/1641173/1919456
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static Guid? Merge(this Guid? guid1, Guid? guid2)
		{
			if (guid1 == null)
			{
				return guid2;
			}

			if (guid2 == null)
			{
				return guid1;
			}

			const int bytecount = 16;
			var destByte = new byte[bytecount];
			var guid1Byte = guid1.Value.ToByteArray();
			var guid2Byte = guid2.Value.ToByteArray();
     
			for (var i = 0; i < bytecount; i++)
			{
				destByte[i] = (byte) (guid1Byte[i] ^ guid2Byte[i]);
			}

			return new Guid(destByte);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static Guid? Merge(this Guid guid1, Guid? guid2)
		{
			return ((Guid?)guid1).Merge(guid2);
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static partial class CacheHelpers
	{
		/// <summary>
		/// Build an object containing parameters used by the caching methods. The org ID can be provided in order to 
		/// differentiate the cache of different organisations on the same machine.<br />
		/// If no config is found and fallback is not given, no caching is used.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="service">CRM service.</param>
		/// <param name="isAddAssemblyTosuffix">Append assembly name to the suffix.</param>
		/// <param name="suffix">Extra text to append on key.</param>
		/// <param name="fallbackCacheDuration">Duration to use for caching if no config was found in CRM.</param>
		public static CacheParams BuildCacheParams(IOrganizationService service,
			bool isAddAssemblyTosuffix = false, string suffix = null, TimeSpan? fallbackCacheDuration = null, Guid? orgId = null)
		{
			var cacheDuration = CrmHelpers.GetGenericConfig(service, orgId)?.GetAttributeValue<int?>("ldv_configurationcacheduration");

			return
				new CacheParams
				{
					CacheSuffix = isAddAssemblyTosuffix
						? $"{Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common")}|{suffix}"
						: suffix,
					CacheExpiryTarget = cacheDuration == null && fallbackCacheDuration.HasValue
						? DateTime.Now + fallbackCacheDuration
						: DateTime.Now.AddMinutes(cacheDuration ?? 0),
					OrgId = orgId
				};
		}

		private const string NullPlaceholder = "YsMemCache|null";

		/// <summary>
		///     Adds the given object to the MemCache.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="key">The string key to add this object under.</param>
		/// <param name="item">The object to add.</param>
		/// <param name="offset">
		///     [OPTIONAL] The time after which to remove the object from the cache.
		/// </param>
		/// <param name="cacheKeysuffix">A string to append to all keys. Usually the assembly name.</param>
		public static T AddToMemCache<T>(string key, T item, DateTimeOffset? offset, string cacheKeysuffix = null,
			Guid? orgId = null)
		{
			key.RequireFilled(nameof(key));

			ObjectCache cache = MemoryCache.Default;

			if (!string.IsNullOrWhiteSpace(cacheKeysuffix))
			{
				key += $"|{cacheKeysuffix}";
			}

			if (orgId.HasValue)
			{
				key += $"|{orgId}";
			}

			RemoveFromMemCache(key);

			if (item == null)
			{
				cache.Add(key, NullPlaceholder, offset ?? ObjectCache.InfiniteAbsoluteExpiration);
			}
			else
			{
				cache.Add(key, item, offset ?? ObjectCache.InfiniteAbsoluteExpiration);
			}

			return item;
		}

		/// <summary>
		///     Adds the given object to the MemCache.<br />
		///     Uses provided cache expiry params.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static T AddToMemCache<T>(string key, T item, string cacheKeysuffix = null, TimeSpan? fallbackCacheDuration = null,
			Guid? orgId = null)
		{
			return AddToMemCache(key, item, null, cacheKeysuffix, fallbackCacheDuration, orgId);
		}

		/// <summary>
		///     Adds the given object to the MemCache.<br />
		///     Uses provided cache expiry params.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static T AddToMemCache<T>(string key, T item, CacheParams cacheParams)
		{
			return AddToMemCache(key, item, cacheParams.CacheExpiryTarget, cacheParams.CacheSuffix, cacheParams.OrgId);
		}

		/// <summary>
		///     Adds the given object to the MemCache.<br />
		///     Automatically retrieves the cache expiry params.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static T AddToMemCache<T>(string key, T item, IOrganizationService service,
			string cacheKeysuffix = null, TimeSpan? fallbackCacheDuration = null, Guid? orgId = null)
		{
			return AddToMemCache(key, item, BuildCacheParams(service, false, cacheKeysuffix, fallbackCacheDuration, orgId));
		}

		/// <summary>
		///     Adds the given object to the MemCache.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="key">The string key to add this object under.</param>
		/// <param name="item">The object to add.</param>
		/// <param name="slidingExpiration">
		///     The duration after which to remove the object from cache, if it was not accessed for that duration.
		/// </param>
		/// <param name="cacheKeysuffix">A string to append to all keys. Usually the assembly name.</param>
		public static T AddToMemCache<T>(string key, T item, TimeSpan slidingExpiration, string cacheKeysuffix = null,
			Guid? orgId = null)
		{
			key.RequireFilled(nameof(key));

			ObjectCache cache = MemoryCache.Default;

			if (!string.IsNullOrWhiteSpace(cacheKeysuffix))
			{
				key += $"|{cacheKeysuffix}";
			}

			if (orgId.HasValue)
			{
				key += $"|{orgId}";
			}

			RemoveFromMemCache(key);

			if (item == null)
			{
				cache.Add(key, NullPlaceholder, new CacheItemPolicy { SlidingExpiration = slidingExpiration });
			}
			else
			{
				cache.Add(key, item, new CacheItemPolicy { SlidingExpiration = slidingExpiration });
			}

			return item;
		}

		/// <summary>
		///     Gets the object from the MemCache.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="key">The string key for the object to get.</param>
		/// <param name="cacheKeySuffix">A string to append to all keys. Usually the assembly name.</param>
		/// <param name="defaultValue">The value to return if the key can't be found in the cache.</param>
		public static TItemType GetFromMemCache<TItemType>(string key, string cacheKeySuffix = null,
			TItemType defaultValue = default(TItemType), Guid? orgId = null)
		{
			key.RequireFilled(nameof(key));

			ObjectCache cache = MemoryCache.Default;

			if (!string.IsNullOrWhiteSpace(cacheKeySuffix))
			{
				key += $"|{cacheKeySuffix}";
			}

			if (orgId.HasValue)
			{
				key += $"|{orgId}";
			}

			if (IsInMemCache(key))
			{
				var value = cache.Get(key);
				return (TItemType)((value as string) == NullPlaceholder ? default(TItemType) : value);
			}

			return defaultValue;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsInMemCache(string key, string cacheKeySuffix = null, Guid? orgId = null)
		{
			key.RequireFilled(nameof(key));

			ObjectCache cache = MemoryCache.Default;

			if (!string.IsNullOrWhiteSpace(cacheKeySuffix))
			{
				key += $"|{cacheKeySuffix}";
			}

			if (orgId.HasValue)
			{
				key += $"|{orgId}";
			}

			return cache.Contains(key);
		}

		/// <summary>
		///     Removes the object from the MemCache.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="key">The string key for the object to remove.</param>
		/// <param name="cacheKeysuffix">A string to append to all keys. Usually the assembly name.</param>
		public static void RemoveFromMemCache(string key, string cacheKeysuffix = null, Guid? orgId = null)
		{
			key.RequireFilled(nameof(key));

			ObjectCache cache = MemoryCache.Default;

			if (!string.IsNullOrWhiteSpace(cacheKeysuffix))
			{
				key += $"|{cacheKeysuffix}";
			}

			if (orgId.HasValue)
			{
				key += $"|{orgId}";
			}

			if (cache.Contains(key))
			{
				cache.Remove(key);
			}
		}

		/// <summary>
		///     Gets the object from the MemCache and add if it doesn't exist.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="key">The string key for the object to get.</param>
		/// <param name="cacheFiller">The function to execute to fill the cache if the key can't be found in the cache.</param>
		/// <param name="cacheParams">Expiry and other params to use.</param>
		/// <param name="defaultValue">The value that if returned by the cache would cause the 'filler' to run anyway.</param>
		public static T GetFromMemCacheAdd<T>(string key, Func<T> cacheFiller, CacheParams cacheParams,
			T defaultValue = default(T))
		{
			cacheParams = cacheParams ?? new CacheParams();

			return IsInMemCache(key, cacheParams.CacheSuffix, cacheParams.OrgId)
				? GetFromMemCache(key, cacheParams.CacheSuffix, defaultValue, cacheParams.OrgId)
				: AddToMemCache(key, cacheFiller(),
					cacheParams.CacheExpiryTarget, cacheParams.CacheSuffix, cacheParams.OrgId);
		}

		/// <summary>
		///     Gets the object from the MemCache and add if it doesn't exist.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static T GetFromMemCacheAdd<T>(string key, Func<T> cacheFiller, DateTimeOffset? offset,
			string cacheKeysuffix = null, T defaultValue = default(T), Guid? orgId = null)
		{
			return IsInMemCache(key, cacheKeysuffix, orgId)
				? GetFromMemCache(key, cacheKeysuffix, defaultValue, orgId)
				: AddToMemCache(key, cacheFiller(), offset, cacheKeysuffix, orgId);
		}

		/// <summary>
		///     Gets the object from the MemCache and add if it doesn't exist.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static T GetFromMemCacheAdd<T>(string key, Func<T> cacheFiller,
			string cacheKeysuffix = null, T defaultValue = default(T), TimeSpan? fallbackCacheDuration = null, Guid? orgId = null)
		{
			return GetFromMemCacheAdd(key, cacheFiller, null, cacheKeysuffix, defaultValue, fallbackCacheDuration, orgId);
		}

		/// <summary>
		///     Gets the object from the MemCache and add if it doesn't exist.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static T GetFromMemCacheAdd<T>(string key, Func<T> cacheFiller, TimeSpan slidingExpiration,
			string cacheKeysuffix = null, T defaultValue = default(T), Guid? orgId = null)
		{
			return IsInMemCache(key, cacheKeysuffix, orgId)
				? GetFromMemCache(key, cacheKeysuffix, defaultValue, orgId)
				: AddToMemCache(key, cacheFiller(), slidingExpiration, cacheKeysuffix, orgId);
		}

		/// <summary>
		///     Gets the object from the MemCache and add if it doesn't exist.<br />
		///     Automatically retrieves the cache expiry params.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="key">The string key for the object to get.</param>
		/// <param name="cacheFiller">The function to execute to fill the cache if the key can't be found in the cache.</param>
		/// <param name="defaultValue">The value that if returned by the cache would cause the 'filler' to run anyway.</param>
		public static T GetFromMemCacheAdd<T>(string key, Func<T> cacheFiller, IOrganizationService service,
			string cacheKeysuffix = null, T defaultValue = default(T), TimeSpan? fallbackCacheDuration = null, Guid? orgId = null)
		{
			return GetFromMemCacheAdd(key, cacheFiller,
				BuildCacheParams(service, false, cacheKeysuffix, fallbackCacheDuration, orgId), defaultValue);
		}
	}

	/// <summary>
	///     credit: http://blog.codeeffects.com/Article/Generate-Random-Numbers-And-Strings-C-Sharp <br />
	///		Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class RandomGenerator
	{
		public enum SymbolFlag
		{
			Uppers = 0,
			Lowers = 1,
			Numbers = 2
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetRandomString(int length, bool isLetterStart, int numberLetterRatio,
			params string[] symbols)
		{
			var sb = new StringBuilder();

			var digits = symbols.Where(symbol => char.IsDigit(symbol[0])).ToArray();
			var letters = symbols.Where(symbol => char.IsLetter(symbol[0])).ToArray();

			var digitsCount = 0;
			var lettersCount = 0;
			var floatRatio = numberLetterRatio / 100.0;

			for (var i = 0; i < length; i++)
			{
				var filteredSymbols = symbols;

				if (isLetterStart && i == 0)
				{
					lettersCount++;
					filteredSymbols = letters;
				}
				else if (numberLetterRatio > -1)
				{
					if ((lettersCount / (float)length) >= (1 - floatRatio)
						|| (GetRandomNumber(0, 100) <= numberLetterRatio
							&& (digitsCount / (float)length) < floatRatio))
					{
						digitsCount++;
						filteredSymbols = digits;
					}
					else
					{
						lettersCount++;
						filteredSymbols = letters;
					}
				}

				sb.Append(filteredSymbols[GetRandomNumber(0, filteredSymbols.Length)]);
			}

			return sb.ToString();
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetRandomString(int length, bool isLetterStart, params string[] symbols)
		{
			return GetRandomString(length, isLetterStart, -1, symbols);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetRandomString(int length, params string[] symbols)
		{
			return GetRandomString(length, false, -1, symbols);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetRandomString(int length, bool isLetterStart, int numberLetterRatio,
			params SymbolFlag[] symbolFlags)
		{
			symbolFlags.Require(nameof(symbolFlags));

			var array = new List<string>();

			var arraySymbolUppers = new[]
									{
										"A", "B", "C", "D", "E", "F", "G", "H", "J", "K", "L", "M", "N", "P", "R", "S", "T", "U",
										"V", "W", "X", "Y",
										"Z"
									};

			var arraySymbolLowers = new[]
									{
										"a", "b", "c", "d", "e", "f", "g", "h", "j", "k", "m", "n", "p", "q", "r", "s", "t", "u",
										"v", "w", "x", "y",
										"z"
									};

			var arrayNumbers = new[]
							   {
								   "0", "2", "3", "4", "5", "6", "8", "9"
							   };

			if (symbolFlags.Length <= 0)
			{
				symbolFlags = new[] { SymbolFlag.Uppers, SymbolFlag.Lowers, SymbolFlag.Numbers };
			}

			if (symbolFlags.Contains(SymbolFlag.Uppers))
			{
				array.AddRange(arraySymbolUppers);
			}

			if (symbolFlags.Contains(SymbolFlag.Lowers))
			{
				array.AddRange(arraySymbolLowers);
			}

			if (symbolFlags.Contains(SymbolFlag.Numbers))
			{
				array.AddRange(arrayNumbers);
			}

			return GetRandomString(length, isLetterStart, numberLetterRatio, array.ToArray());
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetRandomString(int length, bool isLetterStart, params SymbolFlag[] symbolFlags)
		{
			return GetRandomString(length, isLetterStart, -1, symbolFlags);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetRandomString(int length, params SymbolFlag[] symbolFlags)
		{
			return GetRandomString(length, false, -1, symbolFlags);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static int GetRandomNumber(int maxNumber = 100)
		{
			return GetRandomNumber(0, maxNumber);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static int GetRandomNumber(int minNumber, int maxNumber)
		{
			using (var rngGenerator = new RNGCryptoServiceProvider())
			{
				var b = new byte[4];
				rngGenerator.GetBytes(b);
				var seed = (b[0] & 0x7f) << 24 | b[1] << 16 | b[2] << 8 | b[3];
				var r = new Random(seed);

				return r.Next(minNumber, maxNumber);
			}
		}
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static partial class DateTimeHelpers
	{
		/// <summary>
		///     Gets the number of seconds that has passed since 1/1/1970 12AM.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="endDate">[OPTIONAL=UtcNow] The date to count to.</param>
		/// <returns>Number of seconds.</returns>
		public static long GetSecondsSinceEpoch(DateTime? endDate = null)
		{
			return (long)(endDate ?? DateTime.UtcNow).Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;
		}

		/// <summary>
		///     Gets the day occurence of month.<br />
		///     Credit: http://stackoverflow.com/a/18621645/1919456
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static DateTime? GetDayOccurrenceOfMonth(DateTime dateOfMonth, DayOfWeek dayOfWeek, bool isLastOccurrence)
		{
			return GetDayOccurrenceOfMonth(dateOfMonth, dayOfWeek, 5, isLastOccurrence);
		}

		/// <summary>
		///     Gets the day occurence of month.<br />
		///     Credit: http://stackoverflow.com/a/18621645/1919456
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static DateTime? GetDayOccurrenceOfMonth(DateTime dateOfMonth, DayOfWeek dayOfWeek, int occurrence,
			bool isLastOccurrence)
		{
			occurrence.RequireInRange(1, 5, "occurrence", "Occurrence must be greater than zero and less than 6.");

			if (isLastOccurrence)
			{
				occurrence = 5;
			}

			// Change to first day of the month
			var dayOfMonth = dateOfMonth.AddDays(1 - dateOfMonth.Day);

			// Find first dayOfWeek of this month;
			if (dayOfMonth.DayOfWeek > dayOfWeek)
			{
				dayOfMonth = dayOfMonth.AddDays(7 - (int)dayOfMonth.DayOfWeek + (int)dayOfWeek);
			}
			else
			{
				dayOfMonth = dayOfMonth.AddDays((int)dayOfWeek - (int)dayOfMonth.DayOfWeek);
			}

			// add 7 days per occurrence
			dayOfMonth = dayOfMonth.AddDays(7 * (occurrence - 1));

			// make sure this occurrence is within the original month
			if (dayOfMonth.Month == dateOfMonth.Month)
			{
				return dayOfMonth;
			}
			else
			{
				if (isLastOccurrence)
				{
					return dayOfMonth.AddDays(-7);
				}

				return null;
			}
		}
	}

	/// <summary>
	///     credit: http://pietschsoft.com/post/2008/02/net-35-json-serialization-using-the-datacontractjsonserializer <br />
	///		Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static partial class SerialiserHelpers
	{
		// credit: http://stackoverflow.com/a/12845153/1919456
		public static string SerialiseBase64<T>(this T value) where T : class
		{
			using (var stream = new MemoryStream())
			{
				using (var writer = XmlDictionaryWriter.CreateBinaryWriter(stream))
				{
					var serialiser = new DataContractSerializer(value.GetType());
					serialiser.WriteObject(writer, value);
					return Convert.ToBase64String(stream.ToArray());
				}
			}
		}

		public static T DeserialiseBase64<T>(this string base64) where T : class
		{
			using (var stream = new MemoryStream(Convert.FromBase64String(base64)))
			{
				using (var reader = XmlDictionaryReader
					.CreateBinaryReader(stream, XmlDictionaryReaderQuotas.Max))
				{
					var serialiser = new DataContractSerializer(typeof(T));
					return (T)serialiser.ReadObject(reader);
				}
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string SerialiseStrictXml<T>(T obj) where T : class
		{
			using (var stream = new MemoryStream())
			{
				var serialiser = new DataContractSerializer(obj.GetType());
				serialiser.WriteObject(stream, obj);
				return Encoding.UTF8.GetString(stream.ToArray());
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static T DeserialiseStrictXml<T>(string xml) where T : class
		{
			using (var stream = new MemoryStream(Encoding.UTF8.GetBytes(xml)))
			{
				var serialiser = new DataContractSerializer(typeof(T));
				return (T)serialiser.ReadObject(stream);
			}
		}

		/// <summary>
		///     Author: Ramy Victor
		/// </summary>
		public static string SerialiseContractXml<T>(this T obj) where T : class
		{
			using (var stream = new MemoryStream())
			{
				var serialiser = new XmlSerializer(typeof(T));
				serialiser.Serialize(stream, obj);
				stream.Position = 0;
				return Encoding.UTF8.GetString(stream.ToArray());
			}
		}

		/// <summary>
		///     Author: Ramy Victor
		/// </summary>
		public static T DeserialiseContractXml<T>(this string xml) where T : class
		{
			using (var read = new StringReader(xml))
			{
				using (XmlReader reader = new XmlTextReader(read))
				{
					var serialiser = new XmlSerializer(typeof(T));
					return (T)serialiser.Deserialize(reader);
				}
			}
		}

		public static string SerialiseSimpleDictionary<T>(T obj)
		{
			using (var stream = new MemoryStream())
			{
				GetDictSerializer<T>().WriteObject(stream, obj);
				return Encoding.UTF8.GetString(stream.ToArray());
			}
		}

		public static T DeserialiseSimpleDictionary<T>(string json)
		{
			using (var stream = new MemoryStream())
			{
				using (var writer = new StreamWriter(stream))
				{
					writer.Write(json);
					writer.Flush();
					stream.Position = 0;
					return (T)GetDictSerializer<T>().ReadObject(stream);
				}
			}
		}

		private static DataContractJsonSerializer GetDictSerializer<T>()
		{
			var settings =
				new DataContractJsonSerializerSettings
				{
					UseSimpleDictionaryFormat = true
				};

			return new DataContractJsonSerializer(typeof(T), settings);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string SerialiseSimpleJson(IDictionary<string, string> dictionary, bool isUnformatted = false)
		{
			var pairs = dictionary.Select(pair =>
				string.Format((isUnformatted ? string.Empty : "\t") + "\"{0}\":\"{1}\"", pair.Key, pair.Value?.StringLiteral()))
				.ToArray();
			return "{" + (isUnformatted ? string.Empty : "\r\n") + (pairs.Any() ?
				pairs.Aggregate((e1, e2) => e1 + "," + (isUnformatted ? string.Empty : "\r\n") + e2) : string.Empty)
				+ (isUnformatted ? string.Empty : "\r\n") + "}";
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IDictionary<string, string> DeserialiseSimpleJson(string json)
		{
			if (json.IsEmpty())
			{
				return new Dictionary<string, string>();
			}

			var matches = Regex.Matches(json,
				@"\s*,?\s*['""]?([^{}""'\s]*?)['""]?(?:\s*:\s*)(true|false|\d+|[^\\]?['""](?:\\""|\\'|[^{}'""])*?[^\\]?['""])");

			if (matches.Count <= 0)
			{
				throw new FormatException("JSON is empty or poorly formatted.");
			}

			var dictionary = new Dictionary<string, string>();

			foreach (Match match in matches)
			{
				var groups = match.Groups;

				// the whole string is a match and the rest are pairs
				if ((groups.Count - 1) % 2 != 0)
				{
					throw new FormatException("JSON is poorly formatted.");
				}

				if (string.IsNullOrEmpty(groups[2].Value))
				{
					continue;
				}

				dictionary.Add(groups[1].Value, groups[2].Value.Trim('\'', '\"').StringUnliteral());
			}

			return dictionary;
		}

		/// <summary>
		/// Serialises the object into JSON using the .NET <see cref="DataContractJsonSerializer" />.<br />
		/// Classes must be decorated with <see cref="DataContract" /> and member with <see cref="DataMember" />.<br />
		/// To aid in serialisation, known types can be passed, or pass null and the method will automatically
		/// attempt to find the types. You can optionally limit the scope of the search to the provided type's assembly.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <typeparam name="T">Return type.</typeparam>
		/// <param name="obj">The object to serialise.</param>
		/// <param name="isSerializeReadOnlyTypes">If set to <c>true</c> will serialise <c>readonly</c>
		/// and properties with a <c>get</c> only.</param>
		/// <param name="knownTypes">The known types to consider when serialising.</param>
		/// <param name="assembliesScope">The assemblies scope.</param>
		/// <param name="surrogate">The surrogate.</param>
		/// <param name="latestError">The latest error.</param>
		public static string SerialiseContractJson<T>(this T obj, bool isSerializeReadOnlyTypes = false, IEnumerable<Type> knownTypes = null,
			Assembly[] assembliesScope = null, IDataContractSurrogate surrogate = null, string latestError = null)
			where T : class
		{
			knownTypes = knownTypes ?? new Type[0];

			try
			{
				using (var memoryStream = new MemoryStream())
				{
					var serialiser = new DataContractJsonSerializer(typeof(T),
						BuildSerialisationSettings(isSerializeReadOnlyTypes, knownTypes, surrogate));
					serialiser.WriteObject(memoryStream, obj);
					return Encoding.Default.GetString(memoryStream.ToArray());
				}
			}
			catch (SerializationException ex)
			{
				var serialised = HandleSerialisationException(ref knownTypes, assembliesScope, ref latestError, ex);

				if (serialised)
				{
					return obj.SerialiseContractJson(isSerializeReadOnlyTypes, knownTypes, assembliesScope, surrogate, latestError);
				}

				return null;
			}
		}

		/// <summary>
		/// Deserialises the object into JSON using the .NET <see cref="DataContractJsonSerializer" />.<br />
		/// Classes must be decorated with <see cref="DataContract" /> and member with <see cref="DataMember" />.<br />
		/// To aid in deserialisation, known types can be passed, or pass null and the method will automatically
		/// attempt to find the types. You can optionally limit the scope of the search to the provided type's assembly.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <typeparam name="T">Return type.</typeparam>
		/// <param name="json">The json.</param>
		/// <param name="isSerializeReadOnlyTypes">If set to <c>true</c> will deserialise <c>readonly</c>
		/// and properties with a <c>get</c> only.</param>
		/// <param name="knownTypes">The known types to consider when deserialising.</param>
		/// <param name="assembliesScope">The assemblies scope.</param>
		/// <param name="surrogate">The surrogate.</param>
		/// <param name="latestError">The latest error.</param>
		public static T DeserialiseContractJson<T>(this string json, bool isSerializeReadOnlyTypes = false, IEnumerable<Type> knownTypes = null,
			Assembly[] assembliesScope = null, IDataContractSurrogate surrogate = null, string latestError = null)
			where T : class
		{
			knownTypes = knownTypes ?? new Type[0];

			try
			{
				using (var memoryStream = new MemoryStream(Encoding.UTF8.GetBytes(json)))
				{
					var serialiser = new DataContractJsonSerializer(typeof(T),
						BuildSerialisationSettings(isSerializeReadOnlyTypes, knownTypes, surrogate));
					return (T)serialiser.ReadObject(memoryStream);
				}
			}
			catch (SerializationException ex)
			{
				var serialised = HandleSerialisationException(ref knownTypes, assembliesScope, ref latestError, ex);

				if (serialised)
				{
					return json.DeserialiseContractJson<T>(isSerializeReadOnlyTypes, knownTypes, assembliesScope,
						surrogate, latestError);
				}

				return null;
			}
		}

		private static bool HandleSerialisationException(ref IEnumerable<Type> knownTypes, Assembly[] assembliesScope,
			ref string latestError, SerializationException ex)
		{
			if (latestError == ex.Message)
			{
				throw new SerializationException($"Type is unsupported by [de]serialisation => '{latestError}'.");
			}

			latestError = ex.Message;

			var match = Regex.Match(ex.Message, @"Type '(.+?)'");

			if (match.Groups.Count <= 1)
			{
				match = Regex.Match(ex.Message, @"'https?://.*?/([\w\.]+:(\w+))'");
			}

			if (match.Groups.Count > 1)
			{
				knownTypes = knownTypes.Union(
					new[]
					{
						TypeHelpers.GetType(match.Groups[1].ToString().Replace(':', '.'), assembliesScope)
							?? TypeHelpers.GetType(match.Groups[2].ToString(), assembliesScope)
					}).Where(e => e != null);
				return true;
			}

			throw new SerializationException($"Type is unsupported by [de]serialisation => '{latestError}'.");
		}

		private static DataContractJsonSerializerSettings BuildSerialisationSettings(bool isSerializeReadOnlyTypes,
			IEnumerable<Type> knownTypes, IDataContractSurrogate surrogate)
		{
			return new DataContractJsonSerializerSettings
				   {
					   UseSimpleDictionaryFormat = true,
					   SerializeReadOnlyTypes = isSerializeReadOnlyTypes,
					   KnownTypes = knownTypes,
					   DataContractSurrogate = surrogate
				   };
		}

		/// <summary>
		/// Credit: https://stackoverflow.com/a/9347678/1919456
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <seealso cref="System.Runtime.Serialization.IDataContractSurrogate" />
		public class DateTimeCrmContractSurrogate : IDataContractSurrogate
		{
	        private static readonly Regex dateRegex = new Regex(@"/Date\((\d+)([-+])?(\d+)?\)/");
	        private static readonly DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);

	        public object GetCustomDataToExport(Type clrType, Type dataContractType)
	        {
	            // not used
	            return null;
	        }

	        public object GetCustomDataToExport(System.Reflection.MemberInfo memberInfo, Type dataContractType)
	        {
	            // not used
	            return null;
	        }

	        public Type GetDataContractType(Type type)
	        {
	            // not used
	            return type;
	        }

	        public object GetDeserializedObject(object obj, Type targetType)
	        {
	            // for debugging
	            //Console.WriteLine("GetDeserializedObject: obj = {0} ({1}), targetType = {2}", obj, obj.GetType(), targetType);

	            if (obj is DataCollection<string, object> dataCollection)
	            {
		            foreach (var item in dataCollection.ToArray())
		            {
			            dataCollection[item.Key] = ConvertDate(item.Value as string) ?? item.Value;
		            }
	            }

	            if (obj is IDictionary<string, object> dictionary)
	            {
		            foreach (var item in dictionary.ToArray())
		            {
			            dictionary[item.Key] = ConvertDate(item.Value as string) ?? item.Value;
		            }
	            }

		        return CustomIterator(obj);
	        }

			protected virtual object CustomIterator(object obj)
			{
				return obj;
			}

			protected static DateTime? ConvertDate(string unparsedDate)
			{
				if (unparsedDate != null)
				{
					// check if we match the DateTime format
					Match match = dateRegex.Match(unparsedDate);

					if (match.Success)
					{
						// try to parse the string into a long. then create a datetime and convert to local time.
						long msFromEpoch;

						if (long.TryParse(match.Groups[1].Value, out msFromEpoch))
						{
							TimeSpan fromEpoch = TimeSpan.FromMilliseconds(msFromEpoch);
							return TimeZoneInfo.ConvertTimeFromUtc(epoch.Add(fromEpoch), TimeZoneInfo.Local);
						}
					}
				}

				return null;
			}

			public void GetKnownCustomDataTypes(System.Collections.ObjectModel.Collection<Type> customDataTypes)
	        {
	            // not used   
	        }

	        public object GetObjectToSerialize(object obj, Type targetType)
	        {
	            // for debugging
	            //Console.WriteLine("GetObjectToSerialize: obj = {0} ({1}), targetType = {2}", obj, obj.GetType(), targetType);
	            return obj;
	        }

	        public Type GetReferencedTypeOnImport(string typeName, string typeNamespace, object customData)
	        {
	            // not used
	            return null;
	        }

	        public System.CodeDom.CodeTypeDeclaration ProcessImportedType(System.CodeDom.CodeTypeDeclaration typeDeclaration, System.CodeDom.CodeCompileUnit compileUnit)
	        {
	            // not used
	            return typeDeclaration;
	        }
	    }
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	//[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class CrmParser
	{
		private const string Pattern =
			@"
(?<x>{
	(?:_`.*?`_)?	# description
	( (?<c>.) )		# construct key
)
		(?>		# construct param
			\(
				( (?> [^`@%\|()] | `[^`]*?` )*? )
			\)
		)?
	\|
	(?:
		(?>
			(
				% ([a-z]+?)			# preprocessor key
					(				# preprocessor param
						(?>
							\(
								(?> [^`@%\|()] | `[^`]*?` )*?
							\)
						)?
					)
			)+
		%)*
		( (?> [^`@%\|] | `[^`]*?` | \|\| )*? )	# block
		(?>
			(
				@ ([a-z]+?)			# postprocessor key
					(				# postprocessor param
						(?>
							\(
								(?> [^`@%\|()] | `[^`]*?` )*?
							\)
						)?
					)
			)+
		@)*
	)?
	\|
(?<-x>
	\k<c>(?<-c>)
})(?(x)(?!))";

		private const string ParameterPattern = @"^((?: [^,`@%\|()] | `[^`]*?` )+?)(?: , ((?: [^,`@%\|()] | `[^`]*?` )*?) )*?$";
		private const string TokenPattern = @"\[__(\d+?)__\]";
		private const string ExpressionTokenPattern = @"\[\$\$(\d+?)\$\$\]";

		private static readonly TimeSpan fallbackCacheDuration = TimeSpan.FromDays(365);

		public static string Parse(string input, IOrganizationService service, Guid? orgId = null)
		{
			service.Require(nameof(service));
			var state = new GlobalState(service, orgId);
			input = Tokenise(input, state);
			return Parse(input, state);
		}

		public static string Parse(string input, Entity context, IOrganizationService service, Guid? orgId = null)
		{
			service.Require(nameof(service));
			var state = new GlobalState(context, service, orgId);

			// convert all constructs into tokens to be able to get the parent/enclosing constructs first by detokenising
			// this is needed in constructs that manipulate the context of their block; otherwise, inner most is executed first
			// while testing I found that it was too expensive (performance) and complex (maintainability) using pure RegEx
			input = Tokenise(input, state);

			return Parse(input, state);
		}

		private static string Tokenise(string input, GlobalState state)
		{
			input.Require(nameof(input));
			state.Require(nameof(state));

			var matches = Regex
				.Matches(input, Pattern, RegexOptions.IgnorePatternWhitespace)
				.OfType<Match>().ToArray();

			if (!matches.Any())
			{
				return input;
			}

			input = matches
				.DistinctBy(m => m.Groups[0].Value)
				.Aggregate(input, (current, match) => current.Replace(match.Value, $"[__{state.GenerateToken(match.Value)}__]"));

			return Tokenise(input, state);
		}

		private static string Parse(string input, GlobalState state, int exhausted = 0)
		{
			input.Require(nameof(input));
			state.Require(nameof(state));

			// an infinite loop occurs when the quick-check regex pattern parser is stuck matching but the more complex one isn't
			// this happens when reserved characters are used without ticks (`)
			if (exhausted > 1)
			{
				throw new StackOverflowException("CrmParser is stuck. Make sure to wrap any reserved characters with ticks (`).");
			}

			// do a cheap and quick check on the existence of any construct
			if (!Regex.IsMatch(input, @"(?<x>{(?:_`.*?`_)?(?<c>.))(?:\(.*?\))?\|.*\|(?<-x>\k<c>(?<-c>)})(?(x)(?!))"))
			{
				var deTokenised = DeTokenise(input, TokenPattern, state);
				return input == deTokenised ? input : Parse(deTokenised, state);
			}

			// each match is a construct
			var parsed = Regex.Replace(input, Pattern,
				match =>
				{
					var constructString = match.Groups[0].Value;

					var constructKey = match.Groups[1].Value;
					var constructParam = match.Groups[2].Value;

					var preProcessorStrings = match.Groups[3].ExtractCaptures();
					var preProcessorKeys = match.Groups[4].ExtractCaptures();
					var preProcessorParams = match.Groups[5].ExtractCaptures().Select(c => c.Trim('(', ')'));
					var preProcessors = ParseProcessors<PreprocessorAttribute>(state, preProcessorStrings.ToArray(),
						preProcessorKeys.ToArray(), preProcessorParams.ToArray());

					var block = match.Groups[6].Value;

					var postProcessorStrings = match.Groups[7].ExtractCaptures();
					var postProcessorKeys = match.Groups[8].ExtractCaptures();
					var postProcessorParams = match.Groups[9].ExtractCaptures().Select(c => c.Trim('(', ')'));
					var postProcessors = ParseProcessors<PostProcessorAttribute>(state, postProcessorStrings.ToArray(),
						postProcessorKeys.ToArray(), postProcessorParams.ToArray());

					return ConstructFactory
						.GetConstruct(state, constructString, constructKey, constructParam,
							preProcessors.OfType<Preprocessor>(), postProcessors.OfType<PostProcessor>())
						.Execute(block)
						.StringAggregate("");
				}, RegexOptions.IgnorePatternWhitespace);
			
			return Parse(parsed, state, parsed == input ? ++exhausted : 0);
		}

		private static string DeTokenise(string input, string pattern, GlobalState state)
		{
			return Regex
				.Replace(input, pattern,
					m =>
					{
						if (!m.Success)
						{
							return "";
						}

						return state.GetToken(m.Groups[1].Value) ?? "";
					});
		}

		private static IEnumerable<StageProcessor> ParseProcessors<TProcessor>(GlobalState state,
			string[] processorStrings, string[] processorKeys, string[] parameters)
			where TProcessor : ProcessorAttribute
		{
			processorStrings.Require(nameof(processorStrings));
			processorKeys.RequireCountAtLeast(processorStrings.Length, nameof(processorKeys));
			parameters.RequireCountAtLeast(processorStrings.Length, nameof(parameters));

			return processorStrings
				.Select((p, i) => ProcessorFactory
					.GetProcessor<TProcessor>(state, p, processorKeys[i], parameters[i]));
		}
		
		private static IEnumerable<Entity> BuildTraversalContext(Entity context, IEnumerable<string> traversal,
			GlobalState state, IReadOnlyList<string> distinctFields,
			IReadOnlyList<string> orderFields, bool isCacheGlobal)
		{
			IEnumerable<Entity> contextBuffer = new[] { context };

			foreach (var n in traversal)
			{
				var isRelation = n.StartsWith("!");
				var node = n.TrimStart('.', '!');

				contextBuffer = contextBuffer.SelectMany(
					c =>
					{
						if (isRelation)
						{
							var attributes = distinctFields?.Union(orderFields?.Select(o => o.Trim('!')) ?? Array.Empty<string>()).Distinct().ToArray();
							attributes = attributes?.Any() == true ? attributes : Array.Empty<string>();
							var key = $"CrmParser.BuildContextBuffer|{c.LogicalName}|{c.Id}|{node}|{attributes.StringAggregate()}";

							var related = c
								.RelatedEntities
								.Where(r => r.Key.SchemaName == node && r.Value != null)
								.SelectMany(r => r.Value?.Entities).ToArray();

							related =
								related.Any()
									? related
									: state.GetCachedAdd(key, () =>
									CrmHelpers.GetRelatedRecords(state.Service, c.ToEntityReference(), node, null, state.OrgId, attributes)
										.ToArray(),
									isCacheGlobal);

							if (related.Any())
							{
								c.RelatedEntities[new Relationship(node)] = new EntityCollection(related);
							}

							var q = related.AsEnumerable();

							if (distinctFields.IsFilled())
							{
								q = q.DistinctBy(
									e => distinctFields
										.Select(s => CrmHelpers.GetAttributeName(s, e))
										.StringAggregate());
							}

							if (orderFields.IsFilled())
							{
								var ordered = q.OrderBy(e => e.Id);

								for (var i = 0; i < orderFields.Count; i++)
								{
									var orderRaw = orderFields[i];
									var order = orderRaw.Trim('!');
									var isDesc = orderRaw.StartsWith("!");

									if (i == 0)
									{
										if (isDesc)
										{
											ordered = ordered.OrderByDescending(e =>
												CrmHelpers.GetAttributeName(order, e));
										}
										else
										{
											ordered = ordered.OrderBy(e =>
												CrmHelpers.GetAttributeName(order, e));
										}
									}
									else
									{
										if (isDesc)
										{
											ordered = ordered.ThenByDescending(e =>
												CrmHelpers.GetAttributeName(order, e));
										}
										else
										{
											ordered = ordered.ThenBy(e =>
												CrmHelpers.GetAttributeName(order, e));
										}
									}
								}

								q = ordered;
							}

							return q;
						}
						else
						{
							var fieldValue = c.GetAttributeValue<object>(node);

							// get the entity record
							c = fieldValue == null && c.LogicalName.IsFilled() && c.Id != Guid.Empty
								? c.IntegrateAttributes(Retrieve(state, c.LogicalName, c.Id, isCacheGlobal, node))
								: c;

							fieldValue = c.GetAttributeValue<object>(node);

							// if the field value is not a lookup, then we can't recurse
							if (!(fieldValue is EntityReference reference))
							{
								throw new Exception($"Field \"{node}\" is not a lookup.");
							}

							return
								new[]
								{
									new Entity(reference.LogicalName)
									{
										Id = reference.Id
									}
								};
						}
					});
			}

			return contextBuffer;
		}

		public static string Unescape(string buffer)
		{
			return buffer.Replace("`", "");
		}

		public static string TrimEscape(string buffer)
		{
			return buffer.Trim('`');
		}

		static readonly string[] ops = new[] { "+", "-", "*", "/", ">", "<", "<=", ">=", "==", "!=", "&&", "||", "??", "?", ":" };
		static readonly string[] reserved = ops.Union(new[] { "(", ")" }).ToArray();

		private static string ParseExpression(string expression, GlobalState state, bool isTokenise = true)
	    {
			try
			{
				if (!reserved.Any(expression.Contains))
				{
					return !isTokenise && Regex.IsMatch(expression, ExpressionTokenPattern)
						? ParseExpression(DeTokenise(expression, ExpressionTokenPattern, state), state, false)
						: expression;
				}

				var tokens = expression.ToCharArray().Select(t => t.ToString()).ToArray();
				var valuesStack = new Stack<string>();
				var opsStack = new Stack<string>();

				// base algorithm credit: https://www.tutorialcup.com/interview/stack/arithmetic-expression-evaluation.htm
				for (var i = 0; i < tokens.Length; i++)
				{
					var op = GetOp(ops, tokens, i);

					if (op != null)
					{
						if (i == 0 || GetOp(ops, tokens, i - 1) != null)
						{
							valuesStack.Push("");
						}

						while (opsStack.Any() && HasPrecedence(op, opsStack.Peek()))
						{
							valuesStack.Push(ApplyOp(opsStack.Pop(), valuesStack.Pop(), valuesStack.Pop(), state, isTokenise));
						}

						opsStack.Push(op);

						if ((i + op.Length) >= tokens.Length || ((i + op.Length) < tokens.Length && GetOp(ops, tokens, i + op.Length) != null))
						{
							valuesStack.Push("");
						}

						i += op.Length - 1;
					}
					else if (tokens[i] == "(")
					{
						opsStack.Push(tokens[i]);
					}
					else if (tokens[i] == ")")
					{
						while (opsStack.Peek() != "(")
						{
							valuesStack.Push(ApplyOp(opsStack.Pop(), valuesStack.Pop(), valuesStack.Pop(), state, isTokenise));
						}

						opsStack.Pop();
					}
					else
					{
						var isHungry = tokens[i] == "`";

						var sbuf = new StringBuilder();
						sbuf.Append(tokens[i]);

						while (((i + 1) < tokens.Length && GetOp(reserved, tokens, i + 1) == null) || isHungry)
						{
							var token = tokens[(++i)];
							isHungry = token == "`" ? !isHungry : isHungry;
							sbuf.Append(token);
						}

						valuesStack.Push(sbuf.ToString());
					}
				}

				while (opsStack.Any())
				{
					valuesStack.Push(ApplyOp(opsStack.Pop(), valuesStack.Pop(), valuesStack.Pop(), state, isTokenise));
				}

				var result = valuesStack.Pop();

				return Regex.IsMatch(result, ExpressionTokenPattern)
					? ParseExpression(DeTokenise(result, ExpressionTokenPattern, state), state, false)
					: result;
			}
			catch
			{
				return expression;
			}
	    }

	    private static string GetOp(string[] pool, string[] tokens, int i)
	    {
		    string op = null;
		    string tempOp;

		    if ((i + 1) < tokens.Length && pool.Contains(tempOp = tokens[i] + tokens[i + 1]))
		    {
			    op = tempOp;
		    }
			else if (pool.Contains(tokens[i]))
		    {
			    op = tokens[i];
		    }
		    
		    return op;
	    }

		private static bool HasPrecedence(string op1, string op2)
	    {
		    if (op2 == "(" || op2 == ")")
		    {
			    return false;
		    } 

			var precedence =
			    new List<string[]>
				{
					new[] { ":" },
					new[] { "?" },
					new[] { "??" },
					new[] { "||" },
					new[] { "&&" },
					new[] { "==", "!=" },
					new[] { "<", ">", "<=", ">=" },
					new[] { "+", "-" },
					new[] { "*", "/" }
				};

		    return precedence.FindIndex(p => p.Contains(op1)) <
			    precedence.FindIndex(p => p.Contains(op2));
	    }

		private static string ApplyOp(string op, string right, string left, GlobalState state, bool isTokenise)
		{
			var result = "";

			if (op == "?")
			{
				left = TrimEscape(left);
				left = Parse(left, state);
				left = ParseExpression(left, state, false);
				var isLeftBool = bool.TryParse(left, out var leftBool);

				if (isLeftBool)
				{
					result = ParseExpression($"{leftBool}_@$@_{right}", state);
				}
			}
			else if (op == ":")
			{
				var leftSplit = left.Split(new[] { "_@$@_" }, StringSplitOptions.None);
				var predicateString = leftSplit.FirstOrDefault() ?? "";
				var leftClause = leftSplit.LastOrDefault() ?? "";

				var isPredicateBool = bool.TryParse(predicateString, out var predicate);

				if (isPredicateBool)
				{
					if (!predicate)
					{
						right = TrimEscape(right);
						right = Parse(right, state);
					}

					result = ParseExpression(predicate ? leftClause : right, state, false);
				}

				result = ParseExpression(result, state);
			}
			else if (op == "??")
			{
				left = TrimEscape(left);
				left = Parse(left, state);
				left = ParseExpression(left, state, false);

				if (left.IsEmpty())
				{
					right = TrimEscape(right);
					right = Parse(right, state);
				}

				result = left.IsEmpty() ? ParseExpression(right, state, false) : left;
				result = ParseExpression(result, state);
			}
			else if (new[] { "&&", "||" }.Contains(op))
			{
				left = TrimEscape(left);
				left = Parse(left, state);
				left = ParseExpression(left, state, false);
				var isLeftBool = bool.TryParse(left, out var leftBool);

				switch (op)
				{
					case "&&":
						result = false.ToString();

						// short circuit
						if (isLeftBool && leftBool)
						{
							right = TrimEscape(right);
							right = Parse(right, state);
							right = ParseExpression(right, state, false);
							var isRightBool = bool.TryParse(right, out var rightBool);
							result = (isRightBool && rightBool).ToString();
						}
						break;

					case "||":
						result = true.ToString();

						if (isLeftBool && !leftBool)
						{
							right = TrimEscape(right);
							right = Parse(right, state);
							right = ParseExpression(right, state, false);
							var isRightBool = bool.TryParse(right, out var rightBool);
							result = (isRightBool && rightBool).ToString();
						}
						break;
				}

				result = ParseExpression(result, state);
			}
			else
			{
				left = Parse(left, state);
				right = Parse(right, state);

				if (isTokenise)
				{
					return $"[$${state.GenerateToken($"({left}{op}{right})")}$$]";
				}

				while (Regex.IsMatch(left, ExpressionTokenPattern) || Regex.IsMatch(right, ExpressionTokenPattern))
				{
					left = ParseExpression(left, state, false);
					right = ParseExpression(right, state, false);
				}

				left = TrimEscape(left);
				right = TrimEscape(right);

				var isLeftNumeric = decimal.TryParse(left, out var leftNumeric);
				var isLeftDate = DateTime.TryParse(left, out var leftDate);

				var isRightNumeric = decimal.TryParse(right, out var rightNumeric);
				var isRightDate = DateTime.TryParse(right, out var rightDate);

				IComparable leftComparable = isLeftNumeric ? leftNumeric : (isLeftDate ? leftDate : (IComparable)null);
				IComparable rightComparable = isRightNumeric ? rightNumeric : (isRightDate ? rightDate : (IComparable)null);

				var comparable = leftComparable?.GetType().IsInstanceOfType(rightComparable) == true
					? leftComparable?.CompareTo(rightComparable)
					: null;

				if (op == "-")
				{
					rightNumeric = -rightNumeric;
				}

				switch (op)
				{
					case "*":
						if (isLeftNumeric && isRightNumeric)
						{
							result = (leftNumeric * rightNumeric).ToString();
						}
						break;

					case "/":
						if (isRightNumeric && rightNumeric == 0)
						{
							throw new DivideByZeroException("Cannot divide by 0.");
						}

						if (isLeftNumeric && isRightNumeric && rightNumeric != 0)
						{
							result = (leftNumeric / rightNumeric).ToString();
						}
						break;

					case "+":
					case "-":
						if (isLeftNumeric)
						{
							if (isRightNumeric)
							{
								result = (leftNumeric + rightNumeric).ToString();
							}
							else if (isRightDate)
							{
								result = rightDate.AddMinutes((double)leftNumeric).ToString("s");
							}
						}
						else if (isLeftDate)
						{
							if (isRightNumeric)
							{
								result = leftDate.AddMinutes((double)rightNumeric).ToString("s");
							}
							else
							{
								var dateMatch = Regex.Match(right, @"(\d*?)([mhdMy])");
								var isAmount = double.TryParse(dateMatch.Groups[1].Value, out var amount);
								var unit = dateMatch.Groups[2].Value;

								if (isAmount)
								{
									if (op == "-")
									{
										amount = -amount;
									}

									switch (unit)
									{
										case "m":
											result = leftDate.AddMinutes(amount).ToString("s");
											break;

										case "h":
											result = leftDate.AddHours(amount).ToString("s");
											break;

										case "d":
											result = leftDate.AddDays(amount).ToString("s");
											break;

										case "M":
											result = leftDate.AddMonths((int)amount).ToString("s");
											break;

										case "y":
											result = leftDate.AddYears((int)amount).ToString("s");
											break;
									}
								}
							}
						}
						break;

					case "<":
						result = (comparable < 0).ToString();
						break;

					case ">":
						result = (comparable > 0).ToString();
						break;

					case "<=":
						result = (comparable <= 0).ToString();
						break;

					case ">=":
						result = (comparable >= 0).ToString();
						break;

					case "==":
						result = (left == right).ToString();
						break;

					case "!=":
						result = (left != right).ToString();
						break;
				}
			}

			return result;
		}

		public static Entity Retrieve(GlobalState state,
			string entityName, Guid id, bool isCacheGlobal, params string [] attributes)
		{
			return state.GetCachedAdd($"CrmParser.Retrieve|{entityName}|{id}|{attributes.StringAggregate()}",
				() => state.Service.Retrieve(entityName, id, attributes?.Any() == true ? new ColumnSet(attributes) : new ColumnSet(false)),
				isCacheGlobal);
		}

		public static Entity[] RetrieveMultiple(IOrganizationService service, GlobalState state, string fetchXml,
			bool isCacheGlobal)
		{
			return state.GetCachedAdd($"CrmParser.RetrieveMultiple|{fetchXml}",
				() => CrmHelpers.RetrieveRecords(service, fetchXml).ToArray(),
				isCacheGlobal);
		}

		public static Entity CallAction(IOrganizationService service, string actionName, EntityReference target, string parameters)
		{
			var request = new OrganizationRequest(actionName);

			if (parameters.IsFilled())
			{
				foreach (var pair in SerialiserHelpers.DeserialiseSimpleJson(parameters))
				{
					request[pair.Key] = pair.Value;
				}
			}

			if (target != null)
			{
				request["Target"] = target;
			}

			var result = new Entity();

			foreach (var pair in service.Execute(request).Results)
			{
				var key = pair.Key;
				var value = pair.Value;

				if (value is EntityCollection collection)
				{
					if (collection.Entities.Any())
					{
						result.RelatedEntities[new Relationship(key)] = new EntityCollection(collection.Entities);
					}
				}
				else
				{
					result[pair.Key] = pair.Value;
				}
			}

			return result;
		}

		#region Factories

		private static IDictionary<string, Type> ConstructTypes
			=> CacheHelpers.GetFromMemCacheAdd("Yagasoft.CrmParser.GetTypes<ConstructAttribute>",
				() => Yagasoft.Libraries.Common.TypeHelpers.GetTypes<ConstructAttribute>()
					.ToDictionary(t => t.GetCustomAttribute<ConstructAttribute>().Key, t => t),
				fallbackCacheDuration: fallbackCacheDuration);

		private static IDictionary<string, Type> ProcessorTypes
			=> CacheHelpers.GetFromMemCacheAdd("Yagasoft.CrmParser.GetTypes<ProcessorAttribute>",
				() => Yagasoft.Libraries.Common.TypeHelpers.GetTypes<ProcessorAttribute>()
					.ToDictionary(t =>
								  {
									  var attribute = t.GetCustomAttribute<ProcessorAttribute>();
									  return attribute.Key + attribute.GetType().FullName;
								  }, t => t),
				fallbackCacheDuration: fallbackCacheDuration);

		private static class ConstructFactory
		{
			public static Construct GetConstruct(GlobalState state, string constructString, string constructKey, string parameters,
				IEnumerable<Preprocessor> preProcessors, IEnumerable<PostProcessor> postProcessors)
			{
				constructString.RequireFilled(nameof(constructString));
				constructKey.RequireFilled(nameof(constructKey));

				var error = $"Unable to find a construct class with key '{constructKey}' for '{constructString}'.";

				var type = ConstructTypes.FirstNotNullOrDefault(constructKey);

				if (type == null)
				{
					throw new KeyNotFoundException(error);
				}

				var construct = Activator.CreateInstance(type, state, constructString, parameters, preProcessors, postProcessors) as Construct;

				if (construct == null)
				{
					throw new KeyNotFoundException(error);
				}

				return construct;
			}
		}

		private static class ProcessorFactory
		{
			public static StageProcessor GetProcessor<TProcessor>(GlobalState state,
				string processorString, string processorKey, string parameters)
				where TProcessor : ProcessorAttribute
			{
				processorString.RequireFilled(nameof(processorString));
				processorKey.RequireFilled(nameof(processorKey));

				var error = $"Unable to find a processor class with key '{processorKey}' for '{processorString}'.";

				var type = ProcessorTypes.FirstNotNullOrDefault(processorKey + typeof(TProcessor).FullName);

				if (type == null)
				{
					throw new KeyNotFoundException(error);
				}

				var processor = Activator.CreateInstance(type, state, processorString, parameters) as StageProcessor;

				if (processor == null)
				{
					throw new KeyNotFoundException(error);
				}

				return processor;
			}
		}
		
		#endregion

		public class GlobalState
		{
			public readonly IOrganizationService Service;
			public readonly Guid? OrgId;

			public Entity Context;

			public int Lcid = 1033;

			public readonly IDictionary<string, string> Templates = new Dictionary<string, string>();

			private readonly IDictionary<string, object> cache = new Dictionary<string, object>();
			private readonly IDictionary<string, object> memory = new Dictionary<string, object>();

			private readonly IDictionary<string, string> tokens = new Dictionary<string, string>();
			private int nextIndex = 1;

			public GlobalState(IOrganizationService service, Guid? orgId = null)
			{
				Service = service;
				OrgId = orgId;
			}

			public GlobalState(Entity context, IOrganizationService service, Guid? orgId = null) : this(service, orgId)
			{
				Context = context;
			}

			public string GenerateToken(string str)
			{
				var index = nextIndex.ToString();
				nextIndex++;
				tokens[index] = str;
				return index;
			}

			public string GetToken(string token)
			{
				return tokens.TryGetValue(token, out var str) ? str : null;
			}

			public T AddCached<T>(string key, T obj, bool isGlobal = false)
			{
				if (isGlobal)
				{
					CacheHelpers.AddToMemCache(key, obj, Service, fallbackCacheDuration: fallbackCacheDuration, orgId: OrgId);
				}
				else
				{
					cache[key] = obj;
				}

				return obj;
			}

			public T GetCachedAdd<T>(string key, Func<T> objFunc, bool isGlobal = false)
			{
				var cached = GetCached<T>(key);

				if (cached != null)
				{
					return cached;
				}

				var obj = objFunc();

				if (isGlobal)
				{
					CacheHelpers.AddToMemCache(key, obj, Service, fallbackCacheDuration: fallbackCacheDuration, orgId: OrgId);
				}
				else
				{
					cache[key] = obj;
				}

				return obj;
			}

			public T GetCached<T>(string key)
			{
				return cache.TryGetValue(key, out var obj) && obj is T cast
					? cast
					: (CacheHelpers.GetFromMemCache<object>(key, orgId: OrgId) is T castGlobal ? castGlobal : default);
			}

			public string GetCached(string key)
			{
				return GetCached<string>(key);
			}

			public T Store<T>(string key, T obj)
			{
				memory[key] = obj;
				return obj;
			}

			public T Read<T>(string key)
			{
				return memory.TryGetValue(key, out var obj) && obj is T cast ? cast : default;
			}

			public string Read(string key)
			{
				return Read<string>(key);
			}
		}

		#region Definitions

		public enum ValueForm
		{
			Raw,
			Name,
			LogicalName,
			Id
		}

		public abstract class Processor
		{
			public readonly string ProcessorString;
			public readonly string ParametersString;

			protected string CleanParameters => Unescape(ParametersString);

			protected readonly GlobalState State;

			protected string Name
			{
				get
				{
					var processorAttribute =
						this.GetAttribute<PreprocessorAttribute>()
							?? this.GetAttribute<ConstructAttribute>() as ProcessorAttribute
								?? this.GetAttribute<PostProcessorAttribute>();

					var processorName = processorAttribute?.LongForm.IsFilled() == true
						? $"{processorAttribute.LongForm} ({processorAttribute.Key})"
						: processorAttribute?.Key;

					return processorName;
				}
			}

			protected Processor(GlobalState state, string processorString, string parameters)
			{
				State = state;
				ProcessorString = processorString;
				ParametersString = parameters;
			}

			protected void RequireParameter()
			{
				ParametersString.RequireFilled(nameof(ParametersString), $"Parameter for '{Name}'"
					+ $" {GetType().BaseType?.Name} is missing for '{ProcessorString}'");
			}

			protected void ThrowMisformattedParam(string paramName = null)
			{
				throw new FormatException($"Parameter {(paramName.IsFilled() ? $"'{paramName}' " : "")}for '{Name}'"
					+ $" {GetType().BaseType?.Name} is misformatted for '{ProcessorString}'");
			}

			public ProcessorParameters ExtractParameters(int minCount = 1, bool isRegexRequired = false)
			{
				var match = Regex.Match(ParametersString, ParameterPattern, RegexOptions.IgnorePatternWhitespace);
				var regex = GetRegex(match.Groups[1].Value);

				if (regex == null && isRegexRequired)
				{
					ThrowMisformattedParam();
				}

				var parameters = new List<string>();

				if (!isRegexRequired)
				{
					parameters.AddRange(match.Groups[1].ExtractCaptures());
				}

				parameters.AddRange(match.Groups[2].ExtractCaptures());

				if (parameters.Count < minCount)
				{
					ThrowMisformattedParam();
				}

				return new ProcessorParameters { Params = parameters.Select(Unescape).ToArray(), Regex = regex };
			}

			private RegexParams GetRegex(string buffer)
			{
				if (buffer.IsEmpty())
				{
					return null;
				}

				var match = Regex.Match(buffer, @"^\$`(.*?)`(?:\$`(.*?)`)?$");

				if (!match.Success)
				{
					return null;
				}

				var regex = match.Groups[1].Value;
				var groups = match.Groups[2].Value.Split(',');

				return new RegexParams { Regex = regex, Groups = groups.Any() ? groups : null };
			}

			protected IEnumerable<string> ExtractMatches(string input, ProcessorParameters procParams,
				Func<Capture, string> captureOperation = null, string defaultValue = "")
			{
				captureOperation = captureOperation ?? (s => s.Value);

				var regex = procParams.Regex;

				if (regex == null)
				{
					return new [] { input };
				}

				var parameters = procParams.Params;
				var isLast = parameters.Any(s => s == "last");
				var isSingle = parameters.Any(s => s == "single");

				input = Unescape(input);

				var matches = Regex.Matches(input, regex.Regex).Cast<Match>().ToArray();

				var isCapture = matches.Any(m => m.Groups.Count > 1);

				string[] captures;

				if (isLast)
				{
					captures = matches
						.LastOrDefault()?
						.Groups.Cast<Group>()
						.LastOrDefault()?
						.Captures.Cast<Capture>()
						.Select(captureOperation).ToArray();
				}
				else
				{
					var groups = matches
						.FirstOrDefault()?
						.Groups.Cast<Group>().ToArray();

					var captureGroup = groups?.Skip(1).FirstOrDefault();

					var group = isCapture && captureGroup != null
						? captureGroup
						: groups?.FirstOrDefault();

					captures = group?.Captures.Cast<Capture>().Select(captureOperation).ToArray();
				}

				return captures?.Any() == true ? (isSingle ? captures.Take(1) : captures) : new[] { defaultValue };
			}

			protected IEnumerable<string> Replace(IEnumerable<string> buffer, ProcessorParameters procParams)
			{
				var regex = procParams.Regex;
				var pattern = regex?.Regex ?? procParams.Params.First();

				if (pattern == null)
				{
					return buffer;
				}

				var replacementPattern = regex?.Regex == null ? procParams.Params.Skip(1).First() : procParams.Params.First();

				IDictionary<string, string> replacementMap = null;

				try
				{
					replacementMap = SerialiserHelpers.DeserialiseSimpleJson(replacementPattern);
				}
				catch (FormatException)
				{ }

				return buffer
					.Select(Unescape)
					.Select(s => replacementMap?.Any() != true
						? (regex?.Groups == null
							? Regex.Replace(s, pattern, replacementPattern)
							: s.ReplaceGroups(pattern, regex.Groups.ToDictionary(p => p, _ => replacementPattern)))
						: s.ReplaceGroups(pattern, replacementMap));
			}
		}

		public class ProcessorParameters
		{
			public string[] Params { get; set; }
			public RegexParams Regex { get; set; }
		}

		public abstract class Construct : Processor
		{
			public readonly IReadOnlyList<Preprocessor> Preprocessors;
			public IReadOnlyList<PostProcessor> PostProcessors;

			protected internal Entity Context => State.Context;

			protected internal readonly Stack<PostProcessor> ResetProcessors = new Stack<PostProcessor>();
			protected internal readonly Queue<IModifier> Modifiers = new Queue<IModifier>();

			protected internal bool IsCacheResult = true;
			protected internal bool IsCacheGlobal;

			protected internal int? BackupLcid;

			protected Construct(GlobalState state, string constructString, string parameters,
				IEnumerable<Preprocessor> preProcessors, IEnumerable<PostProcessor> postProcessors)
			: base(state, constructString, parameters)
			{
				Preprocessors = preProcessors.ToArray();
				PostProcessors = postProcessors.ToList();
			}

			public virtual IEnumerable<string> Execute(string block)
			{
				try
				{
					return ExecutePostProcessors(ExecuteConstruct(ExecutePreprocessors(block)).FilterNull().ToArray()).FilterNull()
						.Select(Unescape);
				}
				catch (Exception ex)
				{
					throw new Exception($"CrmParser failed ({ProcessorString}): {ex.BuildShortExceptionMessage()}", ex);
				}
				finally
				{
					State.Lcid = BackupLcid ?? State.Lcid;
				}
			}

			protected string ExecutePreprocessors(string buffer)
			{
				Modifiers.Clear();

				foreach (var preprocessor in Preprocessors)
				{
					if (preprocessor is IModifiable modifiable)
					{
						ApplyModifiers(modifiable);
					}

					if (preprocessor is IModifier modifier)
					{
						Modifiers.Enqueue(modifier);
					}

					buffer = preprocessor.Execute(buffer, this);
				}

				if (this is IModifiable modifiableConstruct)
				{
					ApplyModifiers(modifiableConstruct);
				}

				return buffer;
			}

			private void ApplyModifiers(IModifiable modifiable)
			{
				var modifierCount = Modifiers.Count;

				for (var i = 0; i < modifierCount; i++)
				{
					var modifierDequeue = Modifiers.Dequeue();

					if (!modifierDequeue.Apply(modifiable))
					{
						Modifiers.Enqueue(modifierDequeue);
					}
				}
			}

			protected abstract IEnumerable<string> ExecuteConstruct(string buffer);

			protected IEnumerable<string> ExecutePostProcessors(IReadOnlyList<string> buffer)
			{
				Modifiers.Clear();

				var result =
					(PostProcessors.IsFilled()
						? PostProcessors
							.Aggregate(buffer,
								(current, processor) =>
								{
									if (processor is IModifiable modifiable)
									{
										ApplyModifiers(modifiable);
									}

									if (processor is IModifier modifier)
									{
										Modifiers.Enqueue(modifier);
									}

									return processor.Execute(current).ToArray();
								})
							.FilterNull()
						: buffer);

				// clean up
				while (ResetProcessors.Count > 0)
				{
					result = ResetProcessors.Pop().Execute(result);
				}

				return result;
			}
		}

		public abstract class DefaultConstruct : Construct
		{
			protected DefaultConstruct(GlobalState state, string constructString, string parameters,
				IEnumerable<Preprocessor> preProcessors, IEnumerable<PostProcessor> postProcessors)
				: base(state, constructString, parameters, preProcessors, postProcessors)
			{ }

			protected override IEnumerable<string> ExecuteConstruct(string buffer)
			{
				return ExecuteLogic(Parse(ParseExpression(buffer, State), State));
			}

			protected abstract IEnumerable<string> ExecuteLogic(string buffer);
		}

		public abstract class DefaultContextConstruct : DefaultConstruct
		{
			protected DefaultContextConstruct(GlobalState state, string constructString, string parameters,
				IEnumerable<Preprocessor> preProcessors, IEnumerable<PostProcessor> postProcessors)
				: base(state, constructString, parameters, preProcessors, postProcessors)
			{ }
			
			protected override IEnumerable<string> ExecuteLogic(string buffer)
			{
				Context.Require(nameof(Context),
					$"An entity context was not provided for the '{GetType().Name}' construct for '{ProcessorString}'.");
				return new[] { ExecuteContextLogic(Context, Parse(ParseExpression(buffer, State), State)) };
			}

			protected abstract string ExecuteContextLogic(Entity context, string buffer);
		}

		public abstract class StageProcessor : Processor
		{
			protected StageProcessor(GlobalState state, string processorString, string parameters) : base(state, processorString, parameters)
			{ }
		}

		public abstract class Preprocessor : StageProcessor
		{
			protected Preprocessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{ }

			public abstract string Execute(string block, Construct construct);
		}

		public abstract class PostProcessor : StageProcessor
		{
			protected PostProcessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{ }

			public abstract IEnumerable<string> Execute(IEnumerable<string> buffer);

			protected IEnumerable<string> ApplyToCaptures(IEnumerable<string> buffer, Func<string, string> action, RegexParams regex)
			{
				return buffer
					.Select(Unescape)
					.Select(s => regex?.Regex == null ? action(s) : s.ReplaceGroups(regex.Regex, action));
			}
		}

		public class RuntimeGenerated : Attribute
		{ }

		public interface IModifier
		{
			bool Apply(IModifiable target);
		}

		public interface IModifiable
		{ }

		public interface IQuery : IModifiable
		{
			IReadOnlyList<string> Distinct { get; set; }
			IReadOnlyList<string> Order { get; set; }
		}

		public class RowValue
		{
			public virtual string StringValue
			{
				get
				{
					var key = $"CrmParser.RowValue.StringValue|{Context.LogicalName}|{Context.Id}";
					return StringValueInner.IsFilled()
						? StringValueInner
						: (State.Service == null
							? $"{Context.LogicalName}:{Context.Id.ToString().ToUpper()}"
							: State.GetCachedAdd(key,
								() => CrmHelpers.GetRecordName(State.Service, Context, true, null, State.OrgId),
								IsCacheGlobal));
				}
				set => StringValueInner = value;
			}

			public readonly Entity Context;

			public readonly GlobalState State;

			protected readonly bool IsCacheGlobal;
			protected string StringValueInner;

			public RowValue(Entity context, GlobalState state, bool isCacheGlobal)
			{
				Context = context;
				State = state;
				IsCacheGlobal = isCacheGlobal;
			}

			public override string ToString()
			{
				return StringValue;
			}
		}

		public class FieldValue : RowValue
		{
			public override string StringValue
			{
				get => StringValueInner.IsFilled() ? StringValueInner : CrmHelpers.GetAttributeStringRep(FieldName, Context);
				set => StringValueInner = value;
			}

			public readonly string FieldName;
			public object Value => Context.GetAttributeValue<object>(FieldName);

			public FieldValue(Entity context, string fieldName, GlobalState state, bool isCacheGlobal)
				: base(context, state, isCacheGlobal)
			{
				FieldName = fieldName;
			}
		}

		[AttributeUsage(AttributeTargets.Class)]
		public class ProcessorAttribute : Attribute
		{
			public readonly string Key;
			public readonly string LongForm;

			public ProcessorAttribute(string key, string longForm = null)
			{
				Key = key;
				LongForm = longForm;
			}
		}

		public class RegexParams
		{
			protected internal string Regex { get; set; }
			protected internal string[] Groups { get; set; }
		}

		[AttributeUsage(AttributeTargets.Class)]
		public class ConstructAttribute : ProcessorAttribute
		{
			public ConstructAttribute(string key, string longForm = null) : base(key, longForm)
			{ }
		}

		[AttributeUsage(AttributeTargets.Class)]
		public class PreprocessorAttribute : ProcessorAttribute
		{
			public PreprocessorAttribute(string key, string longForm = null) : base(key, longForm)
			{ }
		}

		[AttributeUsage(AttributeTargets.Class)]
		public class PostProcessorAttribute : ProcessorAttribute
		{
			public PostProcessorAttribute(string key, string longForm = null) : base(key, longForm)
			{ }
		}
		
		#endregion

		#region Constructs

		[Construct("t")]
		public class TemplateConstruct : Construct
		{
			public TemplateConstruct(GlobalState state, string constructString, string parameters, IEnumerable<Preprocessor> preProcessors,
				IEnumerable<PostProcessor> postProcessors)
				: base(state, constructString, parameters, preProcessors, postProcessors)
			{ }

			protected override IEnumerable<string> ExecuteConstruct(string buffer)
			{
				RequireParameter();

				var detokenised = buffer;

				do
				{
					buffer = detokenised;
					detokenised = DeTokenise(buffer, TokenPattern, State);
				}
				while (detokenised != buffer);
				
				State.Templates[CleanParameters] = detokenised;

				return Array.Empty<string>();
			}
		}

		[Construct("p")]
		public class PlaceholderConstruct : Construct
		{
			public PlaceholderConstruct(GlobalState state, string constructString, string parameters, IEnumerable<Preprocessor> preProcessors,
				IEnumerable<PostProcessor> postProcessors)
				: base(state, constructString, parameters, preProcessors, postProcessors)
			{ }

			protected override IEnumerable<string> ExecuteConstruct(string buffer)
			{
				RequireParameter();

				var replacements = ExtractParameters(2).Params;

				if ((replacements.Length % 2) != 0)
				{
					ThrowMisformattedParam();
				}

				var isFound = State.Templates.TryGetValue(Unescape(buffer), out var template);

				if (!isFound)
				{
					throw new KeyNotFoundException($"Template '{buffer}' for 'placeholder (p)' construct is undefined for '{ProcessorString}'");
				}

				buffer = template;

				for (var i = 0; i < replacements.Length; i += 2)
				{
					buffer = buffer.Replace(replacements[i], replacements[i + 1]);
				}

				return new[] { Parse(Tokenise(buffer, State), State) };
			}
		}

		[Construct(".")]
		public class ReferenceConstruct : Construct, IQuery
		{
			public IReadOnlyList<string> Distinct { get; set; }
			public IReadOnlyList<string> Order { get; set; }

			public ReferenceConstruct(GlobalState state, string constructString, string parameters, IEnumerable<Preprocessor> preProcessors,
				IEnumerable<PostProcessor> postProcessors)
				: base(state, constructString, parameters, preProcessors, postProcessors)
			{ }

			protected override IEnumerable<string> ExecuteConstruct(string buffer)
			{
				Context.Require(nameof(Context),
					$"An entity context was not provided for the 'context switch (.)' construct for '{ProcessorString}'.");
				RequireParameter();

				var backupContext = Context;
				backupContext.Require(nameof(backupContext), "An entity context was not provided for the 'context switch (.)' construct.");

				var match = Regex.Match(Unescape(ParametersString),
					@"^([a-zA-Z0-9_]+)(?:((?:\.?|!)[a-zA-Z0-9_]+))*((?:,(?:[a-zA-Z0-9_]+))*)$");

				if (!match.Success)
				{
					return new[] { buffer };
				}

				var output = new List<string>();
				var scopeName = match.Groups[1].Value;

				var switches = match.Groups[3].ExtractCaptures().Select(e => e.Trim(',')).ToArray();
				var isGlobal = switches.LastOrDefault() == "global";
				
				// context given name
				var contextName = switches.Length > 1 && switches[1] != "global" ? switches[1] : null;

				// loop element name
				var localVarName = switches.Length > 2 && switches[2] != "global" ? switches[2] : null;

				var storedScope = State.Read<object>(scopeName);
				var scope = new List<object>();

				if (storedScope is Func<object> storedFunc)
				{
					storedScope = storedFunc();
				}

				if (storedScope is IEnumerable<object> storedCollection)
				{
					scope.AddRange(storedCollection);
				}
				else
				{
					scope.Add(storedScope);
				}

				var isContextStored = scope.FirstOrDefault() is Entity;

				var localContexts = isContextStored ? scope.Cast<Entity>() : new[] { Context };

				foreach (var context in localContexts)
				{
					var traversalContexts = BuildTraversalContext(context, match.Groups[2].ExtractCaptures(), State, Distinct, Order, IsCacheGlobal);

					foreach (var traversalContext in traversalContexts)
					{
						if (contextName.IsFilled())
						{
							State.Store(contextName, traversalContext);
						}

						State.Context = traversalContext;

						if (localVarName.IsFilled())
						{
							if (isContextStored)
							{
								State.Store(localVarName, traversalContext);
								output.Add(Parse(ParseExpression(buffer, State), State));
							}
							else
							{
								foreach (var element in scope)
								{
									State.Store(localVarName, element);
									output.Add(Parse(ParseExpression(buffer, State), State));
								}
							}
						}
						else
						{
							output.Add(Parse(ParseExpression(buffer, State), State));
						}
						
						if (!isGlobal)
						{
							State.Context = backupContext;
						}
					}
				}

				return output;
			}
		}

		[Construct("c")]
		public class ColumnConstruct : DefaultContextConstruct
		{
			public ColumnConstruct(GlobalState state, string constructString, string parameters, IEnumerable<Preprocessor> preProcessors,
				IEnumerable<PostProcessor> postProcessors)
				: base(state, constructString, parameters, preProcessors, postProcessors)
			{ }

			protected override string ExecuteContextLogic(Entity context, string buffer)
			{
				var match = Regex.Match(Unescape(buffer), @"^([a-zA-Z0-9_]+?)(?:\.([a-zA-Z0-9_]+?))*$");

				if (!match.Success)
				{
					return null;
				}

				var initialFieldName = match.Groups[1].Value;
				var traversal = new[] { initialFieldName }.Union(match.Groups[2].ExtractCaptures()).ToArray();

				FieldValue returnValue = null;

				foreach (var fieldName in traversal)
				{
					var fieldValue = context.GetAttributeValue<object>(fieldName);

					// get the entity record
					context = fieldValue == null && context.LogicalName.IsFilled() && context.Id != Guid.Empty
						? context.IntegrateAttributes(Retrieve(State, context.LogicalName, context.Id, IsCacheGlobal, fieldName))
						: context;

					fieldValue = context.GetAttributeValue<object>(fieldName);

					returnValue = new FieldValue(context, fieldName, State, IsCacheGlobal);

					// if the field value is not a lookup, then we can't recurse
					if (!(fieldValue is EntityReference reference))
					{
						break;
					}

					context =
						new Entity(reference.LogicalName)
						{
							Id = reference.Id
						};
				}

				var key = $"CrmParser.ColumnConstruct.ExecuteContextLogic|{context.LogicalName}|{context.Id}|{traversal.StringAggregate()}";

				if (returnValue == null)
				{
					return null;
				}

				if (CleanParameters.IsEmpty())
				{
					return returnValue.StringValue;
				}

				switch (CleanParameters)
				{
					case "raw":
						return returnValue.ToString();
					case "name":
						return
							returnValue.Value is OptionSetValue optionSet && State.Lcid != 1033
								? MetadataHelpers.GetOptionSetLabel(State.Service, returnValue.Context.LogicalName, returnValue.FieldName,
									optionSet.Value, State.Lcid, State.OrgId)
								: CrmHelpers.GetAttributeName(returnValue.FieldName, returnValue.Context);
					case "log":
						return returnValue.Value is EntityReference er1 ? er1.LogicalName : "";
					case "id":
						return
							(returnValue.Value is EntityReference er2
								? er2.Id
								: returnValue.Value is Guid id
									? id
									: (Guid?)null)?
								.ToString().ToUpper();
					case "url":
						return
							returnValue.Value is EntityReference er3
								? State.GetCachedAdd(key, () => CrmHelpers.GetRecordUrl(State.Service, er3, State.OrgId), IsCacheGlobal)
								: "";
					default:
						return returnValue.StringValue;
				}
			}
		}
		
		[Construct("i")]
		public class RowInfoConstruct : DefaultContextConstruct
		{
			public RowInfoConstruct(GlobalState state, string constructString, string parameters, IEnumerable<Preprocessor> preProcessors,
				IEnumerable<PostProcessor> postProcessors)
				: base(state, constructString, parameters, preProcessors, postProcessors)
			{ }

			protected override string ExecuteContextLogic(Entity context, string buffer)
			{
				buffer = Unescape(buffer);
				buffer.RequireFilled("block", $"Block for 'row info' construct is missing for '{ProcessorString}'.");
				var key = $"CrmParser.RowInfoConstruct.ExecuteContextLogic|{buffer}|{context.LogicalName}|{context.Id}";

				switch (buffer)
				{
					case "raw":
						return $"{context.LogicalName}:{context.Id.ToString().ToUpper()}";
					case "name":
						return 
							State.GetCachedAdd($"{key}|name",
							() => CrmHelpers.GetRecordName(State.Service, context, true, null, State.OrgId),
							IsCacheGlobal);
					case "log":
						return context.LogicalName;
					case "id":
						return context.Id.ToString().ToUpper();
					case "url":
						return
							State.GetCachedAdd($"{key}|url",
							() => CrmHelpers.GetRecordUrl(State.Service, context.ToEntityReference(), State.OrgId),
							IsCacheGlobal);
					default:
						throw new NotSupportedException($"Value for 'row info' construct"
							+ $" is not supported ('{buffer}') for '{ProcessorString}'.");
				}
			}
		}

		[Construct("u")]
		public class UserInfoConstruct : DefaultContextConstruct
		{
			public UserInfoConstruct(GlobalState state, string constructString, string parameters, IEnumerable<Preprocessor> preProcessors,
				IEnumerable<PostProcessor> postProcessors)
				: base(state, constructString, parameters, preProcessors, postProcessors)
			{ }

			protected override string ExecuteContextLogic(Entity context, string buffer)
			{
				var isId = Guid.TryParse(ExtractParameters(0).Params.FirstOrDefault(), out var userIdParam);

				buffer = Unescape(buffer);
				buffer.RequireFilled("block", $"Block for {Name} construct is missing for '{ProcessorString}'.");
				var key = $"CrmParser.UserInfoConstruct.ExecuteContextLogic|{buffer}|{context.LogicalName}|{context.Id}";

				var userId = isId ? userIdParam : ((WhoAmIResponse)State.Service.Execute(new WhoAmIRequest())).UserId;
				const string logicalName = "systemuser";
				var user = new Entity("systemuser", userId);

				switch (buffer)
				{
					case "raw":
						return $"{logicalName}:{userId.ToString().ToUpper()}";
					case "name":
						return 
							State.GetCachedAdd($"{key}|name",
							() => CrmHelpers.GetRecordName(State.Service, user, true, null, State.OrgId),
							IsCacheGlobal);
					case "log":
						return logicalName;
					case "id":
						return userId.ToString().ToUpper();
					case "lcid":
						return 
							State.GetCachedAdd($"{key}|lcid",
							() => (int?)CrmHelpers.GetPreferredLangCode(State.Service, user.ToEntityReference()),
							IsCacheGlobal).ToString();
					case "url":
						return
							State.GetCachedAdd($"{key}|url",
							() => CrmHelpers.GetRecordUrl(State.Service, user.ToEntityReference(), State.OrgId),
							IsCacheGlobal);
					default:
						throw new NotSupportedException($"Value for 'row info' construct"
							+ $" is not supported ('{buffer}') for '{ProcessorString}'.");
				}
			}
		}

		[Construct("<")]
		public class PreloadConstruct : DefaultContextConstruct
		{
			public PreloadConstruct(GlobalState state, string constructString, string parameters, IEnumerable<Preprocessor> preProcessors,
				IEnumerable<PostProcessor> postProcessors)
				: base(state, constructString, parameters, preProcessors, postProcessors)
			{ }

			protected override string ExecuteContextLogic(Entity context, string buffer)
			{
				buffer = Unescape(buffer);
				buffer.RequireFilled("block", $"Block for '{Name}' construct is missing for '{ProcessorString}'.");

				var match = Regex.Match(Unescape(buffer), @"^([a-zA-Z0-9_]+?)(?:,([a-zA-Z0-9_]+?))*$",
					RegexOptions.IgnorePatternWhitespace);

				if (!match.Success)
				{
					return null;
				}

				var initialFieldName = match.Groups[1].Value;
				var list = new[] { initialFieldName }.Union(match.Groups[2].ExtractCaptures()).ToArray();

				if (context.Attributes.Keys.Intersect(list).Count() == list.Length)
				{
					return null;
				}
				
				context.IntegrateAttributes(Retrieve(State, context.LogicalName, context.Id, IsCacheGlobal, list));

				return null;
			}
		}

		[Construct("_")]
		public class DiscardConstruct : DefaultContextConstruct
		{
			public DiscardConstruct(GlobalState state, string constructString, string parameters, IEnumerable<Preprocessor> preProcessors,
				IEnumerable<PostProcessor> postProcessors)
				: base(state, constructString, parameters, preProcessors, postProcessors)
			{ }

			public override IEnumerable<string> Execute(string block)
			{
				base.Execute(block);
				return Array.Empty<string>();
			}

			protected override string ExecuteContextLogic(Entity context, string buffer)
			{
				return buffer;
			}
		}

		[Construct("e")]
		public class ExpressionConstruct : DefaultContextConstruct
		{
			public ExpressionConstruct(GlobalState state, string constructString, string parameters, IEnumerable<Preprocessor> preProcessors,
				IEnumerable<PostProcessor> postProcessors)
				: base(state, constructString, parameters, preProcessors, postProcessors)
			{ }

			protected override string ExecuteContextLogic(Entity context, string buffer)
			{
				return buffer;
			}
		}

		// TODO ConfigConstruct
		[Construct("s")]
		public class ConfigConstruct : Construct
		{
			public ConfigConstruct(GlobalState state, string constructString, string parameters, IEnumerable<Preprocessor> preProcessors,
				IEnumerable<PostProcessor> postProcessors)
				: base(state, constructString, parameters, preProcessors, postProcessors)
			{ }

			protected override IEnumerable<string> ExecuteConstruct(string buffer)
			{
				RequireParameter();

				var match = Regex.Match(ParametersString, @"^(this)(?:((?:\.?|!)[a-zA-Z0-9_]+))*((?:,(?:global))*)$");

				if (!match.Success)
				{
					return new[] { buffer };
				}

				var output = new List<object>();
				var scope = match.Groups[1].Value;

				if (scope != "this")
				{
					throw new NotSupportedException($"Reference scope '{scope}' for 'context switch (r)' construct"
						+ $" is not supported for '{ProcessorString}'.");
				}

				var switches = match.Groups[3].ExtractCaptures().Select(e => e.Trim(','));
				var isGlobal = switches.Contains("global");

				return null;
			}
		}

		[Construct("r")]
		public class ReplaceConstruct : DefaultContextConstruct
		{
			public ReplaceConstruct(GlobalState state, string constructString, string parameters, IEnumerable<Preprocessor> preProcessors,
				IEnumerable<PostProcessor> postProcessors)
				: base(state, constructString, parameters, preProcessors, postProcessors)
			{ }

			protected override string ExecuteContextLogic(Entity context, string buffer)
			{
				RequireParameter();
				var procParams = ExtractParameters(1, true);
				return Replace(new [] { buffer }, procParams).FirstOrDefault();
			}
		}

		[Construct("v")]
		public class DictionaryConstruct : DefaultContextConstruct
		{
			public DictionaryConstruct(GlobalState state, string constructString, string parameters, IEnumerable<Preprocessor> preProcessors,
				IEnumerable<PostProcessor> postProcessors)
				: base(state, constructString, parameters, preProcessors, postProcessors)
			{ }

			protected override string ExecuteContextLogic(Entity context, string buffer)
			{
				var fetch =
					$@"<fetch no-lock='true'>
  <entity name='ys_keyvalue' >
    <attribute name='ys_value' />
    <attribute name='ys_value{(State.Lcid == 1033 ? "" : $"_{State.Lcid}")}' />
    <filter>
      <condition attribute='ys_name' operator='eq' value='{Unescape(buffer)}' />
    </filter>
  </entity>
</fetch>";

				return RetrieveMultiple(State.Service, State, fetch, IsCacheGlobal).FirstOrDefault()?.GetAttributeValue<string>("ys_value");
			}
		}

		[Construct("g")]
		public class CommonConfigConstruct : DefaultContextConstruct
		{
			public CommonConfigConstruct(GlobalState state, string constructString, string parameters, IEnumerable<Preprocessor> preProcessors,
				IEnumerable<PostProcessor> postProcessors)
				: base(state, constructString, parameters, preProcessors, postProcessors)
			{ }

			protected override string ExecuteContextLogic(Entity context, string buffer)
			{
				buffer = Unescape(buffer);
				buffer.RequireFilled("block", $"Block for '{Name}' construct is missing for '{ProcessorString}'.");

				var config = CrmHelpers.GetGenericConfig(State.Service, State.OrgId);
				var value = CrmHelpers.GetGenericConfig(State.Service, State.OrgId).GetAttributeValue<object>(buffer);

				return
					value is OptionSetValue optionSet && State.Lcid != 1033
						? MetadataHelpers.GetOptionSetLabel(State.Service, config.LogicalName, buffer,
							optionSet.Value, State.Lcid, State.OrgId)
						: CrmHelpers.GetAttributeName(buffer, config);
			}
		}
		
		[Construct("f")]
		public class FetchConstruct : DefaultContextConstruct
		{
			public FetchConstruct(GlobalState state, string constructString, string parameters, IEnumerable<Preprocessor> preProcessors,
				IEnumerable<PostProcessor> postProcessors)
				: base(state, constructString, parameters, preProcessors, postProcessors)
			{ }

			protected override string ExecuteContextLogic(Entity context, string buffer)
			{
				RequireParameter();

				var name = ExtractParameters().Params.First();

				if (name.IsEmpty())
				{
					ThrowMisformattedParam(nameof(name));
				}

				State.Store(name, new Func<Entity[]>(() =>
					RetrieveMultiple(State.Service, State, Unescape(buffer), IsCacheGlobal)));

				return null;
			}
		}
		
		[Construct("a")]
		public class ActionConstruct : DefaultContextConstruct
		{
			public ActionConstruct(GlobalState state, string constructString, string parameters, IEnumerable<Preprocessor> preProcessors,
				IEnumerable<PostProcessor> postProcessors)
				: base(state, constructString, parameters, preProcessors, postProcessors)
			{ }

			protected override string ExecuteContextLogic(Entity context, string buffer)
			{
				RequireParameter();

				var parameters = ExtractParameters(0).Params;
				var storeName = parameters.FirstOrDefault();
				var input = parameters.Length > 1 ? parameters.Skip(1).FirstOrDefault(p => p != "global") : null;
				var isGlobal = parameters.Any(p => p == "global");

				State.Store(storeName, new Func<Entity>(() =>
					CallAction(State.Service, Unescape(buffer), isGlobal ? null : context.ToEntityReference(), input)));

				return null;
			}
		}

		#endregion

		#region Preprocessors

		[Preprocessor("filter")]
		public class FilterPreprocessor : Preprocessor, IModifier
		{
			public FilterPreprocessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{ }

			public override string Execute(string block, Construct construct)
			{
				return block;
			}

			public bool Apply(IModifiable target)
			{
				throw new NotImplementedException();
			}
		}

		[Preprocessor("distinct")]
		public class DistinctPreprocessor : Preprocessor, IModifier
		{
			public DistinctPreprocessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{
				RequireParameter();
			}

			public override string Execute(string block, Construct construct)
			{
				return block;
			}

			public bool Apply(IModifiable target)
			{
				if (target is IQuery query && ParametersString.IsFilled())
				{
					query.Distinct = ParametersString.Split(',');
					return true;
				}

				return false;
			}
		}

		[Preprocessor("order")]
		public class OrderPreprocessor : Preprocessor, IModifier
		{
			public OrderPreprocessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{
				RequireParameter();
			}

			public override string Execute(string block, Construct construct)
			{
				return block;
			}

			public bool Apply(IModifiable target)
			{
				if (target is IQuery query && ParametersString.IsFilled())
				{
					query.Order = ParametersString.Split(',');
					return true;
				}

				return false;
			}
		}

		[Preprocessor("cache")]
		public class CachePreprocessor : Preprocessor
		{
			public CachePreprocessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{
				RequireParameter();
			}

			public override string Execute(string block, Construct construct)
			{
				var split = ParametersString.Split(',');

				if (bool.TryParse(split.FirstOrDefault(), out var isCache))
				{
					construct.IsCacheResult = isCache;
				}

				if (split.Length > 1 && split[1] == "global")
				{
					construct.IsCacheGlobal = true;
				}

				return block;
			}
		}

		[Preprocessor("store")]
		public class StorePreprocessor : Preprocessor
		{
			public StorePreprocessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{
				RequireParameter();
			}

			public override string Execute(string block, Construct construct)
			{
				return State.Store(ParametersString, block);
			}
		}

		[Preprocessor("read")]
		public class ReadPreprocessor : Preprocessor
		{
			public ReadPreprocessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{
				RequireParameter();
			}

			public override string Execute(string block, Construct construct)
			{
				switch (State.Read<object>(ParametersString))
				{
					case string str:
						return str;
					case IEnumerable<object> e:
						return e.StringAggregate("");
					default:
						return "";
				}
			}
		}

		[Preprocessor("local")]
		public class LocalisePreprocessor : Preprocessor, IModifier
		{
			public LocalisePreprocessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{
				RequireParameter();
			}

			public override string Execute(string block, Construct construct)
			{
				return block;
			}

			public bool Apply(IModifiable target)
			{
				if (target is Construct construct && ParametersString.IsFilled())
				{
					var parameters = ParametersString.Split(',');
					var isLcid = int.TryParse(parameters.FirstOrDefault(), out var lcid);
					var isGlobal = parameters.Any(p => p == "global");

					if (isLcid)
					{
						if (!isGlobal)
						{
							construct.BackupLcid = State.Lcid;
						}

						State.Lcid = lcid;
					}

					return true;
				}

				return false;
			}
		}

		#endregion

		#region Post processors

		[PostProcessor("store")]
		public class StorePostProcessor : PostProcessor
		{
			public StorePostProcessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{
				RequireParameter();
			}

			public override IEnumerable<string> Execute(IEnumerable<string> buffer)
			{
				return State.Store(ParametersString, buffer.FilterNull());
			}
		}

		[PostProcessor("read")]
		public class ReadPostProcessor : PostProcessor
		{
			public ReadPostProcessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{
				RequireParameter();
			}

			public override IEnumerable<string> Execute(IEnumerable<string> buffer)
			{
				switch (State.Read<object>(ParametersString))
				{
					case string str:
						return new[] { str };
					case IEnumerable<string> e:
						return e;
					default:
						return Array.Empty<string>();
				}
			}
		}

		[PostProcessor("discard")]
		public class DiscardPostProcessor : PostProcessor
		{
			public DiscardPostProcessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{ }

			public override IEnumerable<string> Execute(IEnumerable<string> buffer)
			{
				return buffer.Select(_ => (string)null);
			}
		}

		[PostProcessor("sub")]
		public class StringSubPostProcessor : PostProcessor
		{
			public StringSubPostProcessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{ }

			public override IEnumerable<string> Execute(IEnumerable<string> buffer)
			{
				RequireParameter();

				var processorParameters = ExtractParameters();
				var parameters = processorParameters.Params;

				var isStart = int.TryParse(parameters.First(), out var start);

				if (!isStart)
				{
					ThrowMisformattedParam(nameof(start));
				}

				var isLength = int.TryParse(parameters.Skip(1).First(), out var length);

				return ApplyToCaptures(buffer, s => isLength ? s.Substring(start, length) : s.Substring(start), processorParameters.Regex);
			}
		}

		[PostProcessor("trim")]
		public class StringTrimPostProcessor : PostProcessor
		{
			public StringTrimPostProcessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{ }

			public override IEnumerable<string> Execute(IEnumerable<string> buffer)
			{
				RequireParameter();

				var processorParameters = ExtractParameters();
				var parameters = processorParameters.Params;

				var characters = parameters.First().ToCharArray();
				var isStart = parameters.Skip(1).Any(e => e == "start");
				var isEnd = parameters.Skip(1).Any(e => e == "end");

				return ApplyToCaptures(buffer,
					s =>
					{
						if (isStart)
						{
							s = s.TrimStart(characters);
						}

						if (isEnd)
						{
							s = s.TrimEnd(characters);
						}

						if (!isStart && !isEnd)
						{
							s = s.Trim(characters);
						}

						return s;
					},
					processorParameters.Regex);
			}
		}

		[PostProcessor("pad")]
		public class StringPadPostProcessor : PostProcessor
		{
			public StringPadPostProcessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{ }

			public override IEnumerable<string> Execute(IEnumerable<string> buffer)
			{
				RequireParameter();

				var processorParameters = ExtractParameters(2);
				var parameters = processorParameters.Params;

				var character = parameters.First().ToCharArray().FirstOrDefault();

				if (character == default(char))
				{
					ThrowMisformattedParam(nameof(character));
				}

				var isLength = int.TryParse(parameters.Skip(1).First(), out var length);

				if (!isLength)
				{
					ThrowMisformattedParam(nameof(length));
				}

				var isRight = parameters.Skip(2).Any(e => e == "right");

				return ApplyToCaptures(
					buffer,
					s => isRight
						? s.PadRight(length, character)
						: s.PadLeft(length, character),
					processorParameters.Regex);
			}
		}

		[PostProcessor("length")]
		public class StringLengthPostProcessor : PostProcessor
		{
			public StringLengthPostProcessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{ }

			public override IEnumerable<string> Execute(IEnumerable<string> buffer)
			{
				var processorParameters = ExtractParameters(0);
				var output = new List<string>();

				ApplyToCaptures(
					buffer,
					s =>
					{
						output.Add(s.Length.ToString());
						return null;
					},
					processorParameters.Regex).ToArray();

				return output;
			}
		}

		[PostProcessor("upper")]
		public class StringUpperPostProcessor : PostProcessor
		{
			public StringUpperPostProcessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{ }

			public override IEnumerable<string> Execute(IEnumerable<string> buffer)
			{
				return ApplyToCaptures(
					buffer,
					s => s.ToUpper(),
					ExtractParameters(0).Regex);
			}
		}

		[PostProcessor("lower")]
		public class StringLowerPostProcessor : PostProcessor
		{
			public StringLowerPostProcessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{ }

			public override IEnumerable<string> Execute(IEnumerable<string> buffer)
			{
				return ApplyToCaptures(
					buffer,
					s => s.ToLower(),
					ExtractParameters(0).Regex);
			}
		}

		[PostProcessor("sentence")]
		public class StringSentencePostProcessor : PostProcessor
		{
			public StringSentencePostProcessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{ }

			public override IEnumerable<string> Execute(IEnumerable<string> buffer)
			{
				return ApplyToCaptures(
					buffer,
					s => s.ToSentenceCase(),
					ExtractParameters(0).Regex);
			}
		}

		[PostProcessor("title")]
		public class StringTitlePostProcessor : PostProcessor
		{
			public StringTitlePostProcessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{ }

			public override IEnumerable<string> Execute(IEnumerable<string> buffer)
			{
				return ApplyToCaptures(
					buffer,
					s => s.ToTitleCase(),
					ExtractParameters(0).Regex);
			}
		}

		[PostProcessor("truncate")]
		public class StringTruncatePostProcessor : PostProcessor
		{
			public StringTruncatePostProcessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{ }

			public override IEnumerable<string> Execute(IEnumerable<string> buffer)
			{
				RequireParameter();

				var processorParameters = ExtractParameters();
				var parameters = processorParameters.Params;

				var isLength = int.TryParse(parameters.First(), out var length);

				if (!isLength)
				{
					ThrowMisformattedParam(nameof(length));
				}

				var replacement = parameters.Skip(1).FirstOrDefault();

				return ApplyToCaptures(
					buffer,
					s => s.Truncate(length, replacement),
					processorParameters.Regex);
			}
		}

		[PostProcessor("index")]
		public class StringIndexPostProcessor : PostProcessor
		{
			public StringIndexPostProcessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{ }

			public override IEnumerable<string> Execute(IEnumerable<string> buffer)
			{
				RequireParameter();
				var processorParameters = ExtractParameters(0, true);
				return buffer.Select(s => ExtractMatches(s, processorParameters, c => c.Index.ToString(), "-1").StringAggregate());
			}
		}

		[PostProcessor("extract")]
		public class StringExtractPostProcessor : PostProcessor
		{
			public StringExtractPostProcessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{ }

			public override IEnumerable<string> Execute(IEnumerable<string> buffer)
			{
				RequireParameter();
				var processorParameters = ExtractParameters(0, true);
				return buffer.Select(s => ExtractMatches(s, processorParameters, c => c.Value, null).StringAggregate());
			}
		}

		[PostProcessor("replace")]
		public class StringReplacePostProcessor : PostProcessor
		{
			public StringReplacePostProcessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{ }

			public override IEnumerable<string> Execute(IEnumerable<string> buffer)
			{
				RequireParameter();
				var procParams = ExtractParameters(1, true);
				return Replace(buffer, procParams);
			}
		}

		[PostProcessor("split")]
		public class StringSplitPostProcessor : PostProcessor
		{
			public StringSplitPostProcessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{ }

			public override IEnumerable<string> Execute(IEnumerable<string> buffer)
			{
				RequireParameter();

				var parameters = ExtractParameters();
				var splitString = parameters.Params.FirstOrDefault();

				return buffer.SelectMany(
					s => ExtractMatches(s, parameters)
						.SelectMany(m => m.Split(new[] { splitString }, StringSplitOptions.None)));
			}
		}

		[PostProcessor("date")]
		public class FormatDatePostProcessor : PostProcessor
		{
			public FormatDatePostProcessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{ }

			public override IEnumerable<string> Execute(IEnumerable<string> buffer)
			{
				RequireParameter();

				var processorParameters = ExtractParameters();
				var parameters = processorParameters.Params;

				var outputFormat = parameters.First();
				var kindString = parameters.Skip(1).FirstOrDefault();
				var kind = kindString == "utc" ? DateTimeStyles.AssumeUniversal : DateTimeStyles.AssumeLocal;
				var inputFormat = parameters.Skip(2).FirstOrDefault();

				return ApplyToCaptures(
					buffer,
					s => inputFormat.IsFilled()
						&& DateTime.TryParseExact(s, inputFormat, CultureInfo.CurrentCulture, kind, out var parsed)
						? parsed.ToString(outputFormat)
						: (DateTime.TryParse(s, CultureInfo.CurrentCulture, kind, out parsed)
							? parsed.ToString(outputFormat)
							: s),
					processorParameters.Regex);
			}
		}

		[PostProcessor("number")]
		public class FormatNumberPostProcessor : PostProcessor
		{
			public FormatNumberPostProcessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{ }

			public override IEnumerable<string> Execute(IEnumerable<string> buffer)
			{
				RequireParameter();

				var processorParameters = ExtractParameters();
				var parameters = processorParameters.Params;

				var format = parameters.First();

				return ApplyToCaptures(
					buffer,
					s => format.IsFilled() && double.TryParse(s, out var parsed)
						? parsed.ToString(format)
						: s,
					processorParameters.Regex);
			}
		}

		[PostProcessor("clear")]
		public class AggrClearPostProcessor : PostProcessor
		{
			public AggrClearPostProcessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{ }

			public override IEnumerable<string> Execute(IEnumerable<string> buffer)
			{
				return buffer.FilterEmpty();
			}
		}

		[PostProcessor("first")]
		public class AggrFirstPostProcessor : PostProcessor
		{
			public AggrFirstPostProcessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{ }

			public override IEnumerable<string> Execute(IEnumerable<string> buffer)
			{
				return buffer.Take(1);
			}
		}

		[PostProcessor("nth")]
		public class AggrNthPostProcessor : PostProcessor
		{
			public AggrNthPostProcessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{ }

			public override IEnumerable<string> Execute(IEnumerable<string> buffer)
			{
				RequireParameter();

				var isNth = int.TryParse(ExtractParameters().Params.First(), out var nth);

				if (!isNth)
				{
					ThrowMisformattedParam(nameof(nth));
				}

				return buffer.Skip(nth - 1).Take(1);
			}
		}

		[PostProcessor("last")]
		public class AggrLastPostProcessor : PostProcessor
		{
			public AggrLastPostProcessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{ }

			public override IEnumerable<string> Execute(IEnumerable<string> buffer)
			{
				var collection = buffer.ToArray();
				return collection.Skip(collection.Length - 1);
			}
		}

		[PostProcessor("count")]
		public class AggrCountPostProcessor : PostProcessor
		{
			public AggrCountPostProcessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{ }

			public override IEnumerable<string> Execute(IEnumerable<string> buffer)
			{
				return new[] { buffer.Count().ToString() };
			}
		}

		[PostProcessor("join")]
		public class AggrJoinPostProcessor : PostProcessor
		{
			public AggrJoinPostProcessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{ }

			public override IEnumerable<string> Execute(IEnumerable<string> buffer)
			{
				RequireParameter();
				var join = ExtractParameters(0).Params.FirstOrDefault() ?? "";
				return new[] { string.Join(join, buffer) };
			}
		}

		[PostProcessor("min")]
		public class AggrMinPostProcessor : PostProcessor
		{
			public AggrMinPostProcessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{ }

			public override IEnumerable<string> Execute(IEnumerable<string> buffer)
			{
				return
					new[]
					{
						buffer
							.Select(s => double.TryParse(s, out var parsed) ? parsed : (double?)null)
							.FilterNull()
							.Min().ToString()
					};
			}
		}

		[PostProcessor("max")]
		public class AggrMaxPostProcessor : PostProcessor
		{
			public AggrMaxPostProcessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{ }

			public override IEnumerable<string> Execute(IEnumerable<string> buffer)
			{
				return
					new[]
					{
						buffer
							.Select(s => double.TryParse(s, out var parsed) ? parsed : (double?)null)
							.FilterNull()
							.Max().ToString()
					};
			}
		}

		[PostProcessor("avg")]
		public class AggrAvgPostProcessor : PostProcessor
		{
			public AggrAvgPostProcessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{ }

			public override IEnumerable<string> Execute(IEnumerable<string> buffer)
			{
				return
					new[]
					{
						buffer
							.Select(s => double.TryParse(s, out var parsed) ? parsed : (double?)null)
							.FilterNull()
							.Average().ToString()
					};
			}
		}

		[PostProcessor("sum")]
		public class AggrSumPostProcessor : PostProcessor
		{
			public AggrSumPostProcessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{ }

			public override IEnumerable<string> Execute(IEnumerable<string> buffer)
			{
				return
					new[]
					{
						buffer
							.Select(s => double.TryParse(s, out var parsed) ? parsed : (double?)null)
							.FilterNull()
							.Sum().ToString()
					};
			}
		}

		[PostProcessor("top")]
		public class AggrTopPostProcessor : PostProcessor
		{
			public AggrTopPostProcessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{ }

			public override IEnumerable<string> Execute(IEnumerable<string> buffer)
			{
				RequireParameter();

				var isTop = int.TryParse(ExtractParameters().Params.First(), out var top);

				if (!isTop)
				{
					ThrowMisformattedParam(nameof(top));
				}

				return buffer.FilterNull().Take(top);
			}
		}

		[PostProcessor("distinct")]
		public class AggrDistinctPostProcessor : PostProcessor
		{
			public AggrDistinctPostProcessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{ }

			public override IEnumerable<string> Execute(IEnumerable<string> buffer)
			{
				var parameters = ExtractParameters(0);

				return
					parameters?.Regex?.Regex.IsFilled() != true
						? buffer.Distinct()
						: buffer.DistinctBy(s => ExtractMatches(s, parameters).StringAggregate());
			}
		}

		[PostProcessor("order")]
		public class AggrOrderPostProcessor : PostProcessor
		{
			public AggrOrderPostProcessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{ }

			public override IEnumerable<string> Execute(IEnumerable<string> buffer)
			{
				var parameters = ExtractParameters(0);
				var isDesc = parameters?.Params.Any(p => p == "true");

				return
					parameters?.Regex?.Regex.IsFilled() != true
						? buffer.OrderBy(s => s)
						: (isDesc == true
							? buffer.OrderByDescending(s => ExtractMatches(s, parameters).StringAggregate())
							: buffer.OrderBy(s => ExtractMatches(s, parameters).StringAggregate()));
			}
		}

		[PostProcessor("where")]
		public class AggrWherePostProcessor : PostProcessor
		{
			public AggrWherePostProcessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{ }

			public override IEnumerable<string> Execute(IEnumerable<string> buffer)
			{
				RequireParameter();
				return buffer.Where(s => ExtractMatches(s, ExtractParameters(0, true)).FilterEmpty().Any());
			}
		}

		[PostProcessor("filter")]
		public class AggrFilterPostProcessor : PostProcessor
		{
			public AggrFilterPostProcessor(GlobalState state, string processorString, string parameters)
				: base(state, processorString, parameters)
			{ }

			public override IEnumerable<string> Execute(IEnumerable<string> buffer)
			{
				RequireParameter();
				var bufferArray = buffer.ToArray();
				return bufferArray
					.Except(bufferArray
						.Where(s => ExtractMatches(s, ExtractParameters(0, true)).FilterEmpty().Any()));
			}
		}

		[RuntimeGenerated]
		private class InternalActionPostProcessor : PostProcessor
		{
			private readonly Action action;

			public InternalActionPostProcessor(GlobalState state, Action action)
				: base(state, null, null)
			{
				this.action = action;
			}

			public override IEnumerable<string> Execute(IEnumerable<string> buffer)
			{
				action();
				return buffer;
			}
		}

		#endregion
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	//[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static partial class CrmHelpers
	{
		public static string[] NonUpdatableFields =
			{
				"createdby",
				"createdon",
				"createdonbehalfby",
				"importsequencenumber",
				"modifiedby",
				"modifiedon",
				"modifiedonbehalfby",
				"owningbusinessunit",
				"owningteam",
				"owninguser",
				"timezoneruleversionnumber",
				"utcconversiontimezonecode",
				"versionumber",
			};

		/// <summary>
		///     Retrieves the generic configuration record from CRM. All fields are returned.<br />
		///     If none is found, an empty entity record is returned.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="service">CRM Organisation Service</param>
		/// <param name="orgId">CRM Organisation ID to make caching unique</param>
		public static Entity GetGenericConfig(IOrganizationService service, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.CrmHelpers.GetGenericConfig";
			var configLocal = CacheHelpers.GetFromMemCache<Entity>(cacheKey, orgId: orgId);

			if (service != null && configLocal == null)
			{
				var isExist = CacheHelpers.GetFromMemCacheAdd("Yagasoft.Common.GetGenericConfig|IsExist",
					() => MetadataHelpers.IsEntityExist(service, "ldv_genericconfiguration", orgId, true), DateTime.Now.AddYears(1), orgId: orgId);

				if (isExist)
				{
					configLocal =
						(from configQ in new OrganizationServiceContext(service).CreateQuery("ldv_genericconfiguration")
						 where (int)configQ["statecode"] == 0
						 select configQ).FirstOrDefault();
					CacheHelpers.AddToMemCache(cacheKey, configLocal,
						DateTime.Now.AddMinutes(configLocal?.GetAttributeValue<int>("ldv_configurationcacheduration") ?? 0), orgId: orgId);
				}
			}

			return configLocal
				?? new Entity("ldv_genericconfiguration")
				{
					["ldv_name"] = "Generic Config"
				};
		}

		internal static DateTime GetMetadataCacheExpiryDate(IOrganizationService service, Guid? orgId = null)
		{
			return DateTime.Now.AddMinutes(GetGenericConfig(service, orgId)?
				.GetAttributeValue<int>("ldv_metadatacacheduration") ?? 0);
		}

		/// <summary>
		///     Get the value of the primary name field of the record.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetRecordName(IOrganizationService service, Entity record, bool isRetrieveEmpty = true, string primaryNameField = null,
			Guid? orgId = null)
		{
			if (primaryNameField.IsEmpty())
			{
				primaryNameField = MetadataHelpers
					.GetEntityAttribute<string>(service, record.LogicalName, MetadataHelpers.EntityAttribute.PrimaryNameAttribute, orgId);
			}

			var name = record.GetAttributeValue<string>(primaryNameField);

			return (name.IsEmpty() && isRetrieveEmpty)
				? GetRecordName(service, record.LogicalName, record.Id, primaryNameField, orgId)
				: name;
		}

		/// <summary>
		///     Get the value of the primary name field of the record.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetRecordName(IOrganizationService service, string logicalName, Guid id, string primaryNameField = null,
			Guid? orgId = null)
		{
			if (primaryNameField.IsEmpty())
			{
				primaryNameField = MetadataHelpers
					.GetEntityAttribute<string>(service, logicalName, MetadataHelpers.EntityAttribute.PrimaryNameAttribute, orgId);
			}

			return service.Retrieve(logicalName, id, new ColumnSet(primaryNameField)).GetAttributeValue<string>(primaryNameField);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsRecordExists(IOrganizationService service, string logicalName, Guid id, bool isActivity = false)
		{
			var query = new QueryByAttribute(logicalName);
			query.AddAttributeValue(isActivity ? "activityid" : logicalName + "id", id);
			query.ColumnSet = new ColumnSet(false);
			return service.RetrieveMultiple(query).Entities.Any();
		}

		/// <summary>
		///     Get the total number of records returned by the given query using a modded binary search algorithm.<br />
		///     It is recommended that the query's column-set is set to 'false' for speed.<br />
		///     Please note that the 'PageInfo' object in the query will be overwritten.<br />
		///     This does NOT work with CRM Online.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static int GetRecordsCount(IOrganizationService service, QueryExpression query, int countPerPage = 5000,
			string cookie = null, int lowerPageLimit = 1, int upperPageLimit = int.MaxValue)
		{
			var minPage = lowerPageLimit;
			var minPageCount = GetCountInPage(service, query, cookie, minPage, countPerPage);

			// first page is already partially filled or empty, so there are no records after for sure
			if (minPageCount >= 0 && minPageCount < countPerPage)
			{
				return minPageCount;
			}

			var maxPage = minPage;
			int maxPageCount;

			// get max page with partial fill or no records, after which there are surely no records
			// jump pages using an exponent of 2 because it's more likely that there are low number of pages than high
			while (true)
			{
				maxPage = maxPage * 2;
				maxPage = Math.Min(maxPage, upperPageLimit);
				maxPageCount = GetCountInPage(service, query, cookie, maxPage, countPerPage);

				// a filled page is considered a minimum, so set it to reduce search range
				if (maxPageCount == countPerPage)
				{
					minPage = maxPage;
					minPageCount = maxPageCount;
				}
				else
				{
					break;
				}
			}

			var isMaxNextToMin = (minPage + 1) == maxPage;
			var isMaxPageEmpty = maxPageCount == 0;
			var isMaxPagePartial = maxPageCount > 0 && maxPageCount < countPerPage;

			// max page is next to min full page, and is empty or partially filled, so we have reached the end
			if (isMaxPagePartial || (isMaxPageEmpty && isMaxNextToMin))
			{
				return ((maxPage - 1) * countPerPage) + maxPageCount;
			}

			int currentPage;
			int currentPageCount;

			while (true)
			{
				// get the current page in the middle point between min and max
				currentPage = (int)Math.Ceiling((maxPage + minPage) / 2d);

				// if current is not min or max, get its count
				if (currentPage != minPage && currentPage != maxPage)
				{
					currentPageCount = GetCountInPage(service, query, cookie, currentPage, countPerPage);
				}
				else
				{
					currentPageCount = currentPage == minPage ? minPageCount : maxPageCount;
				}

				var isCurrentNextToMin = (minPage + 1) == currentPage;
				var isCurrentNextToMax = (maxPage - 1) == currentPage;
				var isCurrentPageEmpty = currentPageCount == 0;
				var isCurrentPagePartial = currentPageCount > 0 && currentPageCount < countPerPage;
				var isCurrentPageFull = currentPageCount == countPerPage;

				// current page is next to min full page or max empty page
				// and is empty or partially filled, so we have reached the end
				if (isCurrentPagePartial
					|| (isCurrentPageEmpty && isCurrentNextToMin) || (isCurrentPageFull && isCurrentNextToMax))
				{
					break;
				}

				if (isCurrentPageEmpty)
				{
					maxPage = currentPage;
				}

				if (isCurrentPageFull)
				{
					minPage = currentPage;
				}
			}

			return ((currentPage - 1) * countPerPage) + currentPageCount;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static int GetCountInPage(IOrganizationService service, QueryExpression query, string cookie = null,
			int page = 1, int countPerPage = 5000)
		{
			query.PageInfo = query.PageInfo ?? new PagingInfo();
			query.PageInfo.Count = countPerPage;
			query.PageInfo.PageNumber = page;
			query.PageInfo.PagingCookie = query.PageInfo.PagingCookie ?? cookie;
			query.ColumnSet = query.ColumnSet ?? new ColumnSet(false);
			var result = service.RetrieveMultiple(query);
			query.PageInfo.PagingCookie = result.PagingCookie ?? cookie;
			return result.Entities.Count;
		}

		/// <summary>
		///     Gets records from CRM using the query given.<br />
		///     Pass '-1' for limit to get all records, and pass '-1' to page to ignore pages.
		///     The cookie is saved in the query itself during retrieval, so either save the cookie somewhere
		///     and reset it before passing it here, or simply reuse the query for next pages.<br />
		///     You should not skip pages with CRM Online.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IReadOnlyList<Entity> RetrieveRecords(IOrganizationService service, QueryExpression query,
			int limit = -1, int page = -1)
		{
			query.PageInfo =
				new PagingInfo
				{
					PageNumber = page <= 0
						? (query.PageInfo == null || query.PageInfo.PageNumber <= 0
							? 1
							: query.PageInfo.PageNumber)
						: page,
					Count = limit <= 0
						? (query.PageInfo == null || query.PageInfo.Count <= 0
							? 5000
							: query.PageInfo.Count)
						: (limit > 5000 ? 5000 : limit)
				};

			limit = limit <= 0 ? int.MaxValue : limit;

			EntityCollection records;
			var entities = new List<Entity>();

			// get all records
			do
			{
				// fetch the records
				records = service.RetrieveMultiple(query);

				// next time get the next bundle of records
				query.PageInfo.PagingCookie = records.PagingCookie;
				query.PageInfo.PageNumber++;

				// add to existing list
				entities.AddRange(records.Entities);
			}
			while (records.MoreRecords && entities.Count < limit && page <= 0);

			return entities;
		}

		/// <summary>
		///     Gets records from CRM using the FetchXML given.<br />
		///     Pass '-1' for limit to get all records, and pass '-1' to page to ignore pages.
		///     You should not skip pages with CRM Online.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IReadOnlyList<Entity> RetrieveRecords(IOrganizationService service, string fetchXml,
			int limit = -1, int page = -1)
		{
			var isAllPages = page <= 0;
			page = page <= 0 ? 1 : page;
			var loopLimit = limit <= 0 ? int.MaxValue : limit;
			var count = limit > 5000 ? 5000 : limit;
			string cookie = null;

			EntityCollection records;
			var entities = new List<Entity>();

			// get all records
			do
			{
				fetchXml = SetFetchPaging(fetchXml, page, count, cookie);

				// fetch the records
				records = service.RetrieveMultiple(new FetchExpression(fetchXml));

				// next time get the next bundle of records
				cookie = records.PagingCookie;
				page++;

				// add to existing list
				entities.AddRange(records.Entities);
			}
			while (records.MoreRecords && entities.Count < loopLimit && isAllPages);

			return entities;
		}

		private static string SetFetchPaging(string fetchXml, int page, int count = -1, string cookie = null)
		{
			var doc = new XmlDocument();
			doc.LoadXml(fetchXml);

			var fetchNode = doc.SelectNodes("//fetch")?.Cast<XmlNode>().FirstOrDefault();

			if (fetchNode == null)
			{
				throw new FormatException("FetchXML is not properly formatted.");
			}

			var tempDoc = fetchNode.OwnerDocument;

			if (tempDoc == null)
			{
				throw new FormatException("Couldn't find owner document in FetchXML node.");
			}

			if (fetchNode.Attributes == null)
			{
				throw new FormatException("Couldn't find attributes collection in FetchXML node.");
			}

			var attribute = tempDoc.CreateAttribute("page");
			attribute.Value = page.ToString();
			fetchNode.Attributes.SetNamedItem(attribute);

			if (count > 0)
			{
				attribute = tempDoc.CreateAttribute("count");
				attribute.Value = count.ToString();
				fetchNode.Attributes.SetNamedItem(attribute);
			}

			if (!string.IsNullOrWhiteSpace(cookie))
			{
				attribute = tempDoc.CreateAttribute("paging-cookie");
				attribute.Value = cookie;
				fetchNode.Attributes.SetNamedItem(attribute);
			}

			return doc.OuterXml;
		}

		/// <summary>
		///     Extracts the entity references from a record URL. Usually the URL is provided as input to a custom activity.<br />
		///     Execution Context can be null, it is used to cache inside a plugin only.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)<br />
		///     Credit: Yousra Mohamed
		/// </summary>
		public static IEnumerable<EntityReference> GetEntityReferencesFromUrls(IOrganizationService service, Guid? orgId = null,
			params string[] dynamicUrlParams)
		{
			// loop over dynamic urls to retrieve entity reference
			return
				from url in dynamicUrlParams
				where (url.Contains("etc=") || url.Contains("etn=")) && url.Contains("id=")
				select url.Trim().Split('?')
				into urlParts
				select urlParts[1].Split('&')
				into urlParams
				let objectTypeCode = urlParams.FirstOrDefault(p => p.Contains("etc="))?.Replace("etc=", "")
				let objectId = urlParams.First(p => p.Contains("id=")).Replace("id=", "")
				let entityName = objectTypeCode == null
					? urlParams.FirstOrDefault(p => p.Contains("etn="))?.Replace("etn=", "")
					: MetadataHelpers.GetEntityNameUsingTypeCode(service, int.Parse(objectTypeCode), orgId)
				select new EntityReference(entityName, Guid.Parse(objectId));
		}

		/// <summary>
		/// Returns a new Entity with the source and destination attributes merged.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
        public static T MergeAttributes<T>(this T destinationEntity, Entity sourceEntity)
            where T : Entity
        {
            sourceEntity.Require(nameof(sourceEntity));
	        destinationEntity.Require(nameof(destinationEntity));

	        return
				new Entity(destinationEntity.LogicalName)
					.IntegrateAttributes(destinationEntity)
					.IntegrateAttributes(sourceEntity)
					.ToEntity<T>();
        }

		/// <summary>
		/// Returns the destination Entity (left-side of . operator) with the destination attributes merged.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
        public static T IntegrateAttributes<T>(this T destinationEntity, Entity sourceEntity)
            where T : Entity
        {
            sourceEntity.Require(nameof(sourceEntity));
	        destinationEntity.Require(nameof(destinationEntity));

	        foreach (var kv in sourceEntity.Attributes)
	        {
		        destinationEntity[kv.Key] = kv.Value;
	        }

	        foreach (var kv in sourceEntity.FormattedValues)
	        {
		        destinationEntity.FormattedValues[kv.Key] = kv.Value;
	        }

	        return destinationEntity;
        }

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
        public static T ExtractEntityByAlias<T>(this Entity sourceEntity, string alias)
            where T : Entity
        {
            sourceEntity.Require(nameof(sourceEntity));
            alias.RequireNotEmpty(nameof(alias));

            var values = sourceEntity.Attributes
                .Where(kv => kv.Key.StartsWith($"{alias}."))
                .Select(kv => kv.Value as AliasedValue)
                .Where(v => v != null).ToArray();

	        var logicalName = values.FirstOrDefault()?.EntityLogicalName;

	        if (logicalName == null)
	        {
		        return null;
	        }

            var newEntity = new Entity(logicalName);

            foreach (var aliasedValue in values)
            {
                newEntity[aliasedValue.AttributeLogicalName] = aliasedValue.Value;
            }

            var formattedValues = sourceEntity.FormattedValues
                .Where(kv => kv.Key.StartsWith($"{alias}."));

            foreach (var kv in formattedValues)
            {
                newEntity.FormattedValues[kv.Key.Replace($"{alias}.", "")] = kv.Value;
            }

            return newEntity.ToEntity<T>();
        }

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
        public static T ExcludeExistingValues<T>(this T newRecord, Entity existingRecord)
            where T : Entity
        {
            newRecord.Require(nameof(newRecord));
            existingRecord.Require(nameof(existingRecord));

            // IDs' will probably match and be removed below; so restore it after
            var id = newRecord.Id;

            // 'ToArray' is used to create a new collection; modifying collections mid iteration causes exception
            foreach (var attribute in newRecord.Attributes.ToArray())
            {
                var key = attribute.Key;
                var value = attribute.Value;

                bool isEqual;

                switch (value)
                {
                    case OptionSetValue optionSetValue:
                        var existingOsValue = existingRecord.GetAttributeValue<OptionSetValue>(key);
                        isEqual = optionSetValue.Value == existingOsValue?.Value;
                        break;

                    case EntityReference entityReference:
                        var existingRefValue = existingRecord.GetAttributeValue<EntityReference>(key);
                        isEqual = entityReference.Id == existingRefValue?.Id;
                        break;

                    case Money money:
                        var existingMoneyValue = existingRecord.GetAttributeValue<Money>(key);
                        isEqual = money.Value == existingMoneyValue?.Value;
                        break;

                    default:
                        var existingValue = existingRecord.GetAttributeValue<object>(key);
                        isEqual = value == existingValue || value?.Equals(existingValue) == true;
                        break;
                }

                if (isEqual)
                {
                    newRecord.Attributes.Remove(key);
                }
            }

            newRecord.Id = id;

            return newRecord;
        }

		/// <summary>
		///     Executes given requests in a transaction. The returned value should only be taken into consideration
		///     if 'isReturnResponses' is 'true'.<br />
		///     All executed requests will be rolled back if one fails.<br />
		///     The handler takes 'current batch index (1, 2 ... etc.), total batch count, responses' as parameters.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IDictionary<OrganizationRequest, ExecuteBulkResponse> ExecuteTransaction(this IEnumerable<OrganizationRequest> requestsParam,
			IOrganizationService service, bool isReturnResponses = false, int batchSize = 1000,
	        Action<int, int, IDictionary<OrganizationRequest, ExecuteBulkResponse>> bulkFinishHandler = null)
		{
			var requests = requestsParam.ToArray();

	        if (requests?.Any() != true)
	        {
                return new Dictionary<OrganizationRequest, ExecuteBulkResponse>();
	        }

            var bulkRequest =
                new ExecuteTransactionRequest
                {
                    Requests = new OrganizationRequestCollection(),
                    ReturnResponses = isReturnResponses
                };

            var responses = new Dictionary<OrganizationRequest, ExecuteBulkResponse>();
	        var perBulkResponses = new Dictionary<OrganizationRequest, ExecuteBulkResponse>();

            var batchCount = Math.Ceiling(requests.Length / (double)batchSize);

            // take bulk size only for each iteration
            for (var i = 0; i < batchCount; i++)
            {
                // clear the previous batch
                bulkRequest.Requests.Clear();
	            perBulkResponses.Clear();

                // take batches
                bulkRequest.Requests.AddRange(requests.Skip(i * batchSize).Take(batchSize));
                var bulkResponses = (ExecuteTransactionResponse)service.Execute(bulkRequest);

                // no need to build a response
                if (!isReturnResponses)
                {
	                bulkFinishHandler?.Invoke(i + 1, (int)batchCount, perBulkResponses);
                    continue;
                }

                for (var j = 0; j < bulkResponses.Responses.Count; j++)
                {
                    var request = bulkRequest.Requests[j];
                    var bulkResponse = bulkResponses.Responses[j];

                    var response =
                        new ExecuteBulkResponse
                        {
                            RequestType = request.GetType(),
                            Response = bulkResponse,
                            ResponseType = bulkResponse?.GetType()
                        };
                    responses[request] = response;
					perBulkResponses[request] = response;
                }

				bulkFinishHandler?.Invoke(i + 1, (int)batchCount, perBulkResponses);
            }

            return responses;
        }

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IDictionary<OrganizationRequest, ExecuteBulkResponse> ExecuteBulk(IOrganizationService service,
			IReadOnlyList<OrganizationRequest> requests,
			bool isReturnResponses = false, int batchSize = 1000, bool isContinueOnError = true,
			Action<int, int, IDictionary<OrganizationRequest, ExecuteBulkResponse>> bulkFinishHandler = null)
		{
			return requests.ExecuteBulk(service, isReturnResponses, batchSize, isContinueOnError, bulkFinishHandler);
		}

		/// <summary>
		///     Executes given requests in bulk. The returned value should only be taken into consideration
		///     if 'isReturnResponses' is 'true'.<br />
		///     The handler takes 'current batch index (1, 2 ... etc.), total batch count, responses' as parameters.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IDictionary<OrganizationRequest, ExecuteBulkResponse> ExecuteBulk(this IEnumerable<OrganizationRequest> requestsParam,
			IOrganizationService service,
			bool isReturnResponses = false, int batchSize = 1000, bool isContinueOnError = true,
			Action<int, int, IDictionary<OrganizationRequest, ExecuteBulkResponse>> bulkFinishHandler = null)
		{
			var requests = requestsParam.ToArray();

			if (requests?.Any() != true)
			{
				return new Dictionary<OrganizationRequest, ExecuteBulkResponse>();
			}

			var bulkRequest =
				new ExecuteMultipleRequest
				{
					Requests = new OrganizationRequestCollection(),
					Settings =
						new ExecuteMultipleSettings
						{
							ContinueOnError = isContinueOnError,
							ReturnResponses = isReturnResponses
						}
				};

			var responses = new Dictionary<OrganizationRequest, ExecuteBulkResponse>();
			var perBulkResponses = new Dictionary<OrganizationRequest, ExecuteBulkResponse>();

			var batchCount = Math.Ceiling(requests.Length / (double)batchSize);

			// take bulk size only for each iteration
			for (var i = 0; i < batchCount; i++)
			{
				// clear the previous batch
				bulkRequest.Requests.Clear();
				perBulkResponses.Clear();

				// take batches
				bulkRequest.Requests.AddRange(requests.Skip(i * batchSize).Take(batchSize));
				var bulkResponses = (ExecuteMultipleResponse)service.Execute(bulkRequest);

				// no need to build a response
				if (!isReturnResponses)
				{
					// break on error and no 'continue on error' option
					if (!isContinueOnError && (bulkResponses.IsFaulted || bulkResponses.Responses.Any(e => e.Fault != null)))
					{
						break;
					}
					else
					{
						bulkFinishHandler?.Invoke(i + 1, (int)batchCount, perBulkResponses);
						continue;
					}
				}

				for (var j = 0; j < bulkResponses.Responses.Count; j++)
				{
					var request = bulkRequest.Requests[j];
					var bulkResponse = bulkResponses.Responses[j];
					var fault = bulkResponse.Fault;
					string faultMessage = null;

					// build fault message
					if (fault != null)
					{
						var builder = new StringBuilder();
						builder.AppendFormat("Message: \"{0}\", code: {1}", fault.Message, fault.ErrorCode);

						if (fault.TraceText != null)
						{
							builder.AppendFormat(", trace: \"{0}\"", fault.TraceText);
						}

						if (fault.InnerFault != null)
						{
							builder.AppendFormat(", inner message: \"{0}\", inner code: {1}", fault.InnerFault.Message,
								fault.InnerFault.ErrorCode);

							if (fault.InnerFault.TraceText != null)
							{
								builder.AppendFormat(", trace: \"{0}\"", fault.InnerFault.TraceText);
							}
						}

						faultMessage = builder.ToString();
					}

					var response =
						new ExecuteBulkResponse
						{
							RequestType = request.GetType(),
							Response = bulkResponse.Response,
							ResponseType = bulkResponse.Response == null ? null : bulkResponse.Response.GetType(),
							Fault = fault,
							FaultMessage = faultMessage
						};
					responses[request] = response;
					perBulkResponses[request] = response;
				}

				bulkFinishHandler?.Invoke(i + 1, (int)batchCount, perBulkResponses);

				// break on error and no 'continue on error' option
				if (!isContinueOnError && (bulkResponses.IsFaulted || bulkResponses.Responses.Any(e => e.Fault != null)))
				{
					break;
				}
			}

			return responses;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RunWorkflow(IOrganizationService service, Guid entityId, Guid workflowId)
		{
			service.Execute(
				new ExecuteWorkflowRequest
				{
					EntityId = entityId,
					WorkflowId = workflowId
				});
		}

		/// <summary>
		///     Checks whether the given FetchXML returns any records.
		///  The record's ID is added to the FetchXML is as a condition.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsConditionMet(IOrganizationService service, string fetchXml,
			EntityReference record, Guid? orgId = null)
		{
			service.Require("service");
			fetchXml.RequireNotEmpty("fetchXml");
			record.Require("record");

			var primaryIdName = MetadataHelpers.GetEntityAttributes(service, record.LogicalName, orgId,
				MetadataHelpers.EntityAttribute.PrimaryIdAttribute).PrimaryIdAttribute;
			var finalFetchXml = string.Empty;

			var querySplit = fetchXml.Split(new[] { "</entity>" }, StringSplitOptions.None);

			finalFetchXml += querySplit[0];
			finalFetchXml += "<filter type='and'> ";
			finalFetchXml += "<condition attribute='" + primaryIdName + "' operator='eq' value= '" + record.Id + "' /> ";
			finalFetchXml += "</filter>" + "</entity>";
			finalFetchXml += querySplit[querySplit.Length - 1];

			return service.RetrieveMultiple(new FetchExpression(finalFetchXml)).Entities.Any();
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string BuildExceptionMessage(Exception ex, string preMessage = null, bool isUseExStackTrace = false, int depth = 0)
		{
			return ex.BuildExceptionMessage(preMessage, isUseExStackTrace, depth);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string BuildFaultMessage(OrganizationServiceFault fault, int depth)
		{
			return fault.BuildFaultMessage(depth);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static InvalidPluginExecutionException BuildInvalidPluginExecException(Exception ex, string preMessage = null)
		{
			preMessage = (preMessage == null ? string.Empty : preMessage + " ") +
				"<div style=\"display:none\">Exception: " + ex.GetType() + " => \"" + ex.Message + "\"." +
				(ex.InnerException == null
					? string.Empty
					: " Inner exception: " + ex.InnerException.GetType() + " => \"" + ex.InnerException.Message + "\".") +
				"</div>";

			var message = "\nException: " + ex.GetType() + " => \"" + ex.Message + "\"." +
				"\nSource: " + ex.Source +
				"\n\n" + (ex.StackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmHelpers")) + "\n" +
				(ex.InnerException == null
					? string.Empty
					: "\n\nInner exception: " + ex.InnerException.GetType() + " => \"" +
						ex.InnerException.Message + "\"." +
						"\nSource: " + ex.InnerException.Source +
						"\n\n" + ex.InnerException.StackTrace + "\n");

			message = message
				.Replace("\"", "&quot;").Replace("'", "\\'").Replace("\n", "<br />").Replace("\\n", "<br />").Replace("\r",
					string.Empty);

			var script = "<br />" +
				"<button class=\"ms-crm-RefreshDialog-Button\" style=\"margin-right: 30px; margin-left: 8px;\"" +
				"onclick=\"" +
				" var w = window.open('', 'Error Details', 'height=100, width=600, toolbar=no, menubar=no, resizable=no, scrollbars=yes, location=no, directories=no, status=no');"
				+
				" parent.$(w.document.body).html('" + message + "');" +
				" w.document.title = 'Error Details';" +
				" parent.$(w.document.body).css({ 'color': 'blue', 'font-size': 13 });" +
				"\">More Details</button>"
				+ "<br />"
				+ "<br />";

			return new InvalidPluginExecutionException(preMessage + script, ex);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void LogAttributeValues(AttributeCollection attributes, Entity labelsRecord, CrmLog log,
			string logLabel = null)
		{
			attributes.Require("attributes");
			labelsRecord.Require("labelsRecord");
			log.Require("log");

			var attributesInfo = new StringBuilder();
			attributesInfo.Append("Attribute values (" + attributes.Count + "):");

			foreach (var attribute in attributes.OrderBy(pair => pair.Key))
			{
				var value = attribute.Value;

				if (value is OptionSetValue)
				{
					value = labelsRecord.FormattedValues.Contains(attribute.Key)
						? labelsRecord.FormattedValues[attribute.Key]
						: value;

					if (value is OptionSetValue)
					{
						value = ((OptionSetValue)value)?.Value;
					}
				}
				else if (value is EntityReference)
				{
					value = (labelsRecord.FormattedValues.Contains(attribute.Key)
						? labelsRecord.FormattedValues[attribute.Key]
						: ((EntityReference)value).Name) ?? value;

					if (value is EntityReference && value != null)
					{
						value = labelsRecord.GetAttributeValue<EntityReference>(attribute.Key)?.Name;
					}
				}
				else if (value is Money)
				{
					value = attribute.Value;
				}

				attributesInfo.Append("\r\n    \"" + attribute.Key + "\" => \"" + value + "\".");
			}

			log.Log(new LogEntry(logLabel ?? "Entity Object Values", LogLevel.Debug,
				labelsRecord.Id.ToString(), labelsRecord.LogicalName, attributesInfo.ToString()));
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetAttributeName(string field, Entity record)
		{
			record.FormattedValues.TryGetValue(field, out var label);
			return label.IsFilled() ? label : GetAttributeStringRep(field, record);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetAttributeStringRep(string field, Entity record)
		{
			var fieldValue = record.GetAttributeValue<object>(field);

			if (fieldValue == null)
			{
				return null;
			}

			if (fieldValue is string s)
			{
				return s;
			}

			if (fieldValue is OptionSetValue value)
			{
				return value.Value.ToString();
			}

			if (fieldValue is DateTime time)
			{
				return time.ToString("yyyy-MM-ddTHH:mm:ss.fffZ");
			}

			if (fieldValue is EntityReference fieldRef)
			{
				return $"{fieldRef.LogicalName}:{fieldRef.Id.ToString().ToUpper()}";
			}

			if (fieldValue is Guid fieldGuid)
			{
				return fieldGuid.ToString().ToUpper();
			}

			if (fieldValue is int fieldInt)
			{
				return fieldInt.ToString();
			}

			if (fieldValue is Money fieldMoney)
			{
				return fieldMoney.Value.ToString();
			}

			return fieldValue.ToString();
		}

		#region Relations helpers

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IReadOnlyList<Entity> GetRelatedRecords(IOrganizationService service, EntityReference entity,
			MetadataHelpers.RelationType[] relationTypes, FilterExpression filter = null,
			Guid? orgId = null, params string[] attributes)
		{
			if (relationTypes == null || relationTypes.Length <= 0)
			{
				return Array.Empty<Entity>();
			}

			var relationAttributes =
				new[]
				{
					MetadataHelpers.RelationAttribute.SchemaName, MetadataHelpers.RelationAttribute.RelationshipType, MetadataHelpers.RelationAttribute.IntersectEntityName,
					MetadataHelpers.RelationAttribute.ReferencedEntity, MetadataHelpers.RelationAttribute.ReferencedAttribute,
					MetadataHelpers.RelationAttribute.ReferencingEntity, MetadataHelpers.RelationAttribute.ReferencingAttribute,
					MetadataHelpers.RelationAttribute.Entity1LogicalName, MetadataHelpers.RelationAttribute.Entity1IntersectAttribute,
					MetadataHelpers.RelationAttribute.Entity2LogicalName, MetadataHelpers.RelationAttribute.Entity2IntersectAttribute
				};

			var relations = MetadataHelpers
				.GetCustomRelationships(service, entity.LogicalName, relationTypes, relationAttributes, orgId)
				.Select(r =>
						{
							var relation =
								MetadataHelpers.BuildRelationMetadata(r,
									r.RelationshipType == RelationshipType.OneToManyRelationship
										? MetadataHelpers.RelationType.OneToManyRelationships
										: MetadataHelpers.RelationType.ManyToManyRelationships);
							relation.Require(nameof(relation), $"Unable to find relation '{r.SchemaName}' in entity '{entity.LogicalName}'.");
							return relation;
						});
			return GetRelatedRecordsInner(service, entity, relations.ToArray(), filter, orgId, attributes);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IReadOnlyList<Entity> GetRelatedRecords(IOrganizationService service, EntityReference entity,
			string relationName, FilterExpression filter = null, Guid? orgId = null, params string[] attributes)
		{
			service.Require(nameof(service));
			entity.Require(nameof(entity));
			relationName.RequireNotEmpty(nameof(relationName));

			var relation = MetadataHelpers.GetRelation(service, entity.LogicalName, relationName, orgId);
			relation.Require(nameof(relation), $"Unable to find relation '{relationName}' in entity '{entity.LogicalName}'.");

			return GetRelatedRecordsInner(service, entity, new[] { relation }, filter,
				orgId, attributes);
		}

		private static IReadOnlyList<Entity> GetRelatedRecordsInner(IOrganizationService service, EntityReference entity,
			IReadOnlyList<RelationMetadata> relations, FilterExpression filter = null, Guid? orgId = null, params string[] attributes)
		{
			var related = new List<Entity>();

			var idFieldName = MetadataHelpers.GetEntityAttribute<string>(service, entity.LogicalName,
				MetadataHelpers.EntityAttribute.PrimaryIdAttribute, orgId);

			var manyToMany = relations.Where(relation => relation.Type == MetadataHelpers.RelationType.ManyToManyRelationships).ToArray();

			if (manyToMany.Any())
			{
				foreach (var rel in manyToMany)
				{
					var entity2Name = rel.Entity1Name == entity.LogicalName
						? rel.Entity2Name
						: rel.Entity1Name;
					var entity2Id = rel.Entity1Name == entity.LogicalName
						? rel.Entity2FieldName
						: rel.Entity1FieldName;
					var intersectEntity = rel.IntersectingEntityName;

					related.AddRange(GetRecords(entity, service, entity2Name, intersectEntity, entity2Id,
						entity2Id, idFieldName, -1, -1, filter, attributes));
				}
			}

			var oneToMany = relations.Where(relation => relation.Type == MetadataHelpers.RelationType.OneToManyRelationships).ToArray();

			if (oneToMany.Any())
			{
				foreach (var rel in oneToMany)
				{
					var entity2Name = rel.Entity2Name;
					var entity2LookupName = rel.Entity2FieldName;

					related.AddRange(GetRecords(entity, service, entity2Name, entity.LogicalName,
						entity2LookupName, idFieldName, idFieldName, -1, -1, filter, attributes));
				}
			}

			var manyToOne = relations.Where(relation => relation.Type == MetadataHelpers.RelationType.ManyToOneRelationships).ToArray();

			if (manyToOne.Any())
			{
				foreach (var rel in manyToOne)
				{
					var entity2Name = rel.Entity1Name;
					var entity2LookupName = rel.Entity1FieldName;

					related.AddRange(GetRecords(entity, service, entity2Name, entity.LogicalName,
						entity2LookupName, idFieldName, idFieldName, -1, -1, filter, attributes));
				}
			}

			return related;
		}

		#endregion

		#region User helpers

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IReadOnlyList<Guid> GetTeamMembers(IOrganizationService service, Guid teamId)
		{
			using (var svcContext = new OrganizationServiceContext(service))
			{
				return
					(from user in svcContext.CreateQuery("systemuser")
						join member in svcContext.CreateQuery("teammembership")
							on user["systemuserid"] equals member["systemuserid"]
						join teamQ in svcContext.CreateQuery("team")
							on member["teamid"] equals teamQ["teamid"]
						where teamQ["teamid"].Equals(teamId)
						select (Guid)user["systemuserid"]).ToArray();
			}
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IReadOnlyList<Guid> GetQueueMembers(IOrganizationService service, Guid queueId)
		{
			using (var svcContext = new OrganizationServiceContext(service))
			{
				return
					(from user in svcContext.CreateQuery("systemuser")
						join member in svcContext.CreateQuery("queuemembership")
							on user["systemuserid"] equals member["systemuserid"]
						join queue in svcContext.CreateQuery("queue")
							on member["queueid"] equals queue["queueid"]
						where queue["queueid"].Equals(queueId)
						select (Guid)user["systemuserid"]).ToArray();
			}
		}

		/// <summary>
		///     From the SDK: http://msdn.microsoft.com/en-us/library/hh670609.aspx <br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static int GetPreferredLangCode(IOrganizationService service, EntityReference record)
		{
			if (record.LogicalName == "systemuser")
			{
				var userSettingsQuery = new QueryExpression("usersettings");
				userSettingsQuery.ColumnSet.AddColumns("uilanguageid", "systemuserid");
				userSettingsQuery.Criteria.AddCondition("systemuserid", ConditionOperator.Equal, record.Id);
				var userSettings = service.RetrieveMultiple(userSettingsQuery);

				if (userSettings.Entities.Count > 0)
				{
					var code = (int)userSettings.Entities[0]["uilanguageid"];
					return code <= 0 ? 1033 : code;
				}
			}
			else if (record.LogicalName == "account" || record.LogicalName == "contact")
			{
				Entity result;

				result = service.Retrieve(record.LogicalName, record.Id, new ColumnSet("ldv_preferredcommunicationlanguage"));

				if (!result.Contains("ldv_preferredcommunicationlanguage"))
				{
					return 1033;
				}

				return ((OptionSetValue)result["ldv_preferredcommunicationlanguage"]).Value;
			}
			else
			{
				throw new NotSupportedException("Entity does not support a default language spec '" + record.LogicalName + "'.");
			}

			return 1033;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static int GetUserTimeZoneBiasMinutes(IOrganizationService service, Guid userId)
		{
			return GetUsersTimeZoneBiasMinutes(service, userId).FirstOrDefault().Value;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IDictionary<Guid, int> GetUsersTimeZoneBiasMinutes(IOrganizationService service, params Guid[] userIds)
		{
			var query = new QueryExpression("usersettings");
			var filter = new FilterExpression(LogicalOperator.Or);

			foreach (var userId in userIds)
			{
				filter.AddCondition("systemuserid", ConditionOperator.Equal, userId);
			}

			query.ColumnSet = new ColumnSet("systemuserid", "timezonebias");
			query.Criteria.Filters.Add(filter);

			var userSettings = service.RetrieveMultiple(query).Entities;

			if (userSettings == null || userSettings.Count < userIds.Length
				|| userSettings.Any(settings => !settings.Contains("timezonebias")))
			{
				throw new Exception("Can't retrieve the settings of the users.");
			}

			return userSettings.ToDictionary(
				settings => settings.GetAttributeValue<Guid>("systemuserid"),
				settings => settings.GetAttributeValue<int>("timezonebias") * -1);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static Guid? GetManagerId(IOrganizationService service, Guid userId)
		{
			var user = service.Retrieve("systemuser", userId, new ColumnSet("parentsystemuserid"));

			if (!user.Contains("parentsystemuserid"))
			{
				throw new Exception("User record does not contain a manager.");
			}

			return ((EntityReference)user["parentsystemuserid"]).Id;
		}

		/// <summary>
		///     Validates that the owner can edit the record.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="targetRecord">The target record to check for access rights.</param>
		/// <param name="targetOwner">The owner to check the rights for.</param>
		public static bool CanUpdateRecord(IOrganizationService service, EntityReference targetRecord,
			EntityReference targetOwner)
		{
			// request user's access rights to current record
			var principalAccessRequest =
				new RetrievePrincipalAccessRequest
				{
					Principal = targetOwner,
					Target = targetRecord
				};

			// response will contain AccessRights mask, like AccessRights.WriteAccess | AccessRights.ReadAccess | ...
			var principalAccessResponse = (RetrievePrincipalAccessResponse)service.Execute(principalAccessRequest);

			// if user can't edit record
			if ((principalAccessResponse.AccessRights & AccessRights.WriteAccess) != AccessRights.WriteAccess)
			{
				return false;
			}

			return true;
		}

		#endregion

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetRecordUrl(IOrganizationService service, EntityReference recordRef, Guid? orgId = null)
		{
			recordRef.Require(nameof(recordRef));

			var config = GetGenericConfig(service, orgId);
			var baseUrl = config.GetAttributeValue<string>("ldv_organisationbaseurl");
			baseUrl.RequireNotEmpty(nameof(baseUrl));
			var rowTemplate = config.GetAttributeValue<string>("ys_rowurltemplate");
			rowTemplate.RequireNotEmpty(nameof(rowTemplate));

			return $"{baseUrl.Trim('/')}/main.aspx"
				+ $"?{(rowTemplate.Replace("{id}", recordRef.Id.ToString().ToUpper()).Replace("{table}", recordRef.LogicalName))}";
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetAttributeStringValue(object fieldValue)
		{
			if (fieldValue == null)
			{
				return null;
			}

			if (fieldValue is string s)
			{
				return s;
			}

			if (fieldValue is OptionSetValue value)
			{
				return value.Value.ToString();
			}

			if (fieldValue is DateTime time)
			{
				return time.ToString("yyyy-MM-ddTHH:mm:ss.fffZ");
			}

			if (fieldValue is EntityReference fieldRef)
			{
				return $"{fieldRef.LogicalName}:{fieldRef.Id.ToString().ToUpper()}";
			}

			if (fieldValue is Guid fieldGuid)
			{
				return fieldGuid.ToString().ToUpper();
			}

			if (fieldValue is int fieldInt)
			{
				return fieldInt.ToString();
			}

			if (fieldValue is Money fieldMoney)
			{
				return fieldMoney.Value.ToString();
			}

			return fieldValue.ToString();
		}

		private static IReadOnlyList<Entity> GetRecords(EntityReference entity, IOrganizationService service,
			string fromEntityName, string toEntityName, string fromFieldName, string toFieldName,
			string intersectIdFieldName, int limit = -1, int page = -1,
			FilterExpression filter = null, params string[] attributes)
		{
			return RetrieveRecords(service, BuildRetrieveQuery(entity, fromEntityName, toEntityName,
				fromFieldName, toFieldName, intersectIdFieldName, filter, attributes), limit, page);
		}

		private static QueryExpression BuildRetrieveQuery(EntityReference entity,
			string fromEntityName, string toEntityName, string fromFieldName, string toFieldName,
			string intersectIdFieldName, FilterExpression filter = null, params string[] attributes)
		{
			// create the query taking into account paging
			var query = new QueryExpression(fromEntityName);
			query.LinkEntities.Add(new LinkEntity(fromEntityName, toEntityName, fromFieldName, toFieldName, JoinOperator.Inner));
			query.LinkEntities[0].EntityAlias = "linkedEntityAlias";
			query.Criteria.AddCondition("linkedEntityAlias", intersectIdFieldName, ConditionOperator.Equal, entity.Id);

			if (filter != null)
			{
				query.Criteria.AddFilter(filter);
			}

			if (attributes.Length == 1 && attributes[0] == "*")
			{
				query.ColumnSet = new ColumnSet(true);
			}
			else if (attributes.Length > 0)
			{
				query.ColumnSet = new ColumnSet(attributes);
			}
			else
			{
				query.ColumnSet = new ColumnSet(false);
			}

			return query;
		}

		public static string SecureConnectionString(string connectionString)
		{
			return Regex
				.Replace(Regex
					.Replace(connectionString, @"Password\s*?=.*?(?:;{0,1}$|;)", "Password=********;")
					.Replace("\r\n", " "),
					@"\s+", " ")
				.Replace(" = ", "=");
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IEnumerable<TEntity> ToEntity<TEntity>(this IEnumerable<Entity> entities) where TEntity : Entity
		{
			return entities.Select(e => e.ToEntity<TEntity>());
		}
	}

	/// <summary>
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static partial class MetadataHelpers
	{
		private static readonly string[] nonStandard =
		{
			"applicationfile",
			"attachment", // Not included with CrmSvcUtil 6.0.0001.0061
			"authorizationserver", // Not included with CrmSvcUtil 6.0.0001.0061
			"businessprocessflowinstance",
			// Not included with CrmSvcUtil 2013  http://community.dynamics.com/crm/f/117/t/117642.aspx
			"businessunitmap", // Not included with CrmSvcUtil 2013
			"clientupdate", // Not included with CrmSvcUtil 2013
			"commitment", // Not included with CrmSvcUtil 2013
			"competitoraddress", // isn't include in CrmSvcUtil but it shows in the default solution
			"complexcontrol", // Not Included with CrmSvcUtil 2013
			"dependencynode", // Not Included with CrmSvcUtil 2013
			"displaystringmap", // Not Included with CrmSvcUtil 2013
			"documentindex", // Not Included with CrmSvcUtil 2013
			"emailhash", // Not Included with CrmSvcUtil 2013
			"emailsearch", // Not Included with CrmSvcUtil 2013
			"filtertemplate", // Not Included with CrmSvcUtil 2013
			"imagedescriptor", // Not included with CrmSvcUtil 2013
			"importdata", // Not included with CrmSvcUtil 6.0.0001.0061
			"integrationstatus", // Not included with CrmSvcUtil 6.0.0001.0061
			"interprocesslock", // Not included with CrmSvcUtil 6.0.0001.0061
			"multientitysearchentities", // Not included with CrmSvcUtil 6.0.0001.0061
			"multientitysearch", // Not included with CrmSvcUtil 6.0.0001.0061
			"notification", // Not included with CrmSvcUtil 6.0.0001.0061
			"organizationstatistic", // Not included with CrmSvcUtil 6.0.0001.0061
			"owner", // Not included with CrmSvcUtil 2013
			"partnerapplication", // Not included with CrmSvcUtil 6.0.0001.0061
			"principalattributeaccessmap", // Not included with CrmSvcUtil 6.0.0001.0061
			"principalobjectaccessreadsnapshot", // Not included with CrmSvcUtil 6.0.0001.0061
			"principalobjectaccess", // Not included with CrmSvcUtil 6.0.0001.0061
			"privilegeobjecttypecodes", // Not included with CrmSvcUtil 6.0.0001.0061
			"postregarding", // Not included with CrmSvcUtil 2013
			"postrole", // Not included with CrmSvcUtil 2013
			"subscriptionclients", // Not included with CrmSvcUtil 6.0.0001.0061
			"salesprocessinstance", // Not included with CrmSvcUtil 6.0.0001.0061
			"recordcountsnapshot", // Not included with CrmSvcUtil 6.0.0001.0061
			"replicationbacklog", // Not included with CrmSvcUtil 6.0.0001.0061
			"resourcegroupexpansion", // Not included with CrmSvcUtil 6.0.0001.0061
			"ribboncommand", // Not included with CrmSvcUtil 6.0.0001.0061
			"ribboncontextgroup", // Not included with CrmSvcUtil 6.0.0001.0061
			"ribbondiff", // Not included with CrmSvcUtil 6.0.0001.0061
			"ribbonrule", // Not included with CrmSvcUtil 6.0.0001.0061
			"ribbontabtocommandmap", // Not included with CrmSvcUtil 6.0.0001.0061
			"roletemplate", // Not included with CrmSvcUtil 6.0.0001.0061
			"statusmap", // Not included with CrmSvcUtil 6.0.0001.0061
			"stringmap", // Not included with CrmSvcUtil 6.0.0001.0061
			"sqlencryptionaudit",
			"subscriptionsyncinfo",
			"subscription", // Not included with CrmSvcUtil 6.0.0001.0061
			"subscriptiontrackingdeletedobject",
			"systemapplicationmetadata", // Not included with CrmSvcUtil 6.0.0001.0061
			"systemuserbusinessunitentitymap", // Not included with CrmSvcUtil 6.0.0001.0061
			"systemuserprincipals", // Not included with CrmSvcUtil 6.0.0001.0061
			"traceassociation", // Not included with CrmSvcUtil 6.0.0001.0061
			"traceregarding", // Not included with CrmSvcUtil 6.0.0001.0061
			"unresolvedaddress", // Not included with CrmSvcUtil 6.0.0001.0061
			"userapplicationmetadata", // Not included with CrmSvcUtil 6.0.0001.0061
			"userfiscalcalendar", // Not included with CrmSvcUtil 6.0.0001.0061
			"webwizard", // Not included with CrmSvcUtil 6.0.0001.0061
			"wizardaccessprivilege", // Not included with CrmSvcUtil 6.0.0001.0061
			"wizardpage", // Not included with CrmSvcUtil 6.0.0001.0061
			"workflowwaitsubscription", // Not included with CrmSvcUtil 6.0.0001.0061
			// the following cause duplicate errors in generated code
			"bulkdeleteoperation",
			"reportlink",
			"rollupjob"
		};

		public enum EntityAttribute
		{
			LogicalName,
			SchemaName,
			DisplayName,
			PrimaryIdAttribute,
			PrimaryNameAttribute,
			ObjectTypeCode,
			IsActivity,
			Keys
		}

		public enum FieldAttribute
		{
			OptionSet,
			DisplayName
		}

		public enum RelationAttribute
		{
			SchemaName,
			RelationshipType,
			ReferencedEntity,
			ReferencedAttribute,
			ReferencingEntity,
			ReferencingAttribute,
			IntersectEntityName,
			Entity1LogicalName,
			Entity1IntersectAttribute,
			Entity2LogicalName,
			Entity2IntersectAttribute
		}

		public enum RelationType
		{
			OneToManyRelationships,
			ManyToOneRelationships,
			ManyToManyRelationships
		}

		/// <summary>
		///     Checks whether the given field exists in the entity by its logical name.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsFieldExistInEntity(IOrganizationService service, string entityName, string fieldName, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.IsFieldExistInEntity|{entityName}|{fieldName}";
			var isExist = CacheHelpers.GetFromMemCache<bool?>(cacheKey, orgId: orgId);

			if (isExist.HasValue)
			{
				return isExist.Value;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.AddRange("Attributes");

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions
				.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entityName));

			var attributeProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			attributeProperties.PropertyNames.AddRange("LogicalName");

			var attributeFilter = new MetadataFilterExpression(LogicalOperator.And);
			attributeFilter.Conditions
				.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, fieldName));

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties,
					AttributeQuery =
						new AttributeQueryExpression
						{
							Criteria = attributeFilter,
							Properties = attributeProperties
						}
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			var result = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest)).EntityMetadata;
			return CacheHelpers.AddToMemCache(cacheKey,
				result != null && result.Count > 0 && result.First().Attributes.Length > 0
					&& result.First().Attributes.Any(attribute => attribute.LogicalName == fieldName),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
		}

		/// <summary>
		///     Get the names of all entities.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IDictionary<string, string> GetEntityNames(IOrganizationService service, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.GetEntityNames";
			var entityNames = CacheHelpers.GetFromMemCache<IDictionary<string, string>>(cacheKey, orgId: orgId);

			if (entityNames != null)
			{
				return entityNames;
			}

			return CacheHelpers.AddToMemCache(cacheKey,
				GetEntities(service, orgId, EntityAttribute.LogicalName, EntityAttribute.DisplayName)
					.Where(e => e.DisplayName?.UserLocalizedLabel?.Label != null)
					.OrderBy(e => e.LogicalName)
					.ToDictionary(e => e.LogicalName, e => e.DisplayName?.UserLocalizedLabel?.Label),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
		}

		/// <summary>
		///     Get the given properties of all entities.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IReadOnlyList<EntityMetadata> GetEntities(IOrganizationService service, Guid? orgId = null,
			params EntityAttribute[] attributes)
		{
			return GetEntities(service, orgId, attributes.Select(attribute => attribute.ToString()).ToArray());
		}

		/// <summary>
		///     Get the names of all entities.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IReadOnlyList<EntityMetadata> GetEntities(IOrganizationService service, Guid? orgId = null, params string[] attributes)
		{
			var cacheKey = $"Yagasoft.Common.GetEntities|{attributes.Aggregate("", (a1, a2) => a1 + "," + a2)}";
			var entities = CacheHelpers.GetFromMemCache<IReadOnlyList<EntityMetadata>>(cacheKey, orgId: orgId);

			if (entities != null)
			{
				return entities;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};

			if (attributes?.Any() == true)
			{
				entityProperties.PropertyNames.AddRange(attributes);
			}

			var logicalNameString = EntityAttribute.LogicalName.ToString();

			if (attributes?.Contains(logicalNameString) != true)
			{
				entityProperties.PropertyNames.Add(logicalNameString);
			}

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Properties = entityProperties
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			return CacheHelpers.AddToMemCache(cacheKey,
				((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest)).EntityMetadata
					.Where(entity =>
					{
						if (entity.LogicalName == null)
						{
							return false;
						}

						return !nonStandard.Contains(entity.LogicalName);
					}).ToArray(),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
		}

		/// <summary>
		///     Get the entity meta data from the metadata cache.<br />
		///     Includes: LogicalName, DisplayName, PrimaryIdAttribute, PrimaryNameAttribute, Keys,
		///     Attributes, OneToManyRelationships, ManyToOneRelationships, ManyToManyRelationships<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static EntityMetadata GetEntity(IOrganizationService service, string logicalName, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.GetEntity|{logicalName}";
			var entity = CacheHelpers.GetFromMemCache<EntityMetadata>(cacheKey, orgId: orgId);

			if (entity != null)
			{
				return entity;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.AddRange("LogicalName", "DisplayName", "PrimaryIdAttribute", "PrimaryNameAttribute",
				"Keys", "Attributes", "OneToManyRelationships", "ManyToOneRelationships", "ManyToManyRelationships");

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions
				.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, logicalName));

			var attributeProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			attributeProperties.PropertyNames.AddRange("LogicalName", "DisplayName");

			var attributeFilter = new MetadataFilterExpression(LogicalOperator.And);
			attributeFilter.Conditions
				.Add(new MetadataConditionExpression("AttributeOf", MetadataConditionOperator.Equals, null));

			var keyProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			keyProperties.PropertyNames.AddRange("KeyAttributes");

			var relationProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			relationProperties.PropertyNames.AddRange("SchemaName",
				"ReferencedEntity", "ReferencedAttribute", "ReferencingEntity", "ReferencingAttribute",
				"IntersectEntityName", "Entity1LogicalName", "Entity1IntersectAttribute",
				"Entity2LogicalName", "Entity2IntersectAttribute");

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties,
					AttributeQuery =
						new AttributeQueryExpression
						{
							Properties = attributeProperties,
							Criteria = attributeFilter
						},
					KeyQuery =
						new EntityKeyQueryExpression
						{
							Properties = keyProperties
						},
					RelationshipQuery =
						new RelationshipQueryExpression
						{
							Properties = relationProperties
						}
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			return CacheHelpers.AddToMemCache(cacheKey,
				((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
					.EntityMetadata?.FirstOrDefault(),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
		}

		/// <summary>
		///     Checks whether the entity exists in the metadata cache.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsEntityExist(IOrganizationService service, string logicalName, Guid? orgId = null, bool isNoCache = false)
		{
			var cacheKey = $"Yagasoft.Common.IsEntityExist|{logicalName}";
			var isExist = CacheHelpers.GetFromMemCache<bool?>(cacheKey, orgId: orgId);

			if (isExist.HasValue)
			{
				return isExist.Value;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.Add("LogicalName");

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions
				.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, logicalName));

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			var result = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
				.EntityMetadata?.Any() == true;

			return isNoCache
				? result
				: CacheHelpers.AddToMemCache(cacheKey, result,
					CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
		}

		/// <summary>
		///     Get the value of an entity attribute from the metadata.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static T GetEntityAttribute<T>(IOrganizationService service, string entityName,
			EntityAttribute attribute, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.GetEntityAttribute|{entityName}|{attribute}";
			var attributeCached = CacheHelpers.GetFromMemCache<T>(cacheKey, orgId: orgId);

			if (attributeCached != null)
			{
				return attributeCached;
			}

			var entityProperties = new MetadataPropertiesExpression
			{
				AllProperties = false
			};
			entityProperties.PropertyNames.AddRange(attribute.ToString());

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions.Add(
				new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals,
					entityName));

			var entityQueryExpression = new EntityQueryExpression
			{
				Criteria = entityFilter,
				Properties = entityProperties
			};

			var retrieveMetadataChangesRequest = new RetrieveMetadataChangesRequest
			{
				Query = entityQueryExpression,
				ClientVersionStamp = null
			};

			var metadata = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
				.EntityMetadata?.FirstOrDefault();
			return CacheHelpers.AddToMemCache(cacheKey,
				(T)metadata?.GetType().GetProperty(attribute.ToString())?.GetValue(metadata),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
		}

		/// <summary>
		///     Get the value of a list of entity attributes from the metadata.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static EntityMetadata GetEntityAttributes(IOrganizationService service, string entityName,
			Guid? orgId = null, params EntityAttribute[] attributes)
		{
			var cacheKey = $"Yagasoft.Common.GetEntityAttributes|{entityName}|"
				+ $"{attributes.Select(a => a.ToString()).Aggregate<string>((a1, a2) => a1 + "," + a2)}";
			var attributesCached = CacheHelpers.GetFromMemCache<EntityMetadata>(cacheKey, orgId: orgId);

			if (attributesCached != null)
			{
				return attributesCached;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.AddRange(attributes.Select(a => a.ToString()));

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions
				.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entityName));

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			return CacheHelpers.AddToMemCache(cacheKey,
				((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
					.EntityMetadata?.FirstOrDefault(),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
		}

		/// <summary>
		///     Gets the logical name using the entity's object type code.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetEntityNameUsingTypeCode(IOrganizationService service, int typeCode, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.GetEntityNameUsingTypeCode|{typeCode}";
			var entityName = CacheHelpers.GetFromMemCache<string>(cacheKey, orgId: orgId);

			if (entityName != null)
			{
				return entityName;
			}

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions.Add(new MetadataConditionExpression("ObjectTypeCode",
				MetadataConditionOperator.Equals, typeCode));

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.AddRange("LogicalName");

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			return CacheHelpers.AddToMemCache(cacheKey,
				((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
					.EntityMetadata?.FirstOrDefault()?.LogicalName,
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
		}

		/// <summary>
		///     Gets the entity's object type code using its logical name.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static int GetTypeCodeUsingEntityName(IOrganizationService service, string entityName,
			Guid? orgId = null)
		{
			return GetEntityAttribute<int?>(service, entityName, EntityAttribute.ObjectTypeCode, orgId) ?? 0;
		}

		/// <summary>
		///     Get the value of a field attribute from the metadata.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static T GetFieldAttribute<T>(IOrganizationService service, string entityName, string fieldName,
			FieldAttribute attribute, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.GetFieldAttribute|{entityName}|{fieldName}|{attribute}";
			var attributeCached = CacheHelpers.GetFromMemCache<T>(cacheKey, orgId: orgId);

			if (attributeCached != null)
			{
				return attributeCached;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.AddRange("Attributes");

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions.Add(
				new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entityName));

			var attributeFilter = new MetadataFilterExpression(LogicalOperator.And);
			attributeFilter.Conditions
				.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, fieldName));

			var attributeProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			attributeProperties.PropertyNames.AddRange(attribute.ToString());

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties,
					AttributeQuery =
						new AttributeQueryExpression
						{
							Properties = attributeProperties,
							Criteria = attributeFilter
						}
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			var metadata = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
				.EntityMetadata?.FirstOrDefault();

			AttributeMetadata fieldmetadata = null;

			if (metadata != null)
			{
				fieldmetadata = metadata.Attributes?.FirstOrDefault();
			}

			return CacheHelpers.AddToMemCache(cacheKey,
				(T)fieldmetadata?.GetType().GetProperty(attribute.ToString())?.GetValue(fieldmetadata),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
		}

		/// <summary>
		///     Get the properties of all relations of a given type in an the entity from the metadata cache.<br />
		///     Includes: "SchemaName", "ReferencedEntity", "ReferencedAttribute", "ReferencingEntity",
		///     "ReferencingAttribute", "IntersectEntityName", "Entity1LogicalName", "Entity1IntersectAttribute",
		///     "Entity2LogicalName", "Entity2IntersectAttribute"<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IEnumerable<RelationMetadata> GetEntityRelations(IOrganizationService service, string entityName,
			RelationType? type, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.GetEntityRelations|{entityName}|{type}";
			var metadata = CacheHelpers.GetFromMemCache<EntityMetadata>(cacheKey, orgId: orgId);

			if (metadata == null)
			{
				var entityProperties =
					new MetadataPropertiesExpression
					{
						AllProperties = false
					};

				if (type == null)
				{
					entityProperties.PropertyNames.AddRange(Enum.GetNames(typeof(RelationType)));
				}
				else
				{
					entityProperties.PropertyNames.Add(type.ToString());
				}

				var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
				entityFilter.Conditions
					.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entityName));

				var relationProperties =
					new MetadataPropertiesExpression
					{
						AllProperties = false
					};
				relationProperties.PropertyNames.AddRange("SchemaName",
					"ReferencedEntity", "ReferencedAttribute", "ReferencingEntity", "ReferencingAttribute",
					"IntersectEntityName", "Entity1LogicalName", "Entity1IntersectAttribute",
					"Entity2LogicalName", "Entity2IntersectAttribute");

				var entityQueryExpression =
					new EntityQueryExpression
					{
						Criteria = entityFilter,
						Properties = entityProperties,
						RelationshipQuery =
							new RelationshipQueryExpression
							{
								Properties = relationProperties,
							}
					};

				var retrieveMetadataChangesRequest =
					new RetrieveMetadataChangesRequest
					{
						Query = entityQueryExpression,
						ClientVersionStamp = null
					};

				metadata = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
					.EntityMetadata?.FirstOrDefault();

				if (metadata == null)
				{
					return new RelationMetadata[0];
				}

				CacheHelpers.AddToMemCache(cacheKey, metadata, CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
			}

			return BuildRelationMetadata(metadata);
		}

		/// <summary>
		///     Get the properties of the relation from the metadata cache.<br />
		///     Includes: "SchemaName", "ReferencedEntity", "ReferencedAttribute", "ReferencingEntity",
		///     "ReferencingAttribute", "IntersectEntityName", "Entity1LogicalName", "Entity1IntersectAttribute",
		///     "Entity2LogicalName", "Entity2IntersectAttribute"<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static RelationMetadata GetRelation(IOrganizationService service, string entityName, string relationName,
			Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.GetRelation|{entityName}|{relationName}";
			var metadata = CacheHelpers.GetFromMemCache<EntityMetadata>(cacheKey, orgId: orgId);

			if (metadata == null)
			{
				var entityProperties =
					new MetadataPropertiesExpression
					{
						AllProperties = false
					};
				entityProperties.PropertyNames.AddRange(Enum.GetNames(typeof(MetadataHelpers.RelationType)));

				var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
				entityFilter.Conditions
					.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entityName));

				var relationFilter = new MetadataFilterExpression(LogicalOperator.And);
				relationFilter.Conditions
					.Add(new MetadataConditionExpression("SchemaName", MetadataConditionOperator.Equals, relationName));

				var relationProperties =
					new MetadataPropertiesExpression
					{
						AllProperties = false
					};
				relationProperties.PropertyNames.AddRange("SchemaName",
					"ReferencedEntity", "ReferencedAttribute", "ReferencingEntity", "ReferencingAttribute",
					"IntersectEntityName", "Entity1LogicalName", "Entity1IntersectAttribute",
					"Entity2LogicalName", "Entity2IntersectAttribute");

				var entityQueryExpression =
					new EntityQueryExpression
					{
						Criteria = entityFilter,
						Properties = entityProperties,
						RelationshipQuery =
							new RelationshipQueryExpression
							{
								Properties = relationProperties,
								Criteria = relationFilter
							}
					};

				var retrieveMetadataChangesRequest =
					new RetrieveMetadataChangesRequest
					{
						Query = entityQueryExpression,
						ClientVersionStamp = null
					};

				metadata = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
					.EntityMetadata?.FirstOrDefault();

				if (metadata == null)
				{
					return null;
				}

				CacheHelpers.AddToMemCache(cacheKey, metadata, CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
			}

			return BuildRelationMetadata(metadata).FirstOrDefault();
		}

		/// <summary>
		///     Get the value of a relation attribute from the metadata cache.<br />
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static T GetRelationAttribute<T>(IOrganizationService service, string entityName, string relationName,
			RelationType type, RelationAttribute attribute, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.GetRelationAttribute|{entityName}|{relationName}|{type}|{attribute}";
			var attributeCached = CacheHelpers.GetFromMemCache<T>(cacheKey, orgId: orgId);

			if (attributeCached != null)
			{
				return attributeCached;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.Add(type.ToString());

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions
				.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entityName));

			var relationFilter = new MetadataFilterExpression(LogicalOperator.And);
			relationFilter.Conditions
				.Add(new MetadataConditionExpression("SchemaName", MetadataConditionOperator.Equals, relationName));

			var relationProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			relationProperties.PropertyNames.AddRange(attribute.ToString());

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties,
					RelationshipQuery =
						new RelationshipQueryExpression
						{
							Properties = relationProperties,
							Criteria = relationFilter
						}
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			var metadata = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
				.EntityMetadata?.FirstOrDefault();

			if (metadata == null)
			{
				return default(T);
			}

			RelationshipMetadataBase relationMetadata = null;

			if (metadata.OneToManyRelationships != null)
			{
				relationMetadata = metadata.OneToManyRelationships.FirstOrDefault();
			}

			if (metadata.ManyToOneRelationships != null)
			{
				relationMetadata = metadata.ManyToOneRelationships.FirstOrDefault();
			}

			if (metadata.ManyToManyRelationships != null)
			{
				relationMetadata = metadata.ManyToManyRelationships.FirstOrDefault();
			}

			return CacheHelpers.AddToMemCache(cacheKey,
				(T)relationMetadata?.GetType().GetProperty(attribute.ToString())?.GetValue(relationMetadata),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static List<RelationshipMetadataBase> GetCustomRelationships(IOrganizationService service,
			string entityName, RelationType[] types, RelationAttribute[] attributes,
			Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.GetCustomRelationships|{entityName}|"
				+ $"{types.Select(t => t.ToString()).Aggregate<string>((t1, t2) => t1 + "," + t2)}"
				+ $"{attributes.Select(a => a.ToString()).Aggregate<string>((a1, a2) => a1 + "," + a2)}";
			var relations = CacheHelpers.GetFromMemCache<List<RelationshipMetadataBase>>(cacheKey, orgId: orgId);

			if (relations != null)
			{
				return relations;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.AddRange(types.Select(type => type.ToString()));

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions.Add(
				new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entityName));

			var relationFilter = new MetadataFilterExpression(LogicalOperator.And);
			relationFilter.Conditions
				.Add(new MetadataConditionExpression("IsCustomRelationship", MetadataConditionOperator.Equals, true));

			var relationProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			relationProperties.PropertyNames.AddRange(attributes.Select(attribute => attribute.ToString()));
			if (!attributes.Contains(MetadataHelpers.RelationAttribute.RelationshipType))
			{
				relationProperties.PropertyNames.AddRange(MetadataHelpers.RelationAttribute.RelationshipType.ToString());
			}

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties,
					RelationshipQuery =
						new RelationshipQueryExpression
						{
							Properties = relationProperties,
							Criteria = relationFilter
						}
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			var metadata = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
				.EntityMetadata?.FirstOrDefault();

			var relationMetadata = new List<RelationshipMetadataBase>();

			if (metadata == null)
			{
				return relationMetadata;
			}

			if (metadata.OneToManyRelationships != null)
			{
				relationMetadata.AddRange(metadata.OneToManyRelationships);
			}

			if (metadata.ManyToOneRelationships != null)
			{
				relationMetadata.AddRange(metadata.ManyToOneRelationships);
			}

			if (metadata.ManyToManyRelationships != null)
			{
				relationMetadata.AddRange(metadata.ManyToManyRelationships);
			}

			return CacheHelpers.AddToMemCache(cacheKey, relationMetadata, CrmHelpers.GetMetadataCacheExpiryDate(service, orgId),
				orgId: orgId);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetOptionSetLabel(IOrganizationService service, string entityName, string fieldName,
			int value, int? language = null, Guid? orgId = null)
		{
			var label = GetFieldAttribute<OptionSetMetadata>(service, entityName, fieldName, FieldAttribute.OptionSet,
				orgId)?.Options.FirstOrDefault(optionQ => optionQ.Value == value)?.Label;

			return language == null
				? label?.UserLocalizedLabel?.Label
				: label?.LocalizedLabels?.Where(l => l.LanguageCode == language).FirstOrDefault()?.Label;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IEnumerable<RelationMetadata> BuildRelationMetadata(EntityMetadata entityMetadata)
		{
			IEnumerable<RelationMetadata> relationMetadata = new RelationMetadata[0];

			if (entityMetadata.OneToManyRelationships?.Length > 0)
			{
				relationMetadata = relationMetadata.Union(entityMetadata.OneToManyRelationships
					.Select(m => BuildRelationMetadata(m, RelationType.OneToManyRelationships))
					.Where(r => r != null));
			}

			if (entityMetadata.ManyToOneRelationships?.Length > 0)
			{
				relationMetadata = relationMetadata.Union(entityMetadata.ManyToOneRelationships
					.Select(m => BuildRelationMetadata(m, RelationType.ManyToOneRelationships))
					.Where(r => r != null));
			}

			if (entityMetadata.ManyToManyRelationships?.Length > 0)
			{
				relationMetadata = relationMetadata.Union(entityMetadata.ManyToManyRelationships
					.Select(m => BuildRelationMetadata(m, RelationType.ManyToManyRelationships))
					.Where(r => r != null));
			}

			return relationMetadata;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static RelationMetadata BuildRelationMetadata(RelationshipMetadataBase relationMetadata, RelationType type)
		{
			if (relationMetadata is OneToManyRelationshipMetadata relation1NTypeSpecific
				&& type == RelationType.OneToManyRelationships)
			{
				return new RelationMetadata
				{
					SchemaName = relation1NTypeSpecific.SchemaName,
					Entity1Name = relation1NTypeSpecific.ReferencedEntity,
					Entity1FieldName = relation1NTypeSpecific.ReferencedAttribute,
					Entity2Name = relation1NTypeSpecific.ReferencingEntity,
					Entity2FieldName = relation1NTypeSpecific.ReferencingAttribute,
					Type = type
				};
			}

			if (relationMetadata is OneToManyRelationshipMetadata relationN1TypeSpecific
				&& type == RelationType.ManyToOneRelationships)
			{
				return new RelationMetadata
				{
					SchemaName = relationN1TypeSpecific.SchemaName,
					Entity1Name = relationN1TypeSpecific.ReferencedEntity,
					Entity1FieldName = relationN1TypeSpecific.ReferencedAttribute,
					Entity2Name = relationN1TypeSpecific.ReferencingEntity,
					Entity2FieldName = relationN1TypeSpecific.ReferencingAttribute,
					Type = type
				};
			}

			if (relationMetadata is ManyToManyRelationshipMetadata relationNnTypeSpecific
				&& type == RelationType.ManyToManyRelationships)
			{
				return new RelationMetadata
				{
					SchemaName = relationNnTypeSpecific.SchemaName,
					Entity1Name = relationNnTypeSpecific.Entity1LogicalName,
					Entity1FieldName = relationNnTypeSpecific.Entity1IntersectAttribute,
					Entity2Name = relationNnTypeSpecific.Entity2LogicalName,
					Entity2FieldName = relationNnTypeSpecific.Entity2IntersectAttribute,
					IntersectingEntityName = relationNnTypeSpecific.IntersectEntityName,
					Type = type
				};
			}

			return null;
		}
	}

	/// <summary>
	///		Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class ErrorHelpers
	{
		public static string BuildExceptionMessage(this Exception ex, string preMessage = null, bool isUseExStackTrace = false,
			int depth = 0)
		{
			if (ex == null || depth > 5)
			{
				return string.Empty;
			}

			depth++;

			var message = (preMessage == null ? string.Empty : preMessage + "\r\n")
				+ "- Exception: " + ex.GetType()
				+ "\r\n- Message: " + ex.Message
				+ (ex.Source == null ? string.Empty : "\r\n- Source: " + ex.Source)
				+ (ex.HelpLink == null ? string.Empty : "\r\n- Help link: " + ex.HelpLink);

			try
			{
				message += (ex.TargetSite == null ? string.Empty : "\r\n- Target site: " + ex.TargetSite);
			}
			catch
			{
				// ignored
			}

			message += $"\r\n- HResult: {ex.HResult}"
				+ (ex.StackTrace == null
					? string.Empty
					: "\r\n- Stack trace:"
						+ "\r\n" + (ex.StackTrace
							?? (isUseExStackTrace
								? string.Empty
								: Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmHelpers"))));

			if (ex is System.ServiceModel.FaultException<OrganizationServiceFault> fault
				&& fault.CreateMessageFault().HasDetail)
			{
				message += $"\r\n\r\n--- START ** ORG SRV FAULT ---\r\n"
					+ $"\r\n{fault.Detail.BuildFaultMessage(depth)}"
					+ $"\r\n\r\n--- END ** ORG SRV FAULT ---";
			}

			if (ex.InnerException != null)
			{
				message += $"\r\n\r\n----- START ** INNER EXCEPTION -----\r\n"
					+ $"\r\n{ex.InnerException.BuildExceptionMessage(null, true, depth)}"
					+ $"\r\n\r\n----- END ** INNER EXCEPTION -----";
			}

			return message;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string BuildFaultMessage(this OrganizationServiceFault fault, int depth)
		{
			if (fault == null || depth > 5)
			{
				return string.Empty;
			}

			depth++;

			var message = $"- Error: {fault.Message}"
				+ $"\r\n- Error code: {fault.ErrorCode}"
				+ $"\r\n- Timestamp: {fault.Timestamp}"
				+ $"\r\n- Activity ID: {fault.ActivityId}";

			var text = fault.TraceText;

			if (text.IsFilled())
			{
				message += $"\r\n- Trace text:\r\n{text}";
			}

			if (fault.ErrorDetails?.Any() == true)
			{
				message = fault.ErrorDetails.Aggregate($"{message}\r\n- Error details:",
					(current, errorDetail) =>
						current + $"\r\n({errorDetail.Key}, {errorDetail.Value})");
			}

			if (fault.InnerFault != null)
			{
				message += $"\r\n\r\n--- INNER ORG SRV FAULT ---\r\n"
					+ $"\r\n{fault.InnerFault.BuildFaultMessage(depth)}";
			}

			return message;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string BuildShortExceptionMessage(this Exception ex, int depth = 0)
		{
			if (ex == null || depth > 5)
			{
				return string.Empty;
			}

			depth++;

			var message = "Exception: " + ex.GetType()
				+ " | Message: " + ex.Message
				+ (ex.Source == null ? string.Empty : " | Source: " + ex.Source);

			try
			{
				message += (ex.TargetSite == null ? string.Empty : " | Target site: " + ex.TargetSite);
			}
			catch
			{
				// ignored
			}

			message += $" | HResult: {ex.HResult}";

			if (ex is System.ServiceModel.FaultException<OrganizationServiceFault> fault
				&& fault.CreateMessageFault().HasDetail)
			{
				message += $" |> SRV FAULT: {fault.Detail.BuildShortFaultMessage(depth)} <|";
			}

			if (ex.InnerException != null)
			{
				message += $" |>> {ex.InnerException.BuildExceptionMessage(null, true, depth)} <<|";
			}

			return message;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string BuildShortFaultMessage(this OrganizationServiceFault fault, int depth)
		{
			if (fault == null || depth > 5)
			{
				return string.Empty;
			}

			depth++;

			var message = $"Error: {fault.Message}"
				+ $" | Error code: {fault.ErrorCode}"
				+ $" | Timestamp: {fault.Timestamp}"
				+ $" | Activity ID: {fault.ActivityId}";

			var text = fault.TraceText;

			if (fault.ErrorDetails?.Any() == true)
			{
				message = fault.ErrorDetails.Aggregate($"{message} | Error details:",
					(current, errorDetail) =>
						current + $" ({errorDetail.Key}, {errorDetail.Value})");
			}

			if (fault.InnerFault != null)
			{
				message += $" |> INNER SRV FAULT: {fault.InnerFault.BuildFaultMessage(depth)} <|";
			}

			return message;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string ExtractErrorCode(this string message)
		{
			var code = new Regex(@"0x\d*").Match(message).Value;
			return code.IsHexErrorCode() ? code : null;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static bool IsHexErrorCode(this string code)
		{
			return new Regex(@"^0x\d*$").IsMatch(code);
		}
	}

	/// <summary>
	///     credit: http://stackoverflow.com/a/961904/1919456 <br />
	///     Credit: http://stackoverflow.com/questions/19049514/strategy-for-logging-in-production-for-dynamics-crm-plugins
	///     <br />
	///		Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class PluginInfo
	{
		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string GetPluginExecutionInfo(IOrganizationService organizationService, IExecutionContext context)
		{
			var contextTemp = context as IPluginExecutionContext;

			var lines =
				new List<string>
				{
					"MessageName: " + context.MessageName,
					"PrimaryEntityName: " + context.PrimaryEntityName,
					"PrimaryEntityId: " + context.PrimaryEntityId,
					"SecondaryEntityName: " + context.SecondaryEntityName,
					"BusinessUnitId: " + context.BusinessUnitId,
					"CorrelationId: " + context.CorrelationId,
					"Depth: " + context.Depth,
					"InitiatingUserId: " + context.InitiatingUserId,
					"UserId: " + context.UserId,
					"IsInTransaction: " + context.IsInTransaction,
					"IsolationMode: " + context.IsolationMode,
					"Mode: " + context.Mode,
					"OperationCreatedOn: " + context.OperationCreatedOn,
					"OperationId: " + context.OperationId,
					"Organization: " + context.OrganizationName + "(" + context.OrganizationId + ")"
				};


			if (contextTemp != null)
			{
				lines.Add("Stage: " + contextTemp.Stage);
			}

			AddEntityReference(lines, context.OwningExtension, "OwningExtension");
			
			ParameterCollection inputParams = null;

			try
			{
				inputParams = context.InputParameters;
			}
			catch
			{
				// ignored
			}

			if (inputParams != null)
			{
				AddParameters(organizationService, lines, inputParams, "Input Parameters");
			}

			AddParameters(organizationService, lines, context.OutputParameters, "Output Parameters");
			AddParameters(organizationService, lines, context.SharedVariables, "Shared Variables");
			AddEntityImages(organizationService, lines, context.PostEntityImages, "Post Entity Images");
			AddEntityImages(organizationService, lines, context.PreEntityImages, "Pre Entity Images");

			if (contextTemp != null)
			{
				lines.Add("Has Parent Context: " + (contextTemp.ParentContext != null));

				if (contextTemp.ParentContext != null)
				{
					lines.Add("-- Parent Context --");
					lines.Add(GetPluginExecutionInfo(organizationService, contextTemp.ParentContext));
				}
			}

			return string.Join(Environment.NewLine, lines);
		}

		private static void AddEntity(IOrganizationService service, List<string> nameValuePairs, Entity entity, string name)
		{
			if (entity != null)
			{
				nameValuePairs.Add($"** {name} **");
				nameValuePairs.AddRange(entity.Attributes
					.Select(att =>
						"    Entity[" + att.Key + "]: " +
							GetAttributeValue(service, entity.LogicalName, att.Key, att.Value)));
			}
			else
			{
				nameValuePairs.Add(name + ": Empty");
			}
		}

		private static string GetAttributeValue(IOrganizationService organizationService, string logicalName, string key,
			object value)
		{
			if (value == null)
			{
				return "Null";
			}

			var type = value.GetType();

			if (type == typeof(OptionSetValue))
			{
				var retrieveOptionSetRequest =
					new RetrieveAttributeRequest
					{
						EntityLogicalName = logicalName,
						LogicalName = key,
						RetrieveAsIfPublished = true
					};

				var response = (RetrieveAttributeResponse)organizationService.Execute(retrieveOptionSetRequest);

				var metadata = response.AttributeMetadata as EnumAttributeMetadata;

				if (metadata != null)
				{
					var valueTemp = ((OptionSetValue)value).Value;
					return valueTemp + " (" +
						metadata.OptionSet.Options
							.FirstOrDefault(option => option.Value == valueTemp)?
							.Label.UserLocalizedLabel?.Label + ")";
				}
			}

			if (type != typeof(EntityReference))
			{
				return value.ToString();
			}

			var reference = (EntityReference)value;

			if (reference.LogicalName == null)
			{
				return value.ToString();
			}

			var primaryAttribute = ((RetrieveEntityResponse)organizationService
				.Execute(
					new RetrieveEntityRequest
					{
						EntityFilters = EntityFilters.Entity,
						LogicalName = reference.LogicalName
					})).EntityMetadata.PrimaryNameAttribute;

			return reference.Id + " (" +
				organizationService.Retrieve(reference.LogicalName, reference.Id, new ColumnSet(primaryAttribute))
					.GetAttributeValue<string>(primaryAttribute) + ")";
		}

		private static void AddEntityReference(ICollection<string> nameValuePairs, EntityReference entity, string name)
		{
			if (entity != null)
			{
				nameValuePairs.Add(name + ": " + entity.Name);
			}
		}

		private static void AddEntityImages(IOrganizationService organizationService, List<string> nameValuePairs,
			EntityImageCollection images, string name)
		{
			if (images != null && images.Count > 0)
			{
				nameValuePairs.Add("** " + name + " **");

				foreach (var image in images)
				{
					if (image.Value == null || image.Value.Attributes.Count == 0)
					{
						if (image.Value != null)
						{
							nameValuePairs.Add("    Image[" + image.Key + "] " + image.Value.ToEntityReference().Name + ": Empty");
						}
					}
					else
					{
						nameValuePairs.Add("*   Image[" + image.Key + "] " + image.Value.ToEntityReference().Name + "   *");
						nameValuePairs.AddRange(image.Value.Attributes
							.Select(att =>
								"        Entity[" + att.Key + "]: " +
									GetAttributeValue(organizationService, image.Value.ToEntityReference().LogicalName, att.Key, att.Value)));
					}
				}
			}
			else
			{
				nameValuePairs.Add(name + ": Empty");
			}
		}

		private static void AddParameters(IOrganizationService service, List<string> nameValuePairs,
			ParameterCollection parameters, string name)
		{
			if (parameters != null && parameters.Count > 0)
			{
				nameValuePairs.Add("* " + name + " *");
				nameValuePairs.AddRange(parameters
					.Where(param => !(param.Value is Entity))
					.Select(param => "    Param[" + param.Key + "]: " + param.Value));

				foreach (var kv in parameters
					.Where(param => param.Value is Entity))
				{
					var entity = (Entity)kv.Value;
					AddEntity(service, nameValuePairs, entity,
						$"{kv.Key} {entity.ToEntityReference().Name}");
				}
			}
			else
			{
				nameValuePairs.Add(name + ": Empty");
			}
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static partial class BpfHelpers
	{
		/// <summary>
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		///     Returns all stages in the process, in order, with their names.<br />
		/// </summary>
		/// <param name="service">The service.</param>
		/// <param name="processId">The process identifier.</param>
		public static List<BpfStageInfo> GetStages(IOrganizationService service, Guid processId, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.GetStages|{processId}";
			var process = CacheHelpers.GetFromMemCache<Entity>(cacheKey, orgId: orgId)
				?? CacheHelpers.AddToMemCache(cacheKey,
					service.Retrieve("workflow", processId, new ColumnSet("xaml")),
					CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);

			if (!process.Contains("xaml"))
			{
				return null;
			}

			var doc = new XmlDocument();
			doc.LoadXml((string)process["xaml"]);

			var stepNodes = doc.SelectNodes("//*[local-name()='Workflow']/*[local-name()='ActivityReference']" +
				"/*[local-name()='ActivityReference.Properties']/*[local-name()='Collection']" +
				"/*[local-name()='ActivityReference']/*[local-name()='ActivityReference.Properties']");

			var stages = new List<BpfStageInfo>();

			if (stepNodes == null || stepNodes.Count <= 0)
			{
				return null;
			}

			for (var i = 0; i < stepNodes.Count; i++)
			{
				var idText = stepNodes[i].SelectSingleNode("*[local-name()='String' and @*[local-name()='Key']='StageId']");
				var id = idText?.InnerText;
				var labelNode =
					stepNodes[i].SelectSingleNode("*[local-name()='Collection']/*[local-name()='StepLabel']/@Description");
				var label = labelNode?.InnerText;

				if (id != null)
				{
					stages.Add(
						new BpfStageInfo
						{
							Id = Guid.Parse(id),
							Name = label,
							Index = i
						});
				}
			}

			return stages.Any() ? stages : null;
		}

		/// <summary>
		///     Fetches the BPF entity's record related to the given record as raw Entity object.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="service">CRM service.</param>
		/// <param name="record">Target record with the process set.</param>
		/// <param name="processId">The process.</param>
		/// <param name="isIncludeStage">Include the current Stage ID and Traversed Path in the retrieved info.</param>
		/// <param name="primaryEntityPrefix">
		///     Prefix of the Primary Entity ID attribute.
		///     Default: "bpf", and for OoB Entities it's empty.
		/// </param>
		public static BpfRecord GetBpfRecord(IOrganizationService service, EntityReference record, Guid processId,
			bool isIncludeStage = false, string primaryEntityPrefix = "bpf", Guid? orgId = null)
		{
			var processRecord = GetBpfRecordRaw(service, record, processId, isIncludeStage, primaryEntityPrefix, orgId);

			return
				new BpfRecord
				{
					LogicalName = processRecord.LogicalName,
					Id = processRecord.GetAttributeValue<Guid>("businessprocessflowinstanceid"),
					ProcessId = processRecord.GetAttributeValue<EntityReference>("processid").Id,
					StageId = processRecord.GetAttributeValue<EntityReference>("activestageid") == null
						? (Guid?)null
						: processRecord.GetAttributeValue<EntityReference>("activestageid").Id,
					TraversedPath = processRecord.GetAttributeValue<string>("traversedpath")
				};
		}

		/// <summary>
		///     Fetches the BPF entity's record related to the given record as raw Entity object.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="service">CRM service.</param>
		/// <param name="record">Target record with the process set.</param>
		/// <param name="processId">The process.</param>
		/// <param name="isIncludeStage">Include the current Stage ID and Traversed Path in the retrieved info.</param>
		/// <param name="primaryEntityPrefix">
		///     Prefix of the Primary Entity ID attribute.
		///     Default: "bpf", and for OoB Entities it's empty.
		/// </param>
		public static Entity GetBpfRecordRaw(IOrganizationService service, EntityReference record, Guid processId,
			bool isIncludeStage = false, string primaryEntityPrefix = "bpf", Guid? orgId = null)
		{
			var cacheKeyRecordName = $"Yagasoft.Common.GetBpfRecordRaw|{record.Id}|{processId}|processRecordName";
			var processRecordName = CacheHelpers.GetFromMemCache<string>(cacheKeyRecordName, orgId: orgId);

			var cacheKeyRecord = $"Yagasoft.Common.GetBpfRecordRaw|{record.Id}|{processId}|processRecord";
			var processRecord = CacheHelpers.GetFromMemCache<Entity>(cacheKeyRecord, orgId: orgId);

			if (!isIncludeStage && processRecord != null)
			{
				return processRecord;
			}

			using (var context = new OrganizationServiceContext(service) { MergeOption = MergeOption.NoTracking })
			{
				if (processRecordName == null)
				{
					// can't figure out the process record name except from the process's name in the DB
					processRecordName = CacheHelpers.AddToMemCache(cacheKeyRecordName,
						(from process in context.CreateQuery("workflow")
						 where (Guid)process["workflowid"] == processId
						 select (string)process["uniquename"]).FirstOrDefault(),
						CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);

					if (processRecordName == null)
					{
						throw new Exception($"Could not get the entity name of process: {processId}.");
					}
				}

				// get the special entity's record for this process and given target record
				processRecord =
					(from processRecordQ in context.CreateQuery(processRecordName)
					 where processRecordQ["processid"] == (object)processId
						 && processRecordQ[$"{(primaryEntityPrefix.IsFilled() ? $"{primaryEntityPrefix}_" : "")}{record.LogicalName}id"]
							 == (object)record.Id
					 select processRecordQ).FirstOrDefault();

				if (isIncludeStage)
				{
					return processRecord;
				}

				return CacheHelpers.AddToMemCache(cacheKeyRecord, processRecord,
					CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
			}
		}

		/// <summary>
		///     Returns the BPF Instance records. Logical Name of the Process Entity, and the Traversed Path are excluded.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IEnumerable<BpfRecord> GetBpfInstances(IOrganizationService service, EntityReference record, bool isIncludeStage = false,
			Guid? orgId = null)
		{
			return GetBpfInstancesRaw(service, record, isIncludeStage, orgId)?
				.Select(
					e =>
						new BpfRecord
						{
							Id = e.Id,
							ProcessId = e.GetAttributeValue<EntityReference>("processid")?.Id,
							StageId = e.GetAttributeValue<Guid?>("processstageid")
						});
		}

		/// <summary>
		///     Returns the BPF Instance records as raw Entity objects.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IReadOnlyList<Entity> GetBpfInstancesRaw(IOrganizationService service, EntityReference record, bool isIncludeStage = false,
			Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.GetBpfInstancesRaw|{record.Id}";
			var instances = CacheHelpers.GetFromMemCache<IReadOnlyList<Entity>>(cacheKey, orgId: orgId);

			if (!isIncludeStage && instances != null)
			{
				return instances;
			}

			instances =
				((RetrieveProcessInstancesResponse)service.Execute(
					new RetrieveProcessInstancesRequest
					{
						EntityId = record.Id,
						EntityLogicalName = record.LogicalName
					})).Processes?.Entities;

			if (isIncludeStage)
			{
				return instances;
			}

			return CacheHelpers.AddToMemCache(cacheKey, instances,
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
		}

		/// <summary>
		///     Returns the BPF Instance record of the given Process. The Traversed Path is excluded.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static BpfRecord GetBpfInstance(IOrganizationService service, EntityReference record, string processLogicalName,
			Guid processId, bool isIncludeStage = false, Guid? orgId = null)
		{
			var instance = GetBpfInstances(service, record, isIncludeStage, orgId)?
				.FirstOrDefault(e => e.ProcessId == processId);

			if (instance != null)
			{
				instance.LogicalName = processLogicalName;
			}

			return instance;
		}

		/// <summary>
		///     Returns the BPF Instance record of the given Process as raw Entity object.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static Entity GetBpfInstanceRaw(IOrganizationService service, EntityReference record,
			Guid processId, bool isIncludeStage = false, Guid? orgId = null)
		{
			return GetBpfInstancesRaw(service, record, isIncludeStage, orgId)
				.FirstOrDefault(e => e.GetAttributeValue<EntityReference>("processid")?.Id == processId);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static Guid? GetActiveProcessId(IOrganizationService service, EntityReference record, Guid? orgId = null)
		{
			return GetBpfInstances(service, record, false, orgId).FirstOrDefault()?.ProcessId;
		}

		public static Guid? GetActiveStageId(IOrganizationService service, EntityReference record, Guid? orgId = null)
		{
			return GetBpfInstances(service, record, true, orgId).FirstOrDefault()?.StageId;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static BpfStageRecord GetActiveStage(IOrganizationService service, EntityReference record, Guid? processId, string primaryEntityPrefix = "bpf",
			Guid? orgId = null)
		{
			service.Require(nameof(service));
			record.Require(nameof(record));
			processId.Require(nameof(processId));

			var bpfRecord = GetBpfRecordRaw(service, record, processId.GetValueOrDefault(), true, primaryEntityPrefix, orgId);
			var stageId = bpfRecord.GetAttributeValue<EntityReference>("activestageid")?.Id;
			stageId.Require(nameof(stageId), $"Unable to find Stage ID in Process ({processId}) record ({bpfRecord.Id})"
				+ $" for record ({record.LogicalName}|{record.Id}).");
			var activePath = GetActivePathRaw(service, bpfRecord.Id);
			var stage = activePath.FirstOrDefault(e => e.Id == stageId);
			stage.Require(nameof(stage), $"Unable to find Stage ({stageId}) info in Active Path of Process ({processId})"
				+ $" for record ({record.LogicalName}|{record.Id}).");
			var stageEntityName = stage?.GetAttributeValue<string>("primaryentitytypecode");
			var stageEntityRef = bpfRecord.GetAttributeValue<EntityReference>(
				$"{(primaryEntityPrefix.IsFilled() ? $"{primaryEntityPrefix}_" : "")}{stageEntityName}id");

			return
				new BpfStageRecord
				{
					Id = stageId.GetValueOrDefault(),
					StageRecord = stageEntityRef,
					ActivePath = activePath.Select(s => s.Id.ToString().ToLower()).StringAggregate(),
					TraversedPath = bpfRecord.GetAttributeValue<string>("traversedpath")
				};
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void MoveStage(IOrganizationService service, EntityReference record, string processLogicalName, Guid processId, bool moveBackwards = false,
			EntityReference stageRecordRef = null, string stageRecordLookupName = null, Guid? orgId = null)
		{
			service.Require(nameof(service));
			record.Require(nameof(record));
			processLogicalName.RequireNotEmpty(nameof(processLogicalName));

			var instance = GetBpfInstance(service, record, processLogicalName, processId, false, orgId);

			if (instance == null)
			{
				throw new Exception($"Can't find the BPF instance for process: {processId}.");
			}

			var activePath = GetActivePath(service, instance.Id).ToArray();

			Guid? targetStage = null;

			for (var i = 0; i < activePath.Length; i++)
			{
				if (activePath[i] != instance.StageId)
				{
					continue;
				}

				if (moveBackwards)
				{
					if (i <= 0)
					{
						throw new Exception("Can't move backwards from first stage in the process.");
					}

					targetStage = activePath[i - 1];
				}
				else
				{
					if (i >= activePath.Length - 1)
					{
						throw new Exception("Can't move forwards from last stage in the process.");
					}

					targetStage = activePath[i + 1];
				}

				break;
			}

			if (targetStage == null)
			{
				throw new Exception($"Can't find a stage to move to. Process: '{processId}', backwards: {moveBackwards}.");
			}

			var traversedPath = BuildTraversedPath(targetStage.Value, activePath);
			MoveToStage(service, record, targetStage.Value, instance, traversedPath, traversedPath, stageRecordRef, stageRecordLookupName, orgId);
		}

		/// <summary>
		///     Moves the process to the given stage.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="service">CRM service.</param>
		/// <param name="record">The target record to set the Stage in.</param>
		/// <param name="processLogicalName">The Logical Name of the BPF Entity.</param>
		/// <param name="processId">The process that includes the Stage.</param>
		/// <param name="stageId">The Stage.</param>
		/// <param name="stageRecordRef">The Stage record if multi-entity BPF.</param>
		/// <param name="stageRecordLookupName">The name of the Lookup in the Stage record Entity pointing to the main Entity.</param>
		public static void MoveToStage(IOrganizationService service, EntityReference record, string processLogicalName, Guid processId, Guid stageId,
			EntityReference stageRecordRef = null, string stageRecordLookupName = null, Guid? orgId = null)
		{
			service.Require(nameof(service));
			record.Require(nameof(record));
			processLogicalName.RequireNotEmpty(nameof(processLogicalName));

			var instance = GetBpfInstance(service, record, processLogicalName, processId, true, orgId);

			// first time the record is going to this process, so invoke a change so that CRM creates a BPF record first
			if (instance == null)
			{
				service.Update(
					new Entity(record.LogicalName, record.Id)
					{
						["processid"] = processId,
						["stageid"] = stageId
					});
				instance = GetBpfInstance(service, record, processLogicalName, processId, true, orgId);

				if (instance == null)
				{
					throw new Exception($"Can't find the BPF instance for Process: {processId}, for record: {record.Id}|{record.LogicalName}.");
				}
			}

			if (instance.StageId == null)
			{
				throw new Exception($"Can't find Active Stage ID in BPF record: {instance.Id},"
					+ $" for Process: {processId}, for record: {record.Id}|{record.LogicalName}.");
			}

			if (instance.StageId == stageId)
			{
				return;
			}

			if (instance == null)
			{
				throw new Exception($"Can't find the BPF instance for BPF record: {instance.Id},"
					+ $" for process: {processId}, for record: {record.Id}|{record.LogicalName}.");
			}

			var activePath = GetActivePath(service, instance.Id).ToArray();
			var oldTraversedPath = BuildTraversedPath(instance.StageId.Value, activePath);
			var newTraversedPath = BuildTraversedPath(stageId, activePath);
			MoveToStage(service, record, stageId, instance, oldTraversedPath, newTraversedPath, stageRecordRef, stageRecordLookupName, orgId);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void MoveToStage(IOrganizationService service, EntityReference record, Guid stageId, BpfRecord bpfInstanceRecord,
			string oldTraversedPath, string newTraversedPath, EntityReference stageRecordRef = null, string stageRecordLookupName = null,
			Guid? orgId = null)
		{
			service.Require(nameof(service));
			record.Require(nameof(record));
			bpfInstanceRecord.Require(nameof(bpfInstanceRecord));
			bpfInstanceRecord.ProcessId.Require(nameof(bpfInstanceRecord.ProcessId));
			oldTraversedPath.RequireNotEmpty(nameof(oldTraversedPath));
			newTraversedPath.RequireNotEmpty(nameof(newTraversedPath));

			var oldPathLength = oldTraversedPath.Split(',').Length;
			var newPathLength = newTraversedPath.Split(',').Length;

			//if (Math.Abs(oldPathLength - newPathLength) > 1)
			//{
			//	MoveStage(service, record, bpfInstanceRecord.LogicalName, bpfInstanceRecord.ProcessId.GetValueOrDefault(), orgId,
			//		oldPathLength > newPathLength);
			//}

			var updatedProcessRecord =
				new Entity(bpfInstanceRecord.LogicalName)
				{
					Id = bpfInstanceRecord.Id,
					[$"bpf_{record.LogicalName}id"] = record,
					["activestageid"] = new EntityReference("processstage", stageId)
				};

			if (stageRecordRef != null)
			{
				updatedProcessRecord[$"bpf_{stageRecordRef.LogicalName}id"] = stageRecordRef;

				// before jumping into a stage entity record, it has to be related to the current record first, if not already so
				if (stageRecordLookupName.IsFilled())
				{
					service.Update(
						new Entity(stageRecordRef.LogicalName, stageRecordRef.Id) { [stageRecordLookupName] = record });
				}
			}

			service.Update(updatedProcessRecord);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IEnumerable<Guid> GetActivePath(IOrganizationService service, Guid instanceId)
		{
			return GetActivePathRaw(service, instanceId).Select(s => s.Id);
		}

		public static IReadOnlyList<Entity> GetActivePathRaw(IOrganizationService service, Guid instanceId)
		{
			return
				((RetrieveActivePathResponse)service.Execute(
					new RetrieveActivePathRequest
					{
						ProcessInstanceId = instanceId
					})).ProcessStages.Entities;
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static string BuildTraversedPath(Guid stageId, IEnumerable<Guid> activePath)
		{
			var path = activePath.TakeWhile(s => s != stageId).Union(new[] { stageId }).Select(s => s.ToString()).StringAggregate();

			return path.IsFilled()
				? path
				: throw new Exception($"Couldn't find target stage '{stageId}' in the active path of the process.");
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static partial class SlaHelpers
	{
		/// <summary>
		///     Get the date by adding duration to the start date within timeslots
		/// Credit: https://www.codeproject.com/Articles/1181377/Calculate-Due-Date-Based-on-the-Customer-Service-C
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="calendarName">Calendar name as it appears in CRM</param>
		/// <param name="startDate">Date to measure from, in UTC</param>
		/// <param name="duration">Duration after the start date in minutes</param>
		/// <param name="service">CRM service</param>
		/// <returns>DateTime after adding the duration to the start date</returns>
		public static DateTime GetDueDate(string calendarName, DateTime startDate, int duration,
			IOrganizationService service, Guid? orgId = null)
		{
			var calendar = RetrieveCalender(calendarName, service, orgId);
			var holidays = RetrieveHolidays(calendar.HolidayRef, service, orgId);
			return ProcessCalendar(startDate, duration, calendar, holidays, service, orgId);
		}

		/// <summary>
		///     Get the date by adding duration to the start date within timeslots
		/// Credit: https://www.codeproject.com/Articles/1181377/Calculate-Due-Date-Based-on-the-Customer-Service-C
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="calendarId">ID of calendar to use</param>
		/// <param name="startDate">Date to measure from, in UTC</param>
		/// <param name="duration">Duration after the start date in minutes</param>
		/// <param name="service">CRM service</param>
		/// <returns>DateTime after adding the duration to the start date</returns>
		public static DateTime GetDueDate(Guid calendarId, DateTime startDate, int duration,
			IOrganizationService service, Guid? orgId = null)
		{
			var calendar = RetrieveCalender(calendarId, service, orgId);
			var holidays = RetrieveHolidays(calendar.HolidayRef, service, orgId);
			return ProcessCalendar(startDate, duration, calendar, holidays, service, orgId);
		}

		/// <summary>
		///     Get the date by adding duration to the start date within timeslots
		/// Credit: https://www.codeproject.com/Articles/1181377/Calculate-Due-Date-Based-on-the-Customer-Service-C
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="calendarName">Calendar name as it appears in CRM</param>
		/// <param name="startDate">Date to measure from, in UTC</param>
		/// <param name="endDate">Date to measure to, in UTC</param>
		/// <param name="service">CRM service</param>
		/// <returns>Duration, in minutes, within the given range</returns>
		public static int GetDuration(string calendarName, DateTime startDate, DateTime endDate,
			IOrganizationService service, Guid? orgId = null)
		{
			var calendar = RetrieveCalender(calendarName, service, orgId);
			var holidays = RetrieveHolidays(calendar.HolidayRef, service, orgId);
			return ProcessCalendar(startDate, endDate, calendar, holidays, service, orgId);
		}

		/// <summary>
		///     Get the date by adding duration to the start date within timeslots
		/// Credit: https://www.codeproject.com/Articles/1181377/Calculate-Due-Date-Based-on-the-Customer-Service-C
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		/// <param name="calendarId">ID of calendar to use</param>
		/// <param name="startDate">Date to measure from, in UTC</param>
		/// <param name="endDate">Date to measure to, in UTC</param>
		/// <param name="service">CRM service</param>
		/// <returns>Duration, in minutes, within the given range</returns>
		public static int GetDuration(Guid calendarId, DateTime startDate, DateTime endDate,
			IOrganizationService service, Guid? orgId = null)
		{
			var calendar = RetrieveCalender(calendarId, service, orgId);
			var holidays = RetrieveHolidays(calendar.HolidayRef, service, orgId);
			return ProcessCalendar(startDate, endDate, calendar, holidays, service, orgId);
		}

		private static CrmCalendar RetrieveCalender(string calendarName, IOrganizationService service, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.RetrieveCalender|{calendarName}";
			var calendars = CacheHelpers.GetFromMemCache<DataCollection<Entity>>(cacheKey, orgId: orgId);

			if (calendars == null)
			{
				var query =
					new QueryExpression("calendar") { ColumnSet = new ColumnSet("holidayschedulecalendarid") };
				query.Criteria.AddCondition("name", ConditionOperator.Equal, calendarName);
				query.NoLock = true;
				calendars = service.RetrieveMultiple(query).Entities;

				CacheHelpers.AddToMemCache(cacheKey, calendars, CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
			}

			return calendars.Select(calendar =>
				new CrmCalendar
				{
					Id = calendar.Id,
					HolidayRef = calendar.GetAttributeValue<EntityReference>("holidayschedulecalendarid")
				}).FirstOrDefault();
		}

		private static CrmCalendar RetrieveCalender(Guid calendarId, IOrganizationService service, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.RetrieveCalender|{calendarId}";
			var calendar = CacheHelpers.GetFromMemCache<Entity>(cacheKey, orgId: orgId);

			if (calendar == null)
			{
				calendar = service.Retrieve("calendar", calendarId, new ColumnSet("holidayschedulecalendarid"));
				CacheHelpers.AddToMemCache(cacheKey, calendar, CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
			}

			return
				new CrmCalendar
				{
					Id = calendar.Id,
					HolidayRef = calendar.GetAttributeValue<EntityReference>("holidayschedulecalendarid")
				};
		}

		private static DateTime ProcessCalendar(DateTime startDate, int duration, CrmCalendar calendar, IEnumerable<Holiday> holidays,
			IOrganizationService service, Guid? orgId = null)
		{
			DateTime? targetDate = null;
			var defaultTarget = DateTime.UtcNow.AddMinutes(duration);


			while (targetDate == null)
			{
				var timeSlots = RetrieveCalendarTimeSlots(calendar.Id, service, startDate, null, orgId);
				var availableSlots = GetAvailableTimeSlots(timeSlots, holidays);

				foreach (var slot in availableSlots.Where(s => s.End > startDate))
				{
					var slotStart = slot.Start >= startDate ? slot.Start : startDate;
					var slotEnd = slot.End;
					var slotDuration = (int)((slotEnd - slotStart)?.TotalMinutes).GetValueOrDefault();

					// startDate was at the slot's end, or startDate was after the slot's end
					if (slotDuration <= 0)
					{
						continue;
					}

					if (slotDuration <= duration)
					{
						duration -= slotDuration;
						continue;
					}

					// something is wrong, assign default target date
					targetDate = slotStart?.AddMinutes(duration);
					break;
				}

				// duration > available slots
				if (targetDate == null)
				{
					var slotsEnd = timeSlots.LastOrDefault()?.End;

					// something is wrong, exit
					if (slotsEnd == null)
					{
						targetDate = defaultTarget;
					}
					else
					{
						// get more slots from CRM
						startDate = slotsEnd.Value;
					}
				}
			}

			return targetDate.Value;
		}

		private static int ProcessCalendar(DateTime startDate, DateTime endDate, CrmCalendar calendar, IEnumerable<Holiday> holidays,
			IOrganizationService service, Guid? orgId = null)
		{
			var timeSlots = RetrieveCalendarTimeSlots(calendar.Id, service, startDate, endDate, orgId);
			var availableSlots = GetAvailableTimeSlots(timeSlots, holidays);

			return
				(from slot in availableSlots.Where(s => s.End > startDate)
				 let slotStart = slot.Start >= startDate ? slot.Start : startDate
				 let slotEnd = slot.End <= endDate ? slot.End : endDate
				 let slotDuration = (int)Math.Round(((slotEnd - slotStart)?.TotalMinutes).GetValueOrDefault())
				 where slotDuration > 0
				 select slotDuration).Sum();
		}

		private static IEnumerable<Holiday> RetrieveHolidays(EntityReference holidayRef, IOrganizationService service, Guid? orgId = null)
		{
			var cacheKey = $"Yagasoft.Common.RetrieveHolidays|{holidayRef}";
			var rules = CacheHelpers.GetFromMemCache<DataCollection<Entity>>(cacheKey, orgId: orgId);

			if (rules == null && holidayRef != null)
			{
				rules = service.Retrieve(holidayRef.LogicalName, holidayRef.Id, new ColumnSet(true))
					.GetAttributeValue<EntityCollection>("calendarrules").Entities;
				CacheHelpers.AddToMemCache(cacheKey, rules, CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
			}

			return holidayRef == null
				? new Holiday[0]
				: rules.Select(holidayCalrule =>
						new Holiday
						{
							Start = holidayCalrule.GetAttributeValue<DateTime>("effectiveintervalstart"),
							End = holidayCalrule.GetAttributeValue<DateTime>("effectiveintervalend"),
							TimeZoneCode = holidayCalrule.GetAttributeValue<int?>("timezonecode")
						});
		}

		private static TimeInfo[] RetrieveCalendarTimeSlots(Guid calendarId, IOrganizationService service, DateTime startDate,
			DateTime? endDate = null, Guid? orgId = null)
		{
			startDate = startDate.Date;
			endDate = endDate?.AddDays(1).Date ?? startDate.AddDays(30);

			var cacheKey = $"Yagasoft.Common.RetrieveCalendarTimeSlots|{calendarId}|{startDate}|{endDate}";
			var slots = CacheHelpers.GetFromMemCache<TimeInfo[]>(cacheKey, orgId: orgId);

			if (slots == null)
			{
				slots = ((ExpandCalendarResponse)service.Execute(
					new ExpandCalendarRequest
					{
						CalendarId = calendarId,
						Start = startDate,
						End = endDate.Value
					})).result;
				CacheHelpers.AddToMemCache(cacheKey, slots, CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId: orgId);
			}

			return slots;
		}

		private static IEnumerable<TimeInfo> GetAvailableTimeSlots(TimeInfo[] timeSlots, IEnumerable<Holiday> holidays)
		{
			return
				from timeSlotQ in timeSlots
				where holidays?.Any(holiday => holiday.Start < timeSlotQ.Start && holiday.End > timeSlotQ.End) != true
				select timeSlotQ;
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public static class FetchXmlTriggerHelpers
	{
		/// <summary>
		/// Register steps to handle FetchXML condition changes.<br />
		/// If you only care about satisfaction of conditions, then only pass plugin configs for post-operations.<br />
		/// If you need to check for negative/dissatisfaction of conditions, use pre and post-operations,
		/// passing the list of 'root' record IDs from the pre to the post plugin through the SharedVariables object.<br />
		/// You must mark the 'root' plugin, which can be common with other triggers.<br />
		/// 'GetFilteredTriggerConfigs' method can be used to get the serialised trigger config from the plugin config,
		/// which contains the FetchXML used for fetching the 'root' records.
		///		Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void RegisterTriggeringStep(IOrganizationService service, string id, string suffix, string fetchXml,
			TriggerConfigPlugin[] pluginConfigs, Guid? orgId = null)
		{
			service.Require(nameof(service));
			pluginConfigs.Require(nameof(pluginConfigs));
			id.RequireNotEmpty(nameof(id));
			fetchXml.RequireNotEmpty(nameof(fetchXml));

			var triggerConfigs = new List<TriggerConfig>();

			ParseConditionFields(service, $"{id}{(string.IsNullOrWhiteSpace(suffix) ? "" : $"-{suffix}")}",
				fetchXml, triggerConfigs, orgId);
			RegisterTriggeringStep(service, pluginConfigs, triggerConfigs, false, orgId);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static void UnregisterTriggeringStep(IOrganizationService service, string id, string suffix, string fetchXml,
			TriggerConfigPlugin[] pluginConfigs, Guid? orgId = null)
		{
			service.Require(nameof(service));
			pluginConfigs.Require(nameof(pluginConfigs));
			id.RequireNotEmpty(nameof(id));
			fetchXml.RequireNotEmpty(nameof(fetchXml));

			var triggerConfigs = new List<TriggerConfig>();

			ParseConditionFields(service, $"{id}{(string.IsNullOrWhiteSpace(suffix) ? "" : $"-{suffix}")}",
				fetchXml, triggerConfigs, orgId);
			RegisterTriggeringStep(service, pluginConfigs, triggerConfigs, true, orgId);
		}

		public static IEnumerable<TriggerConfig> GetFilteredTriggerConfigs(string pluginConfig, params string[] fields)
		{
			return GetFilteredTriggerConfigs(ParseTriggerConfigs(pluginConfig), fields);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy (Yagasoft.com)
		/// </summary>
		public static IEnumerable<TriggerConfig> GetFilteredTriggerConfigs(IEnumerable<TriggerConfig> triggerConfigs,
			params string[] fields)
		{
			return triggerConfigs.Where(t => fields.Contains("*") || fields.Intersect(t.Fields).Any());
		}

		private static void RegisterTriggeringStep(IOrganizationService service, TriggerConfigPlugin[] pluginConfigs,
			IReadOnlyList<TriggerConfig> triggerConfigs, bool isRemoveCurrent = false, Guid? orgId = null)
		{
			service.Require(nameof(service));
			pluginConfigs.Require(nameof(pluginConfigs));
			triggerConfigs.Require(nameof(triggerConfigs));

			foreach (var triggerConfig in triggerConfigs)
			{
				var id = triggerConfig.Id;
				var entityName = triggerConfig.EntityName;

				foreach (var pluginConfig in pluginConfigs)
				{
					if (triggerConfig.IsRootEntity != pluginConfig.IsRootEntity)
					{
						continue;
					}

					var step = GetStep(service, GetStepName(pluginConfig.Type, pluginConfig.Message, entityName));

					// get existing entity map from plugin configuration
					var stepConfig = step?.GetAttributeValue<string>("configuration");
					var parsedStepConfig = stepConfig == null
						? new List<TriggerConfig>()
						: ParseTriggerConfigs(stepConfig).Where(c => c.Id != id).ToList();

					foreach (var config in parsedStepConfig.Where(c => string.IsNullOrWhiteSpace(c.EntityName)))
					{
						config.EntityName = entityName;
					}

					if (!isRemoveCurrent)
					{
						parsedStepConfig.Add(triggerConfig);
					}

					if (pluginConfig.ExtraTriggerFields?.Any() == true)
					{
						foreach (var field in pluginConfig.ExtraTriggerFields)
						{
							triggerConfig.Fields.Add(field);
						}
					}

					var filteredStepConfigs = parsedStepConfig.Where(c => c.Fields.Any()).ToArray();

					var parsedStepConfigString = filteredStepConfigs
						.Select(c => $"{c.Id}|||{c.IsRootEntity}|||{c.Fields.StringAggregate()}"
							+ $"{(c.IsRootEntity ? "" : $"|||{c.FetchXml.StringAggregate("^^^")}")}")
						.Aggregate("", (c1, c2) => $"{c1};;;{c2}").Trim(',', ';');

					string[] filteringAttributes = null;

					if (pluginConfig.Message == "Update")
					{
						filteringAttributes = filteredStepConfigs.SelectMany(c => c.Fields).Distinct().ToArray();
					}

					RegisterStep(service, entityName, pluginConfig, parsedStepConfigString, orgId, filteringAttributes);
				}
			}
		}

		private static IEnumerable<TriggerConfig> ParseTriggerConfigs(string rawString)
		{
			rawString.RequireNotEmpty(nameof(rawString));

			return rawString.Decompress()
				.Split(new[] { ";;;" }, StringSplitOptions.RemoveEmptyEntries)
				.Select(c => c.Split(new[] { "|||" }, StringSplitOptions.RemoveEmptyEntries))
				.Where(c => c.Any() && !string.IsNullOrWhiteSpace(c[0]))
				.Select(c =>
					new TriggerConfig
					{
						Id = c[0],
						IsRootEntity = c.Length > 1 && bool.Parse(c[1]),
						Fields = c.Length > 2 ? new HashSet<string>(c[2].Split(',')) : new HashSet<string>(),
						FetchXml = c.Length > 3
							? c[3].Split(new[] { "^^^" }, StringSplitOptions.RemoveEmptyEntries).ToList()
							: new List<string>()
					});
		}

		private static void ParseConditionFields(IOrganizationService service, string id, string fetchXml,
			List<TriggerConfig> triggerConfigs, Guid? orgId = null)
		{
			fetchXml.RequireNotEmpty(nameof(fetchXml));
			triggerConfigs.Require(nameof(triggerConfigs));

			var doc = new XmlDocument();
			doc.LoadXml(fetchXml);

			var parentNodes = doc.SelectNodes("//entity")?.Cast<XmlNode>().ToList();

			if (parentNodes == null)
			{
				throw new FormatException("FetchXML is not properly formatted.");
			}

			var linkNodes = doc.SelectNodes("//link-entity")?.Cast<XmlNode>();

			if (linkNodes != null)
			{
				parentNodes.AddRange(linkNodes);
			}

			foreach (var parent in parentNodes)
			{
				var conditionNodes = parent?.SelectNodes("filter//condition")?.Cast<XmlNode>();

				if (conditionNodes == null)
				{
					continue;
				}

				foreach (var node in conditionNodes)
				{
					var entityName = parent.Attributes?["name"]?.Value;
					var attributeName = node.Attributes?["attribute"]?.Value;

					if (entityName == null || attributeName == null)
					{
						continue;
					}

					var isRoot = parent.Name == "entity";
					var triggerConfig = triggerConfigs
							.FirstOrDefault(c => c.IsRootEntity == isRoot && c.EntityName == entityName);

					if (triggerConfig == null)
					{
						triggerConfig =
							new TriggerConfig
							{
								Id = id,
								IsRootEntity = isRoot,
								EntityName = entityName,
								FetchXml = new List<string>(),
								Fields = new HashSet<string>()
							};
						triggerConfigs.Add(triggerConfig);
					}

					triggerConfig.Fields.Add(attributeName);

					var xmlParser = new XmlDocument();
					var primaryIdField = MetadataHelpers.GetEntityAttribute<string>(service, entityName,
						MetadataHelpers.EntityAttribute.PrimaryIdAttribute, orgId);

					xmlParser.LoadXml("<temp><filter>"
						+ $@"<condition attribute=""{primaryIdField}"" operator=""eq"" value=""{{{{recordId}}}}""/></filter></temp>");

					var tempXmlNodes = xmlParser.SelectSingleNode("/temp")?.ChildNodes.Cast<XmlNode>();
					var newXmlNodes = new List<XmlNode>();

					if (tempXmlNodes != null)
					{
						foreach (var tempNode in tempXmlNodes)
						{
							var newNode = parent.OwnerDocument?.ImportNode(tempNode, true);
							newXmlNodes.Add(newNode);

							if (newNode != null)
							{
								parent.AppendChild(newNode);
							}
						}
					}

					var newFetchXml = doc.OuterXml;
					triggerConfig.FetchXml.Add(newFetchXml);

					foreach (var newXmlNode in newXmlNodes)
					{
						parent.RemoveChild(newXmlNode);
					}
				}
			}
		}

		private static void RegisterStep(IOrganizationService service, string entity, TriggerConfigPlugin pluginConfig,
			string unsecureConfig, Guid? orgId = null, params string[] filteringAttributes)
		{
			service.Require(nameof(service));
			entity.RequireNotEmpty(nameof(entity));
			pluginConfig.Require(nameof(pluginConfig));

			var message = GetMessage(service, entity, pluginConfig.Message, orgId);

			if (message == null)
			{
				throw new Exception($"Couldn't find a message '{pluginConfig.Message}' for entity '{entity}'.");
			}

			var query =
				new QueryExpression("plugintype")
				{
					Distinct = true,
					NoLock = true,
					ColumnSet = new ColumnSet("name", "plugintypeid")
				};
			query.Criteria.AddCondition("name", ConditionOperator.Equal, pluginConfig.Type);

			var type = service.RetrieveMultiple(query).Entities
				.Select(e =>
					new
					{
						e.Id,
						Name = e.GetAttributeValue<string>("name")
					}).FirstOrDefault();

			if (type == null)
			{
				throw new Exception($"Couldn't find '{pluginConfig.Type}' plugin type.");
			}

			message.PluginTypeId = type.Id;
			message.TypeName = type.Name;

			var stepName = GetStepName(message.TypeName, message.MessageName, entity);
			var step = GetStep(service, stepName);

			if (string.IsNullOrWhiteSpace(unsecureConfig))
			{
				if (step != null)
				{
					service.Delete("sdkmessageprocessingstep", step.Id);
				}
			}
			else
			{
				step = step
					?? new Entity("sdkmessageprocessingstep")
					{
						["name"] = stepName,
						["rank"] = 999,
						["stage"] = new OptionSetValue((int)pluginConfig.Stage),
						["supporteddeployment"] = new OptionSetValue(0),
						["sdkmessageid"] = new EntityReference("sdkmessage", message.MessageId),
						["sdkmessagefilterid"] = new EntityReference("sdkmessagefilter", message.FilteredId),
						["eventhandler"] = new EntityReference("plugintype", message.PluginTypeId)
					};

				step["configuration"] = unsecureConfig.Compress();

				if (filteringAttributes?.Any() == true)
				{
					step["filteringattributes"] = filteringAttributes.Aggregate("", (f1, f2) => $"{f1},{f2}").Trim(',', ';');
				}

				if (pluginConfig.Mode == PluginMode.Asynchronous)
				{
					step["asyncautodelete"] = true;
				}

				step["mode"] = new OptionSetValue((int)pluginConfig.Mode);

				if (step.Id == Guid.Empty)
				{
					var stepId = service.Create(step);

					if (pluginConfig.IsPreImage || pluginConfig.IsPostImage)
					{
						RegisterImage(service, pluginConfig, stepId);
					}
				}
				else
				{
					service.Update(step);
				}
			}
		}

		private static void RegisterImage(IOrganizationService service, TriggerConfigPlugin pluginConfig, Guid stepId)
		{
			service.Require(nameof(service));
			pluginConfig.Require(nameof(pluginConfig));

			int imageType;

			if (pluginConfig.IsPreImage && !pluginConfig.IsPostImage)
			{
				imageType = 0;
			}
			else if (!pluginConfig.IsPreImage && pluginConfig.IsPostImage)
			{
				imageType = 1;
			}
			else if (pluginConfig.IsPreImage && pluginConfig.IsPostImage)
			{
				imageType = 2;
			}
			else
			{
				throw new ArgumentOutOfRangeException("ImageType", "Image type is not supported.");
			}

			var image =
				new Entity("sdkmessageprocessingstepimage")
				{
					["name"] = "image",
					["entityalias"] = "image",
					["imagetype"] = new OptionSetValue(imageType),
					["messagepropertyname"] = pluginConfig.Message == "Create" ? "Id" : "Target",
					["sdkmessageprocessingstepid"] = new EntityReference("sdkmessageprocessingstep", stepId)
				};
			service.Create(image);
		}

		private static SdkMessageInfo GetMessage(IOrganizationService service, string entityName, string messageName,
			Guid? orgId = null)
		{
			service.Require(nameof(service));
			entityName.RequireNotEmpty(nameof(entityName));
			messageName.RequireNotEmpty(nameof(messageName));

			var query =
				new FetchExpression("<fetch no-lock='true' >" +
					"  <entity name='sdkmessage' >" +
					"    <attribute name='name' />" +
					"    <attribute name='sdkmessageid' />" +
					"    <filter>" +
					$"      <condition attribute='name' operator='eq' value='{messageName}' />" +
					"    </filter>" +
					"    <link-entity name='sdkmessagefilter' from='sdkmessageid' to='sdkmessageid' alias='messagefilter' >" +
					"      <attribute name='sdkmessagefilterid' />" +
					"      <filter>" +
					"        <condition attribute='primaryobjecttypecode' operator='eq'"
					+ $" value='{MetadataHelpers.GetTypeCodeUsingEntityName(service, entityName, orgId)}' />" +
					"      </filter>" +
					"    </link-entity>" +
					"  </entity>" +
					"</fetch>");

			var message = service.RetrieveMultiple(query).Entities
				.Select(e =>
					new SdkMessageInfo
					{
						MessageId = e.GetAttributeValue<Guid>("sdkmessageid"),
						MessageName = e.GetAttributeValue<string>("name"),
						FilteredId = (Guid)
							(e.GetAttributeValue<AliasedValue>("messagefilter.sdkmessagefilterid")?.Value ?? Guid.Empty)
					}).FirstOrDefault();

			if (message == null || message.MessageId == Guid.Empty || message.FilteredId == Guid.Empty)
			{
				throw new Exception($"Couldn't find {messageName} message for entity '{entityName}'.");
			}

			return message;
		}

		private static Entity GetStep(IOrganizationService service, string stepName)
		{
			service.Require(nameof(service));
			stepName.RequireNotEmpty(nameof(stepName));

			var query =
				new QueryExpression("sdkmessageprocessingstep")
				{
					NoLock = true,
					ColumnSet = new ColumnSet(true)
				};
			query.Criteria.AddCondition("name", ConditionOperator.Equal, stepName);
			return service.RetrieveMultiple(query).Entities.FirstOrDefault();
		}

		private static string GetStepName(string typeName, string messageName, string entityName)
		{
			var builder = new StringBuilder();
			builder.Append("FetchXmlTrigger: ");
			builder.Append(typeName);
			builder.Append(": ");
			builder.Append(messageName);
			builder.Append(" of ");
			builder.Append(entityName == "none" ? "any entity" : entityName);

			return builder.ToString();
		}
	}

	public class CacheParams
	{
		public Guid? OrgId;
		public string CacheSuffix;
		public DateTime? CacheExpiryTarget;
	}

	public class SdkMessageInfo
	{
		public Guid MessageId;
		public Guid FilteredId;
		public string MessageName;
		public Guid PluginTypeId;
		public string TypeName;
	}

	public class TriggerConfig
	{
		public string Id;
		public bool IsRootEntity;
		public string EntityName;
		public HashSet<string> Fields;
		public List<string> FetchXml;
	}

	public class TriggerConfigPlugin
	{
		public string Type;
		public string Message;
		public bool IsRootEntity;
		public PluginStage Stage;
		public PluginMode Mode;
		public bool IsPreImage;
		public bool IsPostImage;
		public string[] ExtraTriggerFields;
	}

	public class CrmCalendar
	{
		public Guid Id;
		public EntityReference HolidayRef;
	}

	public class Holiday
	{
		public DateTime Start;
		public DateTime End;
		public int? TimeZoneCode;
	}

	public class RetrievePagingInfo
	{
		public string Cookie
		{
			get; set;
		}

		public int NextPage { get; set; } = 1;

		public int RecordCountLimit { get; set; } = -1;

		public bool IsMoreRecords { get; set; } = true;
	}

	public class BpfRecord
	{
		public Guid Id
		{
			get; set;
		}
		public string LogicalName
		{
			get; set;
		}
		public Guid? ProcessId
		{
			get; set;
		}
		public Guid? StageId
		{
			get; set;
		}
		public string TraversedPath
		{
			get; set;
		}
	}

	public class BpfStageRecord
	{
		public Guid Id { get; set; }
		public EntityReference StageRecord { get; set; }
		public string ActivePath { get; set; }
		public string TraversedPath { get; set; }
	}

	public class BpfStageInfo
	{
		public Guid Id
		{
			get; set;
		}

		public string Name
		{
			get; set;
		}

		public int Index
		{
			get; set;
		}
	}

	public class ExecuteBulkResponse
	{
		public OrganizationResponse Response
		{
			get; set;
		}

		public Type RequestType
		{
			get; set;
		}

		public Type ResponseType
		{
			get; set;
		}

		public OrganizationServiceFault Fault
		{
			get; set;
		}

		public string FaultMessage
		{
			get; set;
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	public class EntityComparer : IEqualityComparer<Entity>
	{
		public bool Equals(Entity x, Entity y)
		{
			return x.Id == y.Id;
		}

		public int GetHashCode(Entity obj)
		{
			return obj.Id.GetHashCode();
		}
	}

	/// <summary>
	/// Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	public class EntityRefComparer : IEqualityComparer<EntityReference>
	{
		public bool Equals(EntityReference x, EntityReference y)
		{
			return x.Id == y.Id;
		}

		public int GetHashCode(EntityReference obj)
		{
			return obj.Id.GetHashCode();
		}
	}

	public class RelationMetadata
	{
		public string SchemaName
		{
			get; set;
		}
		public string Entity1Name
		{
			get; set;
		}
		public string Entity1FieldName
		{
			get; set;
		}
		public string Entity2Name
		{
			get; set;
		}
		public string Entity2FieldName
		{
			get; set;
		}
		public MetadataHelpers.RelationType Type
		{
			get; set;
		}
		public string IntersectingEntityName
		{
			get; set;
		}
	}

	/// <summary>
	///     Unlike <see cref="Semaphore" />, this implementation ensures that holds are released in the order of acquiring the
	///     hold.
	///     It also implements <see cref="IDisposable" />, but in a reusable fashion; e.g:
	///     <code>	using (fifoSemaphore.GetPermit())
	/// 	{
	///  		// code ...
	///   	}
	///     </code>
	///     After exiting the 'using' block, <see cref="ReleasePermit" /> is called automatically.<br />
	///		Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public sealed class FifoSemaphore : IDisposable
	{
		private readonly Queue<ManualResetEvent> threadLocksQueue = new Queue<ManualResetEvent>();

		private readonly int maxConcurrency;

		private readonly object lockObject = new object();
		private int currentRequests;

		public FifoSemaphore(int maxConcurrency)
		{
			this.maxConcurrency = maxConcurrency;
		}

		public void Dispose()
		{
			ReleasePermit();
		}

		/// <summary>
		///     Check how many permits have been requested before, and if the number is greater than the limit,
		///     hold this request until a permit elsewhere is released.
		/// </summary>
		public FifoSemaphore AcquirePermit()
		{
			lock (lockObject)
			{
				currentRequests++;

				// if the limit hasn't been reached yet, note it, and give permission
				if (currentRequests <= maxConcurrency)
				{
					return this;
				}
			}

			using (var newLock = new ManualResetEvent(false))
			{
				// we have to wait for a slot to open
				threadLocksQueue.Enqueue(newLock);
				newLock.WaitOne();
			}

			return this;
		}

		/// <summary>
		///     Release a permit, and release the hold on the next in line.
		/// </summary>
		public void ReleasePermit()
		{
			lock (lockObject)
			{
				// note the release
				currentRequests--;

				// give permission to the next in line
				if (threadLocksQueue.Any())
				{
					threadLocksQueue.Dequeue().Set();
				}
			}
		}
	}

	/// <summary>
	///     credits: http://joe-bq-wang.iteye.com/blog/1878940 <br />
	///		Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public sealed class QueuedLock : IDisposable
	{
		private readonly object innerLock;
		private volatile int ticketsCount;
		private volatile int ticketToRide;

		public QueuedLock()
		{
			innerLock = new object();
			ticketToRide = ticketsCount + 1;
		}

		public void Dispose()
		{
			Exit();
		}

		public QueuedLock Enter()
		{
			var myTicket = Interlocked.Increment(ref ticketsCount);
			Monitor.Enter(innerLock);

			while (true)
			{
				if (myTicket == ticketToRide)
				{
					return this;
				}

				Monitor.Wait(innerLock);
			}
		}

		public void Exit()
		{
			Interlocked.Increment(ref ticketToRide);
			Monitor.PulseAll(innerLock);
			Monitor.Exit(innerLock);
		}
	}

	/// <summary>
	///     credits: http://joe-bq-wang.iteye.com/blog/1878940<br />
	///		Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public class BlockingQueue<T> : BlockingCollection<T>
	{
		#region ctor(s)

		public BlockingQueue() : base(new ConcurrentQueue<T>())
		{ }

		public BlockingQueue(int maxSize) : base(new ConcurrentQueue<T>(), maxSize)
		{ }

		#endregion ctor(s)

		#region Methods

		/// <summary>
		///     Enqueue an Item
		/// </summary>
		/// <param name="item">Item to enqueue</param>
		/// <remarks>Blocks if the blocking queue is full</remarks>
		public void Enqueue(T item)
		{
			Add(item);
		}

		/// <summary>
		///     Dequeue an item
		/// </summary>
		/// <param name="timeout">[Optional] The number of milliseconds to timeout while waiting. Value of -1 is infinite wait.</param>
		/// <returns>Item dequeued</returns>
		/// <remarks>Blocks if the blocking queue is empty</remarks>
		/// <exception cref="TimeoutException">Timeout expired.</exception>
		public T Dequeue(TimeSpan? timeout = null)
		{
			if (timeout == null)
			{
				return Take();
			}

			try
			{
				return Take(new CancellationTokenSource(timeout.Value).Token);
			}
			catch (OperationCanceledException)
			{
				throw new TimeoutException($"Timeout while waiting for an item to be added to the queue (timeout: {timeout} ms).");
			}
		}

		public T Dequeue(CancellationTokenSource cancellationToken)
		{
			return Take(cancellationToken.Token);
		}

		/// <summary>
		///     Clears the queue of all items
		/// </summary>
		public void Clear()
		{
			while (this.Any())
			{
				Dequeue();
			}
		}

		#endregion Methods
	}

	/// <summary>
	///     Adds to the queue, up to the limit, after which it dequeues to keep the size within the limit.<br />
	///     credits: https://stackoverflow.com/a/5852926/1919456<br />
	///		Author: Ahmed Elsawalhy (Yagasoft.com)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public class FixedSizeQueue<T> : ICollection<T>, IEnumerable<T>, IEnumerable, ICollection
	{
		public virtual int Count => q.Count;
		public virtual object SyncRoot => throw new NotSupportedException();
		public virtual bool IsSynchronized => false;
		public virtual bool IsReadOnly => false;

		protected readonly ConcurrentQueue<T> q = new ConcurrentQueue<T>();
		protected virtual int limit { get; set; }

		public FixedSizeQueue(int limit)
		{
			limit.RequireAtLeast(1, nameof(limit));
			this.limit = limit;
		}

		public virtual void Enqueue(T obj)
		{
			q.Enqueue(obj);
			while (q.Count > limit && q.TryDequeue(out var _)) ;
		}

		public virtual T Dequeue()
		{
			q.TryDequeue(out var e);
			return e;
		}

		public virtual void Add(T item)
		{
			Enqueue(item);
		}

		public virtual void Clear()
		{
			while (q.Any())
			{
				Dequeue();
			}
		}

		public virtual bool Contains(T item)
		{
			return q.Contains(item);
		}

		public virtual void CopyTo(T[] array, int arrayIndex)
		{
			array.Require(nameof(array));
			q.CopyTo(array, arrayIndex);
		}

		public virtual bool Remove(T item)
		{
			throw new NotSupportedException();
		}

		public virtual void CopyTo(Array array, int index)
		{
			array.Require(nameof(array));
			this.ToArray().CopyTo(array, index);
		}

		public virtual IEnumerator<T> GetEnumerator()
		{
			return q.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}

	#endregion

	#region CrmLog

	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	[DebuggerNonUserCode]
	public sealed class LogAttribute : Attribute
	{
	}

	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public sealed class NoLogAttribute : Attribute
	{
	}

	/// <summary>
	///     Receives log entries and saves them to CRM, disk, or output to console.<br />
	///		Author: Ahmed Elsawalhy (Yagasoft.com)<br />
	///     Version: 4.2.1
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public class CrmLog
	{
		[Flags]
		private enum LogModeInternal
		{
			None = 0,
			CrmLog = 1,
			TraceService = 1 << 1,
			File = 1 << 2,
			Console = 1 << 3
		}

		#region Fields

		private static readonly Guid configMemCacheKeyBase = Guid.NewGuid();

		private Guid ConfigMemCacheKey => orgId ?? configMemCacheKeyBase;

		private readonly Guid? orgId;
		private readonly bool isSandboxMode;
		private readonly bool isPlugin;
		private Entity parentLog;
		private bool exceptionThrown;
		private LogEntry exceptionLogEntry;
		private Queue<LogEntry> logQueue;
		private Queue<LogEntry> offlineQueue;
		private Stack<LogEntry> execSeqStack;
		private Stopwatch executionTimer;
		private Stack<Stopwatch> functionTimersStack;
		private Stack<int> durationsStack;
		private bool isAutoLogToConsole;
		private bool isParentCreated;
		private bool? isBulkPreviously;
		
		private LogModeInternal logModes;


		#endregion

		#region Constructors

		/// <summary>
		///     Constructor!
		/// </summary>
		/// <param name="maximumLevel">[Optional] The maximum logging level to use, above which, no logs will be saved</param>
		public CrmLog(LogLevel? maximumLevel = null, [CallerMemberName] string callingFunction = "")
		{
			InitialiseLog(null, null, maximumLevel, callingFunction);
			logModes |= LogModeInternal.File;
		}

		/// <summary>
		///     Constructor!
		/// </summary>
		/// <param name="organizationService">The service to be used to flush the entries to CRM</param>
		/// <param name="maximumLevel">[Optional] The maximum logging level to use, above which, no logs will be saved</param>
		public CrmLog(IOrganizationService organizationService, LogLevel? maximumLevel = null,
			[CallerMemberName] string callingFunction = "")
		{
			logModes |= LogModeInternal.CrmLog;
			InitialiseLog(organizationService, null, maximumLevel, callingFunction);
		}

		/// <summary>
		///     Constructor!
		/// </summary>
		/// <param name="organizationService">The service to be used to flush the entries to CRM.</param>
		/// <param name="traceService">The Plugin Tracing service used to log to CRM.</param>
		/// <param name="userId">The ID of the user that is going to be set in the logs.</param>
		/// <param name="maximumLevel">[Optional] The maximum logging level to use, above which, no logs will be saved.</param>
		public CrmLog(IOrganizationService organizationService, ITracingService traceService, Guid userId,
			bool isTraceOnly = false, LogLevel? maximumLevel = null, [CallerMemberName] string callingFunction = "")
		{
			UserId = userId;

			if (!isTraceOnly)
			{
				logModes |= LogModeInternal.CrmLog;
			}

			logModes |= LogModeInternal.TraceService;
			InitialiseLog(organizationService, traceService, maximumLevel, callingFunction);
		}

		/// <summary>
		///     Initializes a new instance of the <see cref="CrmLog" /> class.
		/// </summary>
		/// <param name="serviceProvider">The service provider from a plugin.</param>
		/// <param name="isTraceOnly">Excludes CRM Log feature.</param>
		/// <param name="maximumLevel">[OPTIONAL] The maximum level.</param>
		public CrmLog(IServiceProvider serviceProvider, bool isTraceOnly = false, LogLevel? maximumLevel = null,
			[CallerMemberName] string callingFunction = "")
		{
			serviceProvider.Require(nameof(serviceProvider));

			if (!isTraceOnly)
			{
				logModes |= LogModeInternal.CrmLog;
			}

			logModes |= LogModeInternal.TraceService;

			var context = (IPluginExecutionContext)serviceProvider.GetService(typeof(IPluginExecutionContext));
			UserId = context.InitiatingUserId;
			isSandboxMode = context.IsolationMode == 2;
			isPlugin = true;

			orgId = context.OrganizationId;

			var service = ((IOrganizationServiceFactory)serviceProvider.GetService(typeof(IOrganizationServiceFactory)))
				.CreateOrganizationService(null);
			var tracingService = (ITracingService)serviceProvider.GetService(typeof(ITracingService));

			InitialiseLog(service, tracingService, maximumLevel, callingFunction);
		}

		/// <summary>
		///     Initializes a new instance of the <see cref="CrmLog" /> class.
		/// </summary>
		/// <param name="activityContext">The activity context from a custom step.</param>
		/// <param name="isTraceOnly">Excludes CRM Log feature.</param>
		/// <param name="maximumLevel">[OPTIONAL] The maximum level.</param>
		public CrmLog(ActivityContext activityContext, bool isTraceOnly = false, LogLevel? maximumLevel = null,
			[CallerMemberName] string callingFunction = "")
		{
			activityContext.Require(nameof(activityContext));

			if (!isTraceOnly)
			{
				logModes |= LogModeInternal.CrmLog;
			}

			logModes |= LogModeInternal.TraceService;

			var context = activityContext.GetExtension<IWorkflowContext>();
			UserId = context.InitiatingUserId;
			isSandboxMode = context.IsolationMode == 2;
			isPlugin = true;

			orgId = context.OrganizationId;

			var service = activityContext.GetExtension<IOrganizationServiceFactory>().CreateOrganizationService(null);
			var tracingService = activityContext.GetExtension<ITracingService>();

			InitialiseLog(service, tracingService, maximumLevel, callingFunction);
		}

		/// <summary>
		///     Initializes a new instance of the <see cref="CrmLog" /> class.
		/// </summary>
		/// <param name="path">[OPTIONAL] The path.</param>
		/// <param name="maximumLevel">[OPTIONAL] The maximum level.</param>
		/// <param name="config">[OPTIONAL] Parameters to use in managing offline logging.</param>
		public CrmLog(string path = "", LogLevel? maximumLevel = null, FileConfiguration config = null,
			[CallerMemberName] string callingFunction = "")
		{
			logModes |= LogModeInternal.File;
			InitialiseLog(null, null, maximumLevel, callingFunction);
			InitOfflineLog(path, false, config);
		}

		/// <summary>
		///     Initializes a new instance of the <see cref="CrmLog" /> class.
		/// </summary>
		/// <param name="isAutoLog">If 'true', automatically output log entries to the console.</param>
		/// <param name="maxLogLevel">[OPTIONAL] The maximum log level to output to console. Default is 'Info'.</param>
		public CrmLog(bool isAutoLog, LogLevel? maxLogLevel = null, [CallerMemberName] string callingFunction = "")
		{
			logModes |= LogModeInternal.File | LogModeInternal.Console;
			InitialiseLog(null, null, maxLogLevel, callingFunction);
			MaxConsoleLogLevel = maxLogLevel ?? LogLevel.Info;
			IsAutoLogToConsole = isAutoLog;
		}

		protected CrmLog()
		{
		}

		#endregion

		/// <summary>
		///     The end states of the program that contains the logging object
		/// </summary>
		public enum ExecutionEndState
		{
			Success = 0,
			Failure = 1
		}

		#region Instance variables

		public IOrganizationService OrganizationService
		{
			get; private set;
		}

		public ITracingService TraceService
		{
			get; private set;
		}

		public Guid UserId
		{
			get; private set;
		}

		public FileConfiguration Config
		{
			get; private set;
		}

		public LogLevel MaxLogLevel
		{
			get; private set;
		}

		public ExecutionEndState AssemblyExecutionState
		{
			get; private set;
		}

		public int CurrentEntryIndex
		{
			get; private set;
		}

		public DateTime LogStartDate
		{
			get; private set;
		}

		public bool ExecutionStarted
		{
			get; private set;
		}

		public string OfflinePath
		{
			get; private set;
		}

		public bool IsFailOver
		{
			get; private set;
		}

		public LogLevel MaxConsoleLogLevel
		{
			get; private set;
		}

		public bool IsAutoLogToConsole
		{
			get => isAutoLogToConsole;

			private set
			{
				isAutoLogToConsole = value;

				if (isAutoLogToConsole)
				{
					logModes |= LogModeInternal.Console;
				}
			}
		}

		public event EventHandler<LogEntryAddedEventArgs> LogEntryAdded;

		#endregion

		#region Init

		/// <summary>
		///     Sets the emulated 'regarding' fields in the parent log
		/// </summary>
		/// <param name="regardingType">The logical name of the concerned entity.</param>
		/// <param name="regardingId">The ID of the regarding record.</param>
		/// <param name="regardingName">
		///     [OPTIONAL] The primary field value of the concerned entity (usually the 'xxx_name' field
		///     value).
		/// </param>
		public void SetRegarding(string regardingType, string regardingId, string regardingName = "")
		{
			parentLog["ldv_regardingtype"] = regardingType;
			parentLog["ldv_regardingid"] = regardingId;
			parentLog["ldv_regardingname"] = regardingName;
		}

		/// <summary>
		///     Sets the emulated 'regarding' fields in the parent log
		/// </summary>
		/// <param name="regardingType">The logical name of the concerned entity.</param>
		/// <param name="regardingId">The ID of the regarding record.</param>
		/// <param name="regardingName">
		///     [OPTIONAL] The primary field value of the concerned entity (usually the 'xxx_name' field
		///     value).
		/// </param>
		public void SetRegarding(string regardingType, Guid regardingId, string regardingName = "")
		{
			SetRegarding(regardingType, regardingId.ToString(), regardingName);
		}

		/// <summary>
		///     Sets the emulated 'regarding' fields in the parent log
		/// </summary>
		/// <param name="regarding">The reference to the concerned entity.</param>
		/// <param name="regardingName">
		///     [OPTIONAL] The primary field value of the concerned entity (usually the 'xxx_name' field
		///     value).
		/// </param>
		public void SetRegarding(EntityReference regarding, string regardingName = "")
		{
			regarding.Require(nameof(regarding));
			SetRegarding(regarding.LogicalName, regarding.Id, regardingName);
		}

		/// <summary>
		///     Sets the emulated 'regarding' fields in the parent log.
		/// </summary>
		/// <param name="regarding">The concerned entity.</param>
		/// <param name="primaryFieldName">
		///     [OPTIONAL=null]If null, fetch the 'name' field if it does not have a value in regarding
		///     passed.
		/// </param>
		public void SetRegarding(Entity regarding, string primaryFieldName = null)
		{
			regarding.Require(nameof(regarding));
			var nameField = string.IsNullOrWhiteSpace(primaryFieldName) && MaxLogLevel == LogLevel.Debug
				? MetadataHelpers.GetEntityAttribute<string>(OrganizationService, regarding.LogicalName,
					MetadataHelpers.EntityAttribute.PrimaryNameAttribute, ConfigMemCacheKey)
				: primaryFieldName;
			var name = regarding.GetAttributeValue<string>(nameField)
				?? (MaxLogLevel == LogLevel.Debug
					? CrmHelpers.GetRecordName(OrganizationService, regarding.LogicalName, regarding.Id, nameField,
						ConfigMemCacheKey)
					: string.Empty);
			SetRegarding(regarding.ToEntityReference(), name);
		}

		/// <summary>
		///     Sets the title field in the parent log.
		/// </summary>
		/// <param name="title">Title to set.</param>
		public void SetTitle(string title)
		{
			parentLog["ldv_title"] = title;
		}

		/// <summary>
		///     Sets the title field in the parent log in the format 'Log for "{name}".'.
		/// </summary>
		/// <param name="name">Name of the record.</param>
		public void SetDefaultTitle(string name)
		{
			SetTitle("Log for \"" + name + "\".");
		}

		/// <summary>
		///     Sets the title field in the parent log. Also, sets the regarding with the primary name.<br />
		///     Pass a format with '{name}' to be replaced by record name.
		/// </summary>
		/// <param name="regarding">The concerned entity.</param>
		/// <param name="primaryFieldName">
		///     [OPTIONAL=null]If null, fetch the 'name' field if it does not have a value in regarding
		///     passed.
		/// </param>
		/// <param name="titleTemplate">[OPTIONAL=null]If null, uses 'Log for "{name}".'.</param>
		public void SetTitle(Entity regarding, string primaryFieldName = null, string titleTemplate = null)
		{
			SetRegarding(regarding, primaryFieldName);

			var name = parentLog.GetAttributeValue<string>("ldv_regardingname");

			if (string.IsNullOrWhiteSpace(name))
			{
				return;
			}

			var title = (string.IsNullOrWhiteSpace(titleTemplate) ? "Log for \"{name}\"." : titleTemplate)
				.Replace("{name}", name);
			parentLog["ldv_title"] = title;
		}

		/// <summary>
		///     Sets the entry class of the parent log.
		/// </summary>
		public void SetEntryClass(string entryClass = null)
		{
			parentLog["ldv_entryclass"] = entryClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog");
		}

		/// <summary>
		///     Initializes the offline log.
		/// </summary>
		/// <param name="logPath">
		///     [OPTIONAL] The file to log to. Should be absolute path in the file system.
		///     Logs to C:\Logs\[assemblyName].csv by default.
		/// </param>
		/// <param name="isFailOver">[OPTIONAL] If 'true', only log to file if CRM is unavailable.</param>
		/// <param name="config">[OPTIONAL] Parameters to use in managing offline logging.</param>
		public void InitOfflineLog(string logPath = "", bool isFailOver = true, FileConfiguration config = null)
		{
			Config = config;
			OfflinePath = logPath;
			IsFailOver = isFailOver;
			logModes |= LogModeInternal.File;
		}

		/// <summary>
		///     Initializes console logging.
		/// </summary>
		/// <param name="isAutoLog">[OPTIONAL] If 'true', automatically output log entries to the console. Default is 'true'.</param>
		/// <param name="maxLogLevel">[OPTIONAL] The maximum log level to output to console. Default is 'Info'.</param>
		public void InitConsoleLog(bool isAutoLog = true, LogLevel maxLogLevel = LogLevel.Info)
		{
			MaxConsoleLogLevel = maxLogLevel;
			logModes |= LogModeInternal.Console;
			IsAutoLogToConsole = isAutoLog;
		}

		/// <summary>
		///     Initializes Plugin Trace service logging.
		/// </summary>
		public void InitTraceServiceLog(ITracingService traceService)
		{
			logModes |= LogModeInternal.TraceService;
			TraceService = traceService;
		}

		#endregion

		#region Function start/end logging

		/// <summary>
		///     Logs the start of execution.
		/// </summary>
		/// <param name="message">The message to set in the log entry</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void LogExecutionStart(string message, IExecutionContext context = null,
			string callingClass = null, string stackTrace = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			LogExecutionStart(new LogEntry(message), context, callingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
				stackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"), callingFunction, callingLineNumber);
		}

		/// <summary>
		///     Logs the start of execution.
		/// </summary>
		/// <param name="logEntry">[Optional] The log entry object that includes all relevant information</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void LogExecutionStart(LogEntry logEntry = null, IExecutionContext context = null,
			string callingClass = null, string stackTrace = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			if (MaxLogLevel == LogLevel.None)
			{
				return;
			}

			try
			{
				ExecutionStarted = true;

				var defaultMessage = "Started execution: " + callingFunction;

				logEntry = logEntry ?? new LogEntry(defaultMessage);

				// log this at any level
				logEntry.Level = LogLevel.None;

				// set as root in call sequence
				execSeqStack.Push(logEntry); 

				if (string.IsNullOrWhiteSpace(logEntry.Message))
				{
					logEntry.Message = defaultMessage;
				}

				Log(logEntry, string.Empty, string.Empty, context, callingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
					stackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"), -1,
					true, callingFunction, callingLineNumber);

				// start measuring execution duration
				executionTimer = Stopwatch.StartNew();

				// push a zero-based timestamp
				durationsStack.Push(0);
			}
			catch
			{
				if (context != null && OrganizationService != null)
				{
					throw;
				}
			}
		}

		/// <summary>
		///     Logs the start of a function.
		/// </summary>
		/// <param name="message">The message to set in the log entry</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void LogFunctionStart(string message, IExecutionContext context = null,
			string callingClass = null, string stackTrace = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			LogFunctionStart(new LogEntry(message), context, callingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
				stackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"), callingFunction, callingLineNumber);
		}

		/// <summary>
		///     Logs the start of a function.
		/// </summary>
		/// <param name="logEntry">[Optional] The log entry object that includes all relevant information</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void LogFunctionStart(LogEntry logEntry = null, IExecutionContext context = null,
			string callingClass = null, string stackTrace = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			if (MaxLogLevel == LogLevel.None)
			{
				return;
			}

			try
			{
				if (!ExecutionStarted)
				{
					LogExecutionStart(callingClass: callingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
						stackTrace: stackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"),
						callingFunction: callingFunction, callingLineNumber: callingLineNumber);
				}

				var defaultMessage = "Started: " + callingFunction;

				logEntry = logEntry ?? new LogEntry(defaultMessage);

				// set the parent as the previous in the stack, and set as parent in call sequence for next entries
				logEntry.ParentLogEntry = execSeqStack.Peek();
				execSeqStack.Push(logEntry);

				if (string.IsNullOrWhiteSpace(logEntry.Message))
				{
					logEntry.Message = defaultMessage;
				}

				logEntry.Level = LogLevel.Debug;

				Log(logEntry, string.Empty, string.Empty, context, callingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
					stackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"), -1,
					true, callingFunction, callingLineNumber);

				// start measuring function duration
				functionTimersStack.Push(Stopwatch.StartNew());
				executionTimer = executionTimer ?? functionTimersStack.Peek(); // keep the first timer to log execution time
				// push a zero-based timestamp
				durationsStack.Push(0);
			}
			catch
			{
				if (context != null && OrganizationService != null)
				{
					throw;
				}
			}
		}

		/// <summary>
		///     Logs the end of a function.
		/// </summary>
		/// <param name="message">The message to set in the log entry</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void LogFunctionEnd(string message, IExecutionContext context = null,
			string callingClass = null, string stackTrace = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			LogFunctionEnd(new LogEntry(message), context, callingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
				stackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"), callingFunction, callingLineNumber);
		}

		/// <summary>
		///     Logs the end of a function.
		/// </summary>
		/// <param name="logEntry">[Optional] The log entry object that includes all relevant information</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void LogFunctionEnd(LogEntry logEntry = null, IExecutionContext context = null,
			string callingClass = null, string stackTrace = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			if (MaxLogLevel == LogLevel.None)
			{
				return;
			}

			try
			{
				// stop function timer and get the elapsed time
				functionTimersStack.Peek().Stop();
				var elapsedTime = (int)functionTimersStack.Pop().ElapsedMilliseconds;

				// remove the duration reference of the function
				durationsStack.Pop();

				var defaultMessage = "Finished: " + callingFunction;

				logEntry = logEntry ?? new LogEntry(defaultMessage);

				// log this at any level
				logEntry.Level = LogLevel.None;

				// set parent, then remove it from sequence of calls
				execSeqStack.Pop();

				if (execSeqStack.Any())
				{
					logEntry.ParentLogEntry = execSeqStack.Peek();
				}

				if (string.IsNullOrWhiteSpace(logEntry.Message))
				{
					logEntry.Message = defaultMessage;
				}

				logEntry.Level = LogLevel.Debug;

				Log(logEntry, string.Empty, string.Empty, context, callingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
					stackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"), elapsedTime,
					true, callingFunction, callingLineNumber);
			}
			catch
			{
				if (context != null && OrganizationService != null)
				{
					throw;
				}
			}
		}

		/// <summary>
		///     Logs the end of execution.
		/// </summary>
		/// <param name="message">The message to set in the log entry</param>
		/// <param name="autoFlush">[Optional] Automatically flush after ending execution</param>
		/// <param name="state">[Optional] The state at which the execution ended</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void LogExecutionEnd(string message, bool autoFlush = true, ExecutionEndState state = ExecutionEndState.Success,
			IExecutionContext context = null,
			string callingClass = null, string stackTrace = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			LogExecutionEnd(autoFlush, state, new LogEntry(message), context, callingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
				stackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"), callingFunction, callingLineNumber);
		}

		/// <summary>
		///     Logs the end of execution.
		/// </summary>
		/// <param name="state">[Optional] The state at which the execution ended</param>
		/// <param name="message">[Optional] The message to set in the log entry</param>
		/// <param name="autoFlush">[Optional] Automatically flush after ending exectution</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void LogExecutionEnd(ExecutionEndState state, string message = "", bool autoFlush = true,
			IExecutionContext context = null, string callingClass = null, string stackTrace = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			LogExecutionEnd(autoFlush, state, new LogEntry(message), context, callingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
				stackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"), callingFunction, callingLineNumber);
		}

		/// <summary>
		///     Logs the end of execution.
		/// </summary>
		/// <param name="autoFlush">[Optional] Automatically flush after ending exectution</param>
		/// <param name="state">[Optional] The state at which the execution ended</param>
		/// <param name="logEntry">[Optional] The log entry object that includes all relevant information</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void LogExecutionEnd(bool autoFlush = true, ExecutionEndState state = ExecutionEndState.Success,
			LogEntry logEntry = null,
			IExecutionContext context = null, string callingClass = null, string stackTrace = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			if (MaxLogLevel == LogLevel.None)
			{
				return;
			}

			try
			{
				if (!ExecutionStarted)
				{
					LogExecutionStart(callingClass: callingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
						stackTrace: stackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"),
						callingFunction: callingFunction, callingLineNumber: callingLineNumber);
				}

				// stop execution timer
				executionTimer.Stop();

				// remove the duration reference of the function
				durationsStack.Pop();

				AssemblyExecutionState = (AssemblyExecutionState == ExecutionEndState.Failure) ? AssemblyExecutionState : state;

				var defaultMessage = "Finished execution: " + callingFunction;

				logEntry = logEntry ?? new LogEntry(defaultMessage);

				// log this at any level
				logEntry.Level = LogLevel.None;

				// set parent, then remove it from sequence of calls
				if (execSeqStack.Any())
				{
					logEntry.ParentLogEntry = execSeqStack.Pop();
				}

				if (string.IsNullOrWhiteSpace(logEntry.Message))
				{
					logEntry.Message = defaultMessage;
				}

				Log(logEntry, string.Empty, string.Empty, context, callingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
					stackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"),
					(int)executionTimer.ElapsedMilliseconds, true, callingFunction, callingLineNumber);
			}
			catch
			{
				if (context != null && OrganizationService != null)
				{
					throw;
				}
			}
			finally
			{
				if (autoFlush)
				{
					Flush();
				}
			}
		}

		#endregion

		#region Logging Helpers

		public void LogError(string message, string information = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			if (string.IsNullOrWhiteSpace(information))
			{
				Log(message, LogLevel.Error, callingFunction: callingFunction, callingLineNumber: callingLineNumber);
			}
			else
			{
				Log(new LogEntry(message, LogLevel.Error, string.Empty, string.Empty, information),
					callingFunction: callingFunction, callingLineNumber: callingLineNumber);
			}
		}

		public void LogError(Exception exception, IExecutionContext context = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			if (context == null)
			{
				Log(exception, callingFunction: callingFunction, callingLineNumber: callingLineNumber);
			}
			else
			{
				Log(exception, context, callingFunction: callingFunction, callingLineNumber: callingLineNumber);
			}
		}

		public void LogWarning(string message, string information = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			if (string.IsNullOrWhiteSpace(information))
			{
				Log(message, LogLevel.Warning, callingFunction: callingFunction, callingLineNumber: callingLineNumber);
			}
			else
			{
				Log(new LogEntry(message, LogLevel.Warning, string.Empty, string.Empty, information),
					callingFunction: callingFunction, callingLineNumber: callingLineNumber);
			}
		}

		public void LogInfo(string message, string information = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			if (string.IsNullOrWhiteSpace(information))
			{
				Log(message, callingFunction: callingFunction, callingLineNumber: callingLineNumber);
			}
			else
			{
				Log(new LogEntry(message, LogLevel.Info, string.Empty, string.Empty, information),
					callingFunction: callingFunction, callingLineNumber: callingLineNumber);
			}
		}

		public void LogDebug(string message, string information = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			if (string.IsNullOrWhiteSpace(information))
			{
				Log(message, LogLevel.Debug, callingFunction: callingFunction, callingLineNumber: callingLineNumber);
			}
			else
			{
				Log(new LogEntry(message, LogLevel.Debug, string.Empty, string.Empty, information),
					callingFunction: callingFunction, callingLineNumber: callingLineNumber);
			}
		}

		#endregion

		#region Logging

		/// <summary>
		///     Logs an entry.
		/// </summary>
		/// <param name="message">The message to set in the log entry</param>
		/// <param name="level">[Optional] The logging level, above which, this entry will be skipped</param>
		/// <param name="regardingType">[Optional] The logical name of the entity concerned with this log entry as a string</param>
		/// <param name="regardingName">[Optional] The name of the record concerned with this log entry as a string</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void Log(string message, LogLevel level = LogLevel.Info, string regardingType = "",
			string regardingName = "", IExecutionContext context = null,
			string callingClass = null, string stackTrace = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			Log(new LogEntry(message, level), regardingType, regardingName, context,
				callingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
				stackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"), null, false,
				callingFunction, callingLineNumber);
		}

		/// <summary>
		///     Logs an exception.
		/// </summary>
		/// <param name="exception">The exception that was thrown</param>
		/// <param name="regardingType">[Optional] The logical name of the entity concerned with this log entry as a string</param>
		/// <param name="regardingName">[Optional] The name of the record concerned with this log entry as a string</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void Log(Exception exception, IExecutionContext context, string regardingType = "",
			string regardingName = "", string callingClass = null, string stackTrace = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			Log(new LogEntry(exception, exception.Message), regardingType, regardingName, context,
				callingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
				stackTrace ?? exception.StackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"), null, false,
				callingFunction, callingLineNumber);
		}

		/// <summary>
		///     Logs an exception.
		/// </summary>
		/// <param name="exception">The exception that was thrown</param>
		/// <param name="regardingType">[Optional] The logical name of the entity concerned with this log entry as a string</param>
		/// <param name="regardingName">[Optional] The name of the record concerned with this log entry as a string</param>
		/// <param name="information">
		///     [Optional] Extra information to add to the log entry (in this case, it should be the context
		///     parse)
		/// </param>
		public void Log(Exception exception, string regardingType = "", string regardingName = "", string information = "",
			string callingClass = null, string stackTrace = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			Log(new LogEntry(exception, exception.Message, information: information), regardingType, regardingName,
				callingClass: callingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
				stackTrace: stackTrace ?? exception.StackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"),
				callingFunction: callingFunction, callingLineNumber: callingLineNumber);
		}

		/// <summary>
		///     Logs an entry.
		/// </summary>
		/// <param name="logEntry">The log entry object that includes all relevant information</param>
		/// <param name="regardingType">[Optional] The logical name of the entity concerned with this log entry as a string</param>
		/// <param name="regardingName">[Optional] The name of the record concerned with this log entry as a string</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void Log(LogEntry logEntry, string regardingType = "", string regardingName = "",
			IExecutionContext context = null, string callingClass = null, string stackTrace = null, int? elapsedTime = null,
			bool parent = false, [CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			if (MaxLogLevel == LogLevel.None)
			{
				return;
			}

			try
			{
				if (!ExecutionStarted)
				{
					LogExecutionStart(callingClass: callingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
						stackTrace: stackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"),
						callingFunction: callingFunction, callingLineNumber: callingLineNumber);
				}

				// set parent of this entry to top of the stack entry
				if (!parent)
				{
					logEntry.Require(nameof(logEntry));
					logEntry.ParentLogEntry = execSeqStack.Peek();
				}

				// calculate the duration between the last log entry in this function and this one
				if (elapsedTime == null)
				{
					// get the last recorded duration since function start
					var lastDuration = durationsStack.Pop();

					// get the function timer
					var functionDuration
						= (int)(functionTimersStack.Any()
							? functionTimersStack.Peek().ElapsedMilliseconds
							: executionTimer.ElapsedMilliseconds);

					// add a snapshot
					durationsStack.Push(functionDuration);

					// calculate the time it took to get from the last recorded entry to this entry
					logEntry.ElapsedTime = functionDuration - lastDuration;
				}
				else
				{
					logEntry.ElapsedTime = elapsedTime.Value;
				}

				logEntry.StartDate = DateTime.UtcNow.AddMilliseconds(-logEntry.ElapsedTime);

				logEntry.RegardingType = regardingType ?? logEntry.RegardingType;
				logEntry.RegardingName = regardingName ?? logEntry.RegardingName;

				// exception flag
				if (logEntry.Exception != null)
				{
					exceptionThrown = true;
					logEntry.ExceptionThrown = true;
				}

				if (logEntry.ExceptionThrown)
				{
					var logEntryTemp = logEntry;

					while ((logEntryTemp = logEntryTemp.ParentLogEntry) != null)
					{
						logEntryTemp.ExceptionThrown = true;
					}
				}

				// plugin context
				if (context != null && OrganizationService != null)
				{
					var pluginInfo = PluginInfo.GetPluginExecutionInfo(OrganizationService, context);

					if ((logModes & ~LogModeInternal.TraceService) == 0)
					{
						logQueue.Peek().Information = pluginInfo;
					}
					else
					{
						logEntry.Information = pluginInfo;
					}
				}

				// increment the log entries index
				logEntry.CurrentEntryIndex = CurrentEntryIndex++;

				// code info
				logEntry.StackTrace = stackTrace ?? logEntry.StackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog");
				logEntry.CallingClass = callingClass ?? logEntry.CallingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog");
				logEntry.CallingFunction = callingFunction ?? logEntry.CallingFunction;
				logEntry.CallingLineNumber = callingLineNumber;

				logQueue.Enqueue(logEntry);
				OnLogEntryAdded(new LogEntryAddedEventArgs { LogEntry = logEntry });

				// keep the first entry with an exception to show in root
				exceptionLogEntry = logEntry.ExceptionThrown ? logEntry : exceptionLogEntry;

				if (IsAutoLogToConsole)
				{
					LogToConsole(logEntry);
				}
			}
			catch
			{
				if (context != null && OrganizationService != null)
				{
					throw;
				}
			}
		}

		private void OnLogEntryAdded(LogEntryAddedEventArgs e)
		{
			LogEntryAdded?.Invoke(this, e);
		}

		public void LogKeyValues(string title, string[] paramNames, object[] paramValues,
			LogLevel level = LogLevel.Info, string regardingType = "",
			string regardingName = "", IExecutionContext context = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			try
			{
				paramNames.Require(nameof(paramNames));
				paramValues.Require(nameof(paramValues));

				var paramInfoBuilder = new StringBuilder();

				for (var i = 0; i < paramNames.Length; i++)
				{
					if (i != 0)
					{
						paramInfoBuilder.Append("\r\n");
					}

					paramInfoBuilder
						.Append(paramNames[i])
						.Append(" = ")
						.Append(Helpers.GetStringRepresentation(paramValues[i]));
				}

				Log(new LogEntry(title, level, null, null, paramInfoBuilder.ToString()),
					regardingType, regardingName, context,
					Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"), Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"),
					null, false, callingFunction, callingLineNumber);
			}
			catch
			{
				if (context != null && OrganizationService != null)
				{
					throw;
				}
			}
		}

		public void LogKeyValues(string title, IDictionary<string, object> parameters,
			LogLevel level = LogLevel.Info, string regardingType = "",
			string regardingName = "", IExecutionContext context = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			parameters.Require(nameof(parameters));
			LogKeyValues(title, parameters.Keys.ToArray(), parameters.Values.ToArray(),
				level, regardingType, regardingName, context, callingFunction, callingLineNumber);
		}

		/// <summary>
		///     Logs the current execution line in the code.
		/// </summary>
		/// <param name="message">[OPTIONAL] The message to set in the log entry</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void LogLine(string message = null, IExecutionContext context = null,
			string callingClass = null, string stackTrace = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			if (MaxLogLevel == LogLevel.None)
			{
				return;
			}

			try
			{
				if (!ExecutionStarted)
				{
					LogExecutionStart(callingClass: callingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
						stackTrace: stackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"),
						callingFunction: callingFunction, callingLineNumber: callingLineNumber);
				}

				var defaultMessage = "Execution reached line " + callingLineNumber;

				var logEntry = new LogEntry(message ?? defaultMessage) { Level = LogLevel.Debug };

				Log(logEntry, string.Empty, string.Empty, context, callingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
					stackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"), -1,
					false, callingFunction, callingLineNumber);
			}
			catch
			{
				if (context != null && OrganizationService != null)
				{
					throw;
				}
			}
		}

		/// <summary>
		///     Formats the message with colouring and timestamp, and outputs to console if available.
		/// </summary>
		/// <param name="message">The message to output to console.</param>
		/// <param name="logLevel">Log level to use for formatting. Default is 'Info'.</param>
		public void LogToConsole(string message, LogLevel logLevel = LogLevel.Info)
		{
			LogToConsole(new LogEntry(message, logLevel));
		}

		/// <summary>
		///     Formats the log entry with colouring and timestamp, and outputs to console if available.
		/// </summary>
		/// <param name="logEntry">The log entry object that includes all relevant information.</param>
		public void LogToConsole(LogEntry logEntry)
		{
			logEntry.Require(nameof(logEntry));

			try
			{
				if (!logModes.HasFlag(LogModeInternal.Console) || logEntry.Level > MaxConsoleLogLevel)
				{
					return;
				}

				if (logEntry.ExceptionThrown)
				{
					Console.ForegroundColor = ConsoleColor.Red;
					Console.WriteLine("============================ !! EXCEPTION !! ===============================");
					Console.ResetColor();
					Console.WriteLine(GetFormattedEntry(logEntry));
					Console.ForegroundColor = ConsoleColor.Red;
					Console.WriteLine("============================================================================");
					Console.ResetColor();
				}
				else
				{
					Console.ForegroundColor = ConsoleColor.DarkGreen;
					Console.Write("{0:ddd hh:mm:ss tt: }", DateTime.Now);

					switch (logEntry.Level)
					{
						case LogLevel.Error:
							Console.BackgroundColor = ConsoleColor.White;
							Console.ForegroundColor = ConsoleColor.Red;
							break;
						case LogLevel.Warning:
							Console.ForegroundColor = ConsoleColor.Yellow;
							break;
						case LogLevel.Debug:
							Console.ForegroundColor = ConsoleColor.DarkCyan;
							break;
						default:
							Console.ResetColor();
							break;
					}

					Console.WriteLine(logEntry.Message);
					Console.ResetColor();

					if (logEntry.Information.IsFilled())
					{
						Console.WriteLine(logEntry.Information);
					}
				}
			}
			catch (Exception)
			{
				// ignored
			}
		}

		/// <summary>
		///     Sets the state at which the execution ended
		/// </summary>
		/// <param name="state">The state at which the execution ended</param>
		public void SetExecutionState(ExecutionEndState state)
		{
			AssemblyExecutionState = state;
		}

		/// <summary>
		///     Sets the state at which the execution ended as a failure
		/// </summary>
		public void ExecutionFailed()
		{
			AssemblyExecutionState = ExecutionEndState.Failure;
		}

		/// <summary>
		///     Created the parent log, and creates each log entry in the queue.
		/// </summary>
		/// <param name="inBulk">If true, created all log entries using ExecuteMultiple</param>
		public void Flush(bool inBulk = true)
		{
			var lockObject = this;

			Action action =
				() =>
				{
					lock (lockObject)
					{
						if (MaxLogLevel == LogLevel.None
							|| logQueue.All(entry => entry.Level == LogLevel.None)
							|| (logQueue.All(entry => entry.Level == LogLevel.None || entry.Level > MaxLogLevel)
								&& AssemblyExecutionState != ExecutionEndState.Failure))
						{
							return;
						}

						RunFlushAction(inBulk);
					}
				};

			if (isPlugin || logModes.HasFlag(LogModeInternal.File))
			{
				action.Invoke();
			}
			else
			{
				Task.Factory.StartNew(() => action(), TaskCreationOptions.LongRunning).Wait();
			}
		}

		#endregion

		private static string EscapeCsv(string input)
		{
			if (string.IsNullOrWhiteSpace(input))
			{
				return input;
			}
			
			return "\"" + input.Replace("\"", "\"\"") + "\"";
		}

		private static string BuildLogId(LogEntry logEntry)
		{
			return $"LogEntry-{logEntry.StartDate?.ToLocalTime() ?? DateTime.Now:yyyy_MM_dd-HH_mm_ss_fff}";
		}

		#region Flush

		private void RunFlushAction(bool inBulk)
		{
			try
			{
				var isCrmLog = logModes.HasFlag(LogModeInternal.CrmLog);

				parentLog["ldv_executionendstate"] = new OptionSetValue((int)AssemblyExecutionState);
				parentLog["ldv_executionduration"] = (int)executionTimer.ElapsedMilliseconds;
				parentLog["ldv_exceptionthrown"] = exceptionThrown;

				if (logModes.HasFlag(LogModeInternal.File))
				{
					offlineQueue = new Queue<LogEntry>(logQueue);
				}

				if ((logModes & ~LogModeInternal.File) == 0 || isBulkPreviously == true)
				{
					logQueue.Clear();
					return;
				}

				var requests = new List<OrganizationRequest>();
				var serialisedLogEntries = new StringBuilder();

				inBulk = isBulkPreviously == null && inBulk;

				if (isCrmLog && !inBulk && !isParentCreated)
				{
					OrganizationService.Create(parentLog);
				}

				var traceServiceBuffer = new StringBuilder();

				while (logQueue.Count > 0)
				{
					var logEntry = logQueue.Dequeue();

					// if the log entry's level is above the maximum, then no need to log it
					// unless the execution failed
					if (logEntry.Level > MaxLogLevel
						&& AssemblyExecutionState != ExecutionEndState.Failure)
					{
						continue;
					}
					
					if (logModes.HasFlag(LogModeInternal.TraceService)
						&& !new [] {"Started: ", "Finished: "}.Any(e => logEntry.Message.StartsWith(e)))
					{
						traceServiceBuffer.Append($"\r\n{GetTraceServiceFormattedEntry(logEntry)}");
					}

					var target = CreateEntryEntity(logEntry);

					if (isCrmLog)
					{
						if (inBulk)
						{
							serialisedLogEntries.Append("<|||>")
								.Append(EntitySerializer.SerializeObject(target));
						}
						else
						{
							OrganizationService.Create(target);
						}
					}
				}

				if (traceServiceBuffer.Length > 0)
				{
					TraceService.Trace(traceServiceBuffer.ToString());
				}

				if (isCrmLog)
				{
					if (exceptionLogEntry != null)
					{
						var updatedParent =
							new Entity("ldv_log")
							{
								Id = parentLog.Id,
								["ldv_exceptionlogentry"] =
									new EntityReference("ldv_logentry", exceptionLogEntry.LogEntryId),
								["ldv_exceptionmessage"] = exceptionLogEntry.Message
							};

						if (inBulk)
						{
							serialisedLogEntries.Append("<|||><PARENT>")
								.Append(EntitySerializer.SerializeObject(updatedParent));
						}
						else
						{
							OrganizationService.Update(updatedParent);
						}
					}

					if (inBulk)
					{
						parentLog["ldv_serialisedlogentries"] = serialisedLogEntries.ToString().Compress();
						requests.Add(new CreateRequest { Target = parentLog });
						CrmHelpers.ExecuteBulk(OrganizationService, requests);
					}
				}

				isParentCreated = true;
				isBulkPreviously = inBulk;
			}
			catch
			{
				try
				{
					if (IsFailOver)
					{
						FlushOffline();
					}
				}
				catch
				{
				}

				throw;
			}
			finally
			{
				if (!IsFailOver)
				{
					FlushOffline();
				}
			}
		}

		/// <summary>
		///     Flushes to local file.
		/// </summary>
		private void FlushOffline()
		{
			try
			{
				if (!logModes.HasFlag(LogModeInternal.File))
				{
					return;
				}

				PrepareLogPath();

				if (IsCreateFile())
				{
					CreateLogFile();
				}

				// open the log file and write the log entries
				using (var file = File.Open(OfflinePath, FileMode.Append, FileAccess.Write, FileShare.ReadWrite))
				using (var stream = new StreamWriter(file))
				{
					while (offlineQueue.Any())
					{
						var logEntry = offlineQueue.Dequeue();

						if (logEntry.Level > MaxLogLevel
							&& AssemblyExecutionState != ExecutionEndState.Failure)
						{
							continue;
						}
						
						stream.Write(GetFormattedCsvEntry(logEntry));
					}

					stream.Flush();
				}
			}
			catch
			{
				// ignored
			}
		}

		private bool IsCreateFile()
		{
			// if the file or config do not exist, create file
			if (!File.Exists(OfflinePath) || Config == null)
			{
				return true;
			}

			// check size and date limit for split
			var dateFile = Path.Combine(Path.GetDirectoryName(OfflinePath) ?? "",
				Path.GetFileNameWithoutExtension(OfflinePath) + ".dat");
			var dateText = File.Exists(dateFile)
				? File.ReadAllText(dateFile)
				: DateTime.UtcNow.ToString("yyyy-MM-dd_HH-mm-ss-fff");

			if (!File.Exists(dateFile))
			{
				File.WriteAllText(dateFile, DateTime.UtcNow.ToString("yyyy-MM-dd_HH-mm-ss-fff"));
			}

			var fileDate = DateTime.ParseExact(dateText, "yyyy-MM-dd_HH-mm-ss-fff", CultureInfo.InvariantCulture,
				DateTimeStyles.AssumeUniversal);

			var newFileDate = string.Format("{0:" + (Config.FileDateFormat ?? "yyyy-MM-dd_HH-mm-ss-fff") + "}",
				fileDate.ToLocalTime());
			var datedName = Path.Combine(Path.GetDirectoryName(OfflinePath) ?? "",
				$"{Path.GetFileNameWithoutExtension(OfflinePath)}_{newFileDate}{Path.GetExtension(OfflinePath)}");

			// option exists for size limit
			if ((Config.FileSplitMode == SplitMode.Size || Config.FileSplitMode == SplitMode.Both)
				&& Config.MaxFileSizeKb > 0 && new FileInfo(OfflinePath).Length / 1024 > Config.MaxFileSizeKb)
			{
				File.Move(OfflinePath, datedName);
				return true;
			}

			// option exists for date limit
			if ((Config.FileSplitMode == SplitMode.Date || Config.FileSplitMode == SplitMode.Both)
				&& Config.FileSplitFrequency != null)
			{
				var splitDate = Config.FileSplitDate;

				// calculate the target split date for the file based on its creation date
				switch (Config.FileSplitFrequency)
				{
					case SplitFrequency.Hourly:
						splitDate = new DateTime(fileDate.Year, fileDate.Month, fileDate.Day,
							fileDate.Hour, splitDate.Minute, splitDate.Second).AddHours(1);
						break;

					case SplitFrequency.Daily:
						splitDate = new DateTime(fileDate.Year, fileDate.Month, fileDate.Day,
							splitDate.Hour, splitDate.Minute, splitDate.Second).AddDays(1);
						break;

					case SplitFrequency.Monthly:
						splitDate = new DateTime(fileDate.Year, fileDate.Month, splitDate.Day,
							splitDate.Hour, splitDate.Minute, splitDate.Second).AddMonths(1);
						break;

					case SplitFrequency.Yearly:
						splitDate = new DateTime(fileDate.Year, splitDate.Month, splitDate.Day,
							splitDate.Hour, splitDate.Minute, splitDate.Second).AddYears(1);
						break;
				}

				// rename
				if (DateTime.UtcNow > splitDate)
				{
					File.Move(OfflinePath, datedName);
					return true;
				}
			}

			return false;
		}

		private void PrepareLogPath()
		{
			// no file name specified, create default name
			if (string.IsNullOrWhiteSpace(OfflinePath))
			{
				OfflinePath = $"C:\\Logs\\{Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common")}.csv";
			}

			// if directory was given, add filename to it
			if (!Path.HasExtension(OfflinePath))
			{
				OfflinePath = Path.Combine(OfflinePath, Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common") + ".csv");
			}

			var folder = Path.GetDirectoryName(OfflinePath);

			// if categorisation is needed, add the assembly folder
			if (Config != null && Config.CategoriseByType == true)
			{
				OfflinePath = Path.Combine(Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common"), Path.GetFileName(OfflinePath));

				if (!string.IsNullOrWhiteSpace(folder))
				{
					OfflinePath = Path.Combine(folder, OfflinePath);
				}
			}

			folder = Path.GetDirectoryName(OfflinePath);

			// create path if it doesn't exist
			if (!string.IsNullOrWhiteSpace(folder))
			{
				Directory.CreateDirectory(folder);
			}
		}

		/// <summary>
		///     Creates an entity containing the log entry data
		/// </summary>
		/// <param name="logEntry">The log entry.</param>
		/// <returns>The CRM entity object including all info in the log entry object</returns>
		private Entity CreateEntryEntity(LogEntry logEntry)
		{
			var target =
				new Entity("ldv_logentry")
				{
					Id = logEntry.LogEntryId,
					["ldv_name"] = BuildLogId(logEntry),
					["ldv_message"] = logEntry.Message,
					["ldv_entryindex"] = logEntry.CurrentEntryIndex,
					["ldv_startdate"] = logEntry.StartDate,
					["ldv_regardingtype"] = logEntry.RegardingType,
					["ldv_regardingname"] = logEntry.RegardingName,
					["ldv_stacktrace"] = logEntry.StackTrace
				};

			if (logEntry.Exception != null)
			{
				if (string.IsNullOrWhiteSpace(logEntry.Message))
				{
					target["ldv_message"] = logEntry.Message = "Exception: " + logEntry.Exception.Message;
				}

				target["ldv_exception"] = logEntry.Exception.GetType().Name;
				target["ldv_exceptionsource"] = logEntry.Exception.Source;
				target["ldv_stacktrace"] = logEntry.Exception.StackTrace;

				if (logEntry.Exception.InnerException != null)
				{
					target["ldv_innerexception"] = logEntry.Exception.InnerException.GetType().Name;
					target["ldv_innerexceptionmessage"] = logEntry.Exception.InnerException.Message;
					target["ldv_innerexceptionsource"] = logEntry.Exception.InnerException.Source;
					target["ldv_innerexceptionstacktrace"] = logEntry.Exception.InnerException.StackTrace;
				}
			}

			target["ldv_exceptionthrown"] = logEntry.ExceptionThrown;

			target["ldv_level"] = new OptionSetValue((int)logEntry.Level);

			if (logEntry.UserId != Guid.Empty)
			{
				target["ldv_user"] = new EntityReference("systemuser", logEntry.UserId);
			}
			else if (UserId != Guid.Empty)
			{
				target["ldv_user"] = new EntityReference("systemuser", UserId);
			}

			target["ldv_assembly"] = logEntry.Assembly ?? Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common");
			target["ldv_class"] = logEntry.CallingClass;
			target["ldv_callingfunction"] = logEntry.CallingFunction;
			target["ldv_linenumber"] = logEntry.CallingLineNumber;

			if (logEntry.ElapsedTime > -1)
			{
				target["ldv_executionduration"] = logEntry.ElapsedTime;
			}

			target["ldv_information"] = logEntry.Information;

			target["ldv_parentlogid"] = parentLog.ToEntityReference();

			if (logEntry.ParentLogEntry != null)
			{
				target["ldv_parentlogentryid"] = new EntityReference("ldv_logentry", logEntry.ParentLogEntry.LogEntryId);
			}

			return target;
		}

		private void CreateLogFile()
		{
			File.Create(OfflinePath).Close();

			var data = Encoding.UTF8.GetBytes("Log ID,Assembly,Entry Class,Entry Function,Date,Index," +
				"Log Level,Duration (ms),Class,Function,Line Number,Message,Exception Thrown," +
				"Exception,Source,Stack Trace,Inner Exception,Inner Source,Information," +
				"Log Start Date,Execution State,Execution Duration," +
				"Regarding Type,Regarding Name,Regarding ID,User ID\r\n");
			var bytes = Encoding.UTF8.GetPreamble().Concat(data).ToArray();
			File.WriteAllBytes(OfflinePath, bytes);

			var dateFile = Path.Combine(Path.GetDirectoryName(OfflinePath) ?? "",
				Path.GetFileNameWithoutExtension(OfflinePath) + ".dat");
			File.WriteAllText(dateFile, DateTime.UtcNow.ToString("yyyy-MM-dd_HH-mm-ss-fff"));
		}

		private string GetFormattedEntry(LogEntry logEntry, bool isExcludeTrace = false)
		{
			try
			{
				var stringBuilder = new StringBuilder();

				stringBuilder.AppendFormat("\r\nStart date: {0}", logEntry.StartDate.GetValueOrDefault().ToLocalTime());
				stringBuilder.AppendFormat("\r\nLog level: {0}", logEntry.Level);
				stringBuilder.AppendFormat("\r\nDuration: {0} ms", logEntry.ElapsedTime);
				stringBuilder.AppendFormat("\r\nAssembly: {0}",
					logEntry.Assembly ?? Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common"));
				stringBuilder.AppendFormat("\r\nClass: {0}", logEntry.CallingClass);
				stringBuilder.AppendFormat("\r\nCalling function: {0}", logEntry.CallingFunction);
				stringBuilder.AppendFormat("\r\nLine number: {0}", logEntry.CallingLineNumber);

				if (logEntry.Exception == null)
				{
					stringBuilder.AppendFormat("\r\nMessage: {0}", logEntry.Message);

					if (!isExcludeTrace)
					{
						stringBuilder.AppendFormat("\r\nStack trace: {0}", logEntry.StackTrace);
					}
				}
				else
				{
					stringBuilder.Append($"\r\n--- START ** EXCEPTION ---"
						+ $"\r\n{logEntry.Exception.BuildExceptionMessage()}"
						+ $"\r\n--- EXCEPTION ** END ---");
				}

				if (logEntry.Information.IsFilled())
				{
					stringBuilder.AppendFormat("\r\nInformation:\r\n{0}", logEntry.Information);
				}

				return stringBuilder.ToString();
			}
			catch (Exception e)
			{
				return $"Logger error:\r\n{e}";
			}
		}

		private string GetTraceServiceFormattedEntry(LogEntry logEntry)
		{
			try
			{
				var stringBuilder = new StringBuilder();

				if (logEntry.Message.StartsWith("Started execution: "))
				{
					stringBuilder.Append($"{logEntry.StartDate.GetValueOrDefault().ToLocalTime()}: ");
				}

				////stringBuilder.Append($"Start date: {logEntry.StartDate.GetValueOrDefault().ToLocalTime()}");
				////stringBuilder.AppendFormat("\r\nLog level: {0}", logEntry.Level);
				////stringBuilder.AppendFormat("\r\nDuration: {0} ms", logEntry.ElapsedTime);
				////stringBuilder.AppendFormat("\r\nClass: {0}", logEntry.CallingClass.Split('.').LastOrDefault());
				////stringBuilder.AppendFormat("\r\nMethod: {0}", logEntry.CallingFunction);
				////stringBuilder.AppendFormat("\r\nLine: {0}", logEntry.CallingLineNumber);

				if (logEntry.Exception == null)
				{
					if (logEntry.Level != LogLevel.Info)
					{
						stringBuilder.Append($"[{logEntry.Level}] ");
					}

					stringBuilder.Append($"{logEntry.Message}"
						+ $" | {logEntry.ElapsedTime} ms"
						+ $" | {logEntry.CallingClass?.Split('.').LastOrDefault()}"
						+ $".{logEntry.CallingFunction} at {logEntry.CallingLineNumber}");
				}
				else
				{
					stringBuilder.Append($"\r\n-- START ** EXCEPTION -"
						+ $"\r\n{logEntry.Exception.BuildExceptionMessage()}"
						+ $"\r\n-- END ** EXCEPTION -");
				}

				if (logEntry.Message.StartsWith("Started execution: ") && logEntry.Information.IsFilled())
				{
					stringBuilder.Append($"\r\nInformation:\r\n{logEntry.Information}");
				}

				return stringBuilder.ToString();
			}
			catch (Exception e)
			{
				return $"Logger error:\r\n{e}";
			}
		}

		private string GetFormattedCsvEntry(LogEntry logEntry)
		{
			var stringBuilder = new StringBuilder();

			stringBuilder.AppendFormat("{0}", parentLog.GetAttributeValue<string>("ldv_name"));
			stringBuilder.AppendFormat(",{0}",
				EscapeCsv(logEntry.Assembly ?? Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common")));
			stringBuilder.AppendFormat(",{0}", EscapeCsv(parentLog.GetAttributeValue<string>("ldv_entryclass")));
			stringBuilder.AppendFormat(",{0}", EscapeCsv(parentLog.GetAttributeValue<string>("ldv_entryfunction")));
			stringBuilder.AppendFormat(",{0}", logEntry.StartDate.GetValueOrDefault().ToLocalTime());
			stringBuilder.AppendFormat(",{0}", logEntry.CurrentEntryIndex);
			stringBuilder.AppendFormat(",{0}", logEntry.Level);
			stringBuilder.AppendFormat(",{0}", EscapeCsv(logEntry.ElapsedTime.ToString()));
			stringBuilder.AppendFormat(",{0}", EscapeCsv(logEntry.CallingClass));
			stringBuilder.AppendFormat(",{0}", EscapeCsv(logEntry.CallingFunction));
			stringBuilder.AppendFormat(",{0}", logEntry.CallingLineNumber);

			if (logEntry.Exception != null)
			{
				stringBuilder.AppendFormat(",{0}",
					string.IsNullOrWhiteSpace(logEntry.Message)
						? EscapeCsv(logEntry.Exception.Message)
						: EscapeCsv(logEntry.Message));

				stringBuilder.AppendFormat(",{0}", logEntry.ExceptionThrown);
				stringBuilder.AppendFormat(",{0},{1},{2}",
					EscapeCsv(logEntry.Exception.GetType().Name),
					EscapeCsv(logEntry.Exception.Source), EscapeCsv(logEntry.Exception.StackTrace));

				if (logEntry.Exception.InnerException != null)
				{
					stringBuilder.AppendFormat(",{0},{1}",
						EscapeCsv(logEntry.Exception.InnerException.GetType().Name),
						EscapeCsv(logEntry.Exception.InnerException.Message));
				}
				else
				{
					stringBuilder.Append(",,");
				}
			}
			else
			{
				stringBuilder.AppendFormat(",{0},{1},,,,,", EscapeCsv(logEntry.Message), logEntry.ExceptionThrown);
			}

			stringBuilder.AppendFormat(",{0}", EscapeCsv(logEntry.Information));

			stringBuilder.AppendFormat(",{0}", LogStartDate);
			stringBuilder.AppendFormat(",{0}", AssemblyExecutionState);
			stringBuilder.AppendFormat(",{0}", parentLog.GetAttributeValue<int>("ldv_executionduration"));
			stringBuilder.AppendFormat(",{0}", EscapeCsv(logEntry.RegardingType));
			stringBuilder.AppendFormat(",{0}", EscapeCsv(logEntry.RegardingName));
			stringBuilder.AppendFormat(",{0}", parentLog.GetAttributeValue<string>("ldv_regardingid"));
			stringBuilder.AppendFormat(",{0}\r\n", logEntry.UserId == Guid.Empty ? UserId : logEntry.UserId);

			return stringBuilder.ToString();
		}

		#endregion

		#region Init

		private PrivateConfiguration GetConfiguration()
		{
			if (OrganizationService == null)
			{
				return null;
			}

			var config = CrmHelpers.GetGenericConfig(OrganizationService, orgId);

			return config == null
				? null
				: new PrivateConfiguration
				  {
					  LogLevel = (LogLevel)(config.GetAttributeValue<OptionSetValue>("ldv_loglevel")
						  ?? new OptionSetValue((int)LogLevel.Warning)).Value,
					  LogMode = (LogMode)(config.GetAttributeValue<OptionSetValue>("ldv_logmode")
						  ?? new OptionSetValue((int)LogMode.Crm)).Value,
					  LogPath = config.GetAttributeValue<string>("ldv_logpath"),
					  MaxFileSizeKb = config.GetAttributeValue<int?>("ldv_maxfilesize"),
					  FileDateFormat = config.GetAttributeValue<string>("ldv_logfiledateformat"),
					  FileSplitMode = config.GetAttributeValue<OptionSetValue>("ldv_logfilesplitmode") == null
						  ? null
						  : (SplitMode?)config.GetAttributeValue<OptionSetValue>("ldv_logfilesplitmode").Value,
					  FileSplitFrequency = config.GetAttributeValue<OptionSetValue>("ldv_logfilesplitfrequency") == null
						  ? null
						  : (SplitFrequency?)config.GetAttributeValue<OptionSetValue>("ldv_logfilesplitfrequency").Value,
					  FileSplitDate = config.GetAttributeValue<DateTime>("ldv_logfilesplitdate"),
					  CategoriseByType = config.GetAttributeValue<bool?>("ldv_iscategorisebytype"),
					  AssemblyFilter = config.GetAttributeValue<string>("ldv_assemblyfilter"),
					  AssemblyExclusion = config.GetAttributeValue<string>("ldv_assemblyexclusion")
				  };
		}

		/// <summary>
		///     Initialises the CRM logger.
		/// </summary>
		/// <param name="organizationService">The service to be used to flush the entries to CRM</param>
		/// <param name="traceService">The Plugin Trace service to log entries to CRM</param>
		/// <param name="maximumLevel">[OPTIONAL] The maximum logging level to use, above which, no logs will be saved</param>
		private void InitialiseLog(IOrganizationService organizationService, ITracingService traceService = null,
			LogLevel? maximumLevel = null, [CallerMemberName] string callingFunction = "")
		{
			logQueue = new Queue<LogEntry>();
			offlineQueue = new Queue<LogEntry>();
			execSeqStack = new Stack<LogEntry>();

			functionTimersStack = new Stack<Stopwatch>();
			durationsStack = new Stack<int>();

			OrganizationService = organizationService;

			if (traceService != null)
			{
				InitTraceServiceLog(traceService);
			}

			LogStartDate = DateTime.UtcNow;
			CurrentEntryIndex = 1;

			PrivateConfiguration config = null;

			if (logModes.HasFlag(LogModeInternal.CrmLog) || logModes.HasFlag(LogModeInternal.TraceService))
			{
				config = GetConfiguration();
			}

			MaxLogLevel = maximumLevel ?? config?.LogLevel ?? LogLevel.Warning;

			// if assembly is excluded, then turn off logging
			if (!string.IsNullOrWhiteSpace(config?.AssemblyFilter))
			{
				var isAssemblyIncluded =
					Regex.IsMatch(Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common"), config.AssemblyFilter);
				MaxLogLevel = isAssemblyIncluded ? MaxLogLevel : LogLevel.None;
			}

			if (!string.IsNullOrWhiteSpace(config?.AssemblyExclusion))
			{
				var isAssemblyExcluded =
					Regex.IsMatch(Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common"), config.AssemblyExclusion);
				MaxLogLevel = isAssemblyExcluded ? LogLevel.None : MaxLogLevel;
			}

			if (isSandboxMode && logModes.HasFlag(LogModeInternal.File))
			{
				logModes &= ~LogModeInternal.File;
			}

			if (logModes.HasFlag(LogModeInternal.File))
			{
				InitOfflineLog(config == null ? string.Empty : config.LogPath, false, config);
			}

			if (UserId == Guid.Empty && OrganizationService != null && MaxLogLevel != LogLevel.None)
			{
				UserId = ((WhoAmIResponse)OrganizationService.Execute(new WhoAmIRequest())).UserId;
			}

			InitLogEntity(callingFunction);
		}

		/// <summary>
		///     Initializes the parent log entity.
		/// </summary>
		private void InitLogEntity([CallerMemberName] string callingFunction = "")
		{
			parentLog =
				new Entity("ldv_log")
				{
					Id = Guid.NewGuid(),
					["ldv_name"] = $"Log-{LogStartDate.ToLocalTime():yyyy_MM_dd-HH_mm_ss_fff}",
					["ldv_assembly"] = Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common"),
					["ldv_entryclass"] = Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
					["ldv_entryfunction"] = callingFunction,
					["ldv_startdate"] = LogStartDate,
					["ldv_user"] = new EntityReference("systemuser", UserId),
					["ldv_executionendstate"] = new OptionSetValue((int)ExecutionEndState.Success)
				};
		}

		#endregion

		#region Inner classes

		private class PrivateConfiguration : FileConfiguration
		{
			internal LogLevel LogLevel
			{
				get; set;
			}

			internal LogMode LogMode
			{
				get; set;
			}

			internal string LogPath
			{
				get; set;
			}

			internal string AssemblyFilter
			{
				get; set;
			}

			internal string AssemblyExclusion
			{
				get; set;
			}
		}

		#endregion
	}

	public class LogEntryAddedEventArgs : EventArgs
	{
		public LogEntry LogEntry
		{
			get; set;
		}
	}

	public class FileConfiguration
	{
		public int? MaxFileSizeKb
		{
			get; set;
		}

		public string FileDateFormat
		{
			get; set;
		}

		public SplitMode? FileSplitMode
		{
			get; set;
		}

		public SplitFrequency? FileSplitFrequency
		{
			get; set;
		}

		public DateTime FileSplitDate
		{
			get; set;
		}

		public bool? CategoriseByType
		{
			get; set;
		}
	}

	/// <summary>
	///     Contains information related to the log entry.<br />
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public class LogEntry
	{
		private int elapsedTime;
		private int currentEntryIndex;

		#region Constructors

		public LogEntry(string message, LogLevel level = LogLevel.Info, string regardingType = "", string regardingName = "",
			string information = "") : this(message, null, level, regardingType, regardingName, information)
		{
		}

		public LogEntry(Exception exception, string message = "", string regardingType = "", string regardingName = "",
			string information = "", LogLevel level = LogLevel.Error)
			: this(message, exception, level, regardingType, regardingName, information)
		{
		}

		public LogEntry(string message, Exception exception, LogLevel level, string information)
			: this(message, exception, level, string.Empty, string.Empty, information)
		{
		}

		public LogEntry(string message, Exception exception, LogLevel level, string regardingType, string regardingName,
			string information)
		{
			Message = message;
			Level = level;
			Exception = exception;
			RegardingType = regardingType;
			RegardingName = regardingName;
			Information = information;
		}

		public LogEntry(string message, Exception exception, LogLevel level, string regardingType, string regardingName,
			string information, Guid userId) : this(message, exception, level, regardingType, regardingName, information)
		{
			UserId = userId;
		}

		#endregion

		#region Instance variables

		public Guid LogEntryId { get; } = Guid.NewGuid();

		public LogEntry ParentLogEntry
		{
			get; set;
		}

		public string Message
		{
			get; set;
		}

		public DateTime? StartDate
		{
			get; set;
		}

		public LogLevel Level
		{
			get; set;
		}

		public Guid UserId
		{
			get; set;
		}

		public string RegardingType
		{
			get; set;
		}

		public string RegardingName
		{
			get; set;
		}

		public Exception Exception
		{
			get; set;
		}

		public bool ExceptionThrown
		{
			get; set;
		}

		public string Assembly
		{
			get; set;
		}

		public string StackTrace
		{
			get; set;
		}

		public string CallingClass
		{
			get; set;
		}

		public string CallingFunction
		{
			get; set;
		}

		public int CallingLineNumber
		{
			get; set;
		}

		public string Information
		{
			get; set;
		}

		public int CurrentEntryIndex
		{
			get
			{
				return currentEntryIndex;
			}
			set
			{
				currentEntryIndex = value <= 0 ? 1 : value;
			}
		}

		public int ElapsedTime
		{
			get
			{
				return elapsedTime;
			}
			set
			{
				elapsedTime = elapsedTime < -1 ? -1 : value;
			}
		}

		#endregion
	}

	#endregion

	#region Plugin classes

	public enum PluginStage
	{
		All,
		PreValidation = 10,
		PreOperation = 20,
		PostOperation = 40
	}

	public enum PluginMode
	{
		Synchronous = 0,
		Asynchronous = 1,
		Both = 2
	}

	/// <summary>
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public interface IPluginContext
	{
		IPlugin Plugin { get; }
		CodeActivity CodeActivity { get; }

		IServiceProvider ServiceProvider { get; }
		CodeActivityContext ExecutionContext { get; }

		IExecutionContext Context { get; }
		IOrganizationServiceFactory ServiceFactory { get; }
		ITracingService TracingService { get; }
		IOrganizationService Service { get; }
		IOrganizationService EscalatedService { get; }

		string Message { get; }
		PluginStage Stage { get; }
		Guid UserId { get; }

		Guid EscalationUserId { get; }

		string Entity { get; }
		Guid Id { get; }

		CrmLog Log { get; }

		Entity PreImage { get; }
		Entity Target { get; }
		Entity PostImage { get; }
	}

	/// <summary>
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public abstract class PluginLogic<TPlugin> : IPluginContext
		where TPlugin : IPlugin
	{
		public virtual IPlugin Plugin => plugin;
		public virtual CodeActivity CodeActivity => throw new NotSupportedException("Not supported in IPlugins.");
		public virtual CodeActivityContext ExecutionContext => throw new NotSupportedException("Not supported in IPlugins.");

		public virtual IServiceProvider ServiceProvider
		{
			get
			{
				serviceProvider.Require(nameof(serviceProvider));
				return serviceProvider;
			}
		}

		public virtual IExecutionContext Context => context
			?? (context = (IPluginExecutionContext)ServiceProvider.GetService(typeof(IPluginExecutionContext)));
		public virtual IOrganizationServiceFactory ServiceFactory => serviceFactory
			?? (serviceFactory = (IOrganizationServiceFactory)ServiceProvider.GetService(typeof(IOrganizationServiceFactory)));
		public virtual ITracingService TracingService => tracingService
			?? (tracingService = (ITracingService)ServiceProvider.GetService(typeof(ITracingService)));

		public virtual IOrganizationService Service => service ?? (service = ServiceFactory.CreateOrganizationService(UserId));
		public virtual IOrganizationService EscalatedService => escalatedService
			?? (escalatedService = ServiceFactory.CreateOrganizationService(EscalationUserId));

		public virtual string Message => Context.MessageName;
		public virtual PluginStage Stage => (PluginStage)((IPluginExecutionContext)Context).Stage;
		public virtual Guid UserId => userId ?? Context.UserId;

		public virtual Guid EscalationUserId => escalationUserId
			?? (escalationUserId = CrmHelpers.GetGenericConfig(Service, Context.OrganizationId)
				.GetAttributeValue<EntityReference>("ys_escalationuserid")?.Id)
				?? throw new ArgumentNullException(nameof(EscalationUserId), "Escalation User is not set in Common Configuration.");

		public virtual string Entity => Context.PrimaryEntityName;
		public virtual Guid Id => Context.PrimaryEntityId;

		public virtual CrmLog Log => log;

		public virtual Entity PreImage => preImage ?? (preImage = GetPreImage<Entity>());
		public virtual Entity Target => target ?? (target = GetTarget<Entity>());
		public virtual Entity PostImage
		{
			get
			{
				try
				{
					return postImage ?? (postImage = GetPostImage<Entity>());
				}
				catch
				{
					try
					{
						return postImage ?? (postImage = BuildPostFromPreImage<Entity>());
					}
					catch
					{
						throw new InvalidPluginExecutionException("Missing a post-image for this step.");
					}
				}
			}
		}

		protected readonly string intendedPluginMessage;
		protected readonly PluginStage intendedPluginStage;
		protected readonly string intendedEntity;

		private TPlugin plugin;

		private IServiceProvider serviceProvider;
		private IPluginExecutionContext context;
		private IOrganizationServiceFactory serviceFactory;
		private ITracingService tracingService;
		private IOrganizationService service;
		private IOrganizationService escalatedService;

		private Guid? userId;
		private Guid? escalationUserId;

		private CrmLog log;

		private Entity preImage;
		private Entity target;
		private Entity postImage;

		protected PluginLogic(string intendedPluginMessage, PluginStage intendedPluginStage, string intendedEntity = null)
		{
			this.intendedPluginMessage = intendedPluginMessage;
			this.intendedPluginStage = intendedPluginStage;
			this.intendedEntity = intendedEntity;
		}

		public virtual void Execute(TPlugin plugin, IServiceProvider serviceProvider)
		{
			Execute(plugin, serviceProvider, PluginUser.System);
		}

		public virtual void Execute(TPlugin plugin, IServiceProvider serviceProvider, bool isLogEnabled)
		{
			Execute(plugin, serviceProvider, PluginUser.System, null, isLogEnabled);
		}

		public virtual void Execute(TPlugin plugin, IServiceProvider serviceProvider, Guid? userId,
			bool isLogEnabled = true)
		{
			Execute(plugin, serviceProvider, PluginUser.Custom, userId, isLogEnabled);
		}

		public virtual void Execute(TPlugin plugin, IServiceProvider serviceProvider, PluginUser user,
			bool isLogEnabled = true)
		{
			Execute(plugin, serviceProvider, user, null, isLogEnabled);
		}

		public virtual void Execute(TPlugin plugin, IServiceProvider serviceProvider, PluginUser user, Guid? userId,
			bool isLogEnabled = true)
		{
			this.plugin = plugin;
			this.serviceProvider = serviceProvider;
			this.userId = userId;

			InitialisePlugin(user);

			try
			{
				TracingService.Trace("Initialising log ...");
				log = new CrmLog(serviceProvider);
				TracingService.Trace("Finished initialising log.");

				if (isLogEnabled)
				{
					TracingService.Trace("Log is enabled in the code.");

					TracingService.Trace("Setting entry class in log ...");
					Log.SetEntryClass(typeof(TPlugin).FullName);

					TracingService.Trace("Checking regarding to be set in log ...");

					if (Context.PrimaryEntityName != null && Context.PrimaryEntityName != "none"
						&& Context.PrimaryEntityId != Guid.Empty)
					{
						TracingService.Trace("Setting regarding in log ...");
						Log.SetRegarding(Context.PrimaryEntityName, Context.PrimaryEntityId);
					}
				}
				else
				{
					TracingService.Trace("Log is disabled in the code.");
				}
			}
			catch (Exception ex)
			{
				throw new InvalidPluginExecutionException("Failed to init log => " + ex.Message, ex);
			}

			try
			{
				if (isLogEnabled)
				{
					TracingService.Trace("Logging execution start ...");
					Log.LogExecutionStart();
				}

				TracingService.Trace("Executing plugin logic ...");
				ExecuteLogic();
				TracingService.Trace("Finished executing plugin logic.");
			}
			catch (Exception ex)
			{
				TracingService.Trace($"Exception occurred: {ex.Message}.");
				TracingService.Trace("Logging exception ...");

				if (isLogEnabled)
				{
					Log.ExecutionFailed();
					Log.Log(ex, Context);
				}
				else
				{
					TracingService.Trace(ex.ToString());
					TracingService.Trace(CrmHelpers.BuildExceptionMessage(ex));
				}

				throw new InvalidPluginExecutionException(ex.Message, ex);
			}
			finally
			{
				if (isLogEnabled)
				{
					TracingService.Trace("Logging execution end ...");

					try
					{
						Log.LogExecutionEnd();
					}
					catch (Exception e)
					{
						TracingService.Trace(e.ToString());
						TracingService.Trace(CrmHelpers.BuildExceptionMessage(e));
						throw;
					}
				}

				TracingService.Trace("Finished executing plugin.");
			}
		}

		protected abstract void ExecuteLogic();

		protected TEntity GetPreImage<TEntity>() where TEntity : Entity
		{
			var image = Context.PreEntityImages.FirstOrDefault().Value;

			if (image == null)
			{
				throw new InvalidPluginExecutionException("Missing a pre-image for this step.");
			}

			return image.ToEntity<TEntity>();
		}

		protected TEntity GetTarget<TEntity>() where TEntity : Entity
		{
			if (Context.InputParameters.TryGetValue("Target", out var target) && target is Entity targetEntity)
			{
				return targetEntity.ToEntity<TEntity>();
			}

			throw new InvalidPluginExecutionException("Missing Target in the plugin input, or not of type Entity.");
		}

		protected EntityReference GetTargetReference()
		{
			if (Context.InputParameters.TryGetValue("Target", out var target) && target is EntityReference targetEntityRef)
			{
				return targetEntityRef;
			}

			throw new InvalidPluginExecutionException("Missing Target in the plugin input, or not of type EntityReference.");
		}

		protected TEntity BuildPostFromPreImage<TEntity>() where TEntity : Entity
		{
			var preImage = GetPreImage<TEntity>();
			var target = GetTarget<TEntity>();
			var postImage = new Entity(target.LogicalName, target.Id);

			foreach (var pair in preImage.Attributes)
			{
				postImage[pair.Key] = pair.Value;
			}

			foreach (var pair in preImage.FormattedValues)
			{
				postImage.FormattedValues[pair.Key] = pair.Value;
			}

			foreach (var pair in target.Attributes)
			{
				postImage[pair.Key] = pair.Value;
			}

			foreach (var pair in target.FormattedValues)
			{
				postImage.FormattedValues[pair.Key] = pair.Value;
			}

			return postImage.ToEntity<TEntity>();
		}

		protected TEntity GetPostImage<TEntity>() where TEntity : Entity
		{
			var image = Context.PostEntityImages.FirstOrDefault().Value;

			if (image == null)
			{
				throw new InvalidPluginExecutionException("Missing a post-image for this step.");
			}

			return image.ToEntity<TEntity>();
		}

		protected virtual bool IsContextValid()
		{
			return true;
		}

		protected virtual void ValidateRegistration()
		{
			if (!string.IsNullOrWhiteSpace(intendedEntity) && Context.PrimaryEntityName != intendedEntity)
			{
				throw new InvalidPluginExecutionException(
					$"Step registered on wrong entity: {Context.PrimaryEntityName}, "
						+ $"expected: {intendedEntity}");
			}

			if (!string.IsNullOrWhiteSpace(intendedPluginMessage) && Context.MessageName != intendedPluginMessage)
			{
				throw new InvalidPluginExecutionException(
					$"Step registered on wrong message: {Context.MessageName}, "
						+ $"expected: {intendedPluginMessage}.");
			}

			var pluginContext = (IPluginExecutionContext)Context;

			if (intendedPluginStage != PluginStage.All && pluginContext.Stage != (int)intendedPluginStage)
			{
				throw new InvalidPluginExecutionException(
					$"Step registered on wrong stage: {pluginContext.Stage}, "
						+ $"expected: {intendedPluginStage}");
			}
		}

		protected void InitialisePlugin(PluginUser user = PluginUser.System)
		{
			tracingService = (ITracingService)ServiceProvider.GetService(typeof(ITracingService));

			TracingService.Trace("Getting context ...");
			context = (IPluginExecutionContext)ServiceProvider.GetService(typeof(IPluginExecutionContext));
			ValidateRegistration();

			TracingService.Trace("Getting factory ...");
			serviceFactory = (IOrganizationServiceFactory)ServiceProvider.GetService(typeof(IOrganizationServiceFactory));

			switch (user)
			{
				case PluginUser.ContextUser:
					TracingService.Trace("Running as ContextUser.");
					userId = Context.UserId;
					break;

				case PluginUser.InitiatingUser:
					TracingService.Trace("Running as InitiatingUserId.");
					userId = Context.InitiatingUserId;
					break;

				case PluginUser.System:
					TracingService.Trace("Running as System.");
					userId = null;
					break;

				case PluginUser.Custom:
					TracingService.Trace($"Running as {userId}.");
					break;

				default:
					throw new ArgumentOutOfRangeException("user", user, "Plugin user type is out of range.");
			}

			TracingService.Trace("Getting service ...");
			service = ServiceFactory.CreateOrganizationService(userId);

			if (!IsContextValid())
			{
				throw new InvalidPluginExecutionException("Failed to initialise plugin due to invalid context.");
			}

			TracingService.Trace($"Initialised plugin.");
		}
	}

	/// <summary>
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[GeneratedCode("This is not generated code, but this attribute is used for excluding the code from code analysis.", "0.0.0.0")]
	public abstract class StepLogic<TCodeActivity> : IPluginContext
		where TCodeActivity : CodeActivity
	{
		public virtual IPlugin Plugin => throw new NotSupportedException("Not supported in Code Activities.");
		public virtual CodeActivity CodeActivity => codeActivity;

		public virtual IServiceProvider ServiceProvider => throw new NotSupportedException("Not supported in Code Activities.");

		public virtual CodeActivityContext ExecutionContext
		{
			get
			{
				executionContext.Require(nameof(executionContext));
				return executionContext;
			}
		}

		public virtual IExecutionContext Context => context ?? (context = ExecutionContext.GetExtension<IWorkflowContext>());
		public virtual IOrganizationServiceFactory ServiceFactory => serviceFactory
			?? (serviceFactory = ExecutionContext.GetExtension<IOrganizationServiceFactory>());
		public virtual ITracingService TracingService => tracingService
			?? (tracingService = ExecutionContext.GetExtension<ITracingService>());

		public virtual IOrganizationService Service => service ?? (service = ServiceFactory.CreateOrganizationService(UserId));
		public virtual IOrganizationService EscalatedService => escalatedService
			?? (escalatedService = ServiceFactory.CreateOrganizationService(EscalationUserId));

		public virtual string Message => Context.MessageName;
		public virtual PluginStage Stage => throw new NotSupportedException("Not supported in Code Activities.");
		public virtual Guid UserId => userId ?? Context.UserId;

		public virtual Guid EscalationUserId => escalationUserId
			?? (escalationUserId = CrmHelpers.GetGenericConfig(Service, Context.OrganizationId)
				.GetAttributeValue<EntityReference>("ys_escalationuserid")?.Id)
				?? throw new ArgumentNullException(nameof(EscalationUserId), "Escalation User is not set in Common Configuration.");
		
		public virtual string Entity => Context.PrimaryEntityName;
		public virtual Guid Id => Context.PrimaryEntityId;

		public virtual CrmLog Log => log;

		public virtual Entity PreImage => preImage ?? (preImage = GetPreImage<Entity>());
		public virtual Entity Target => target ?? (target = GetTarget<Entity>());
		public virtual Entity PostImage
		{
			get
			{
				try
				{
					return postImage ?? (postImage = GetPostImage<Entity>(true));
				}
				catch
				{
					throw new InvalidPluginExecutionException("Missing a post-image for this step.");
				}
			}
		}

		protected TCodeActivity codeActivity;

		private CodeActivityContext executionContext;
		private IWorkflowContext context;
		private IOrganizationServiceFactory serviceFactory;
		private ITracingService tracingService;
		private IOrganizationService service;
		private IOrganizationService escalatedService;

		private Guid? userId;
		private Guid? escalationUserId;

		private CrmLog log;

		private Entity preImage;
		private Entity target;
		private Entity postImage;

		public virtual void Execute(TCodeActivity codeActivity, CodeActivityContext executionContext)
		{
			Execute(codeActivity, executionContext, PluginUser.System);
		}

		public virtual void Execute(TCodeActivity codeActivity, CodeActivityContext executionContext,
			bool isLogEnabled)
		{
			Execute(codeActivity, executionContext, PluginUser.System, null, isLogEnabled);
		}

		public virtual void Execute(TCodeActivity codeActivity, CodeActivityContext executionContext,
			Guid? userId, bool isLogEnabled = true)
		{
			Execute(codeActivity, executionContext, PluginUser.Custom, userId, isLogEnabled);
		}

		public virtual void Execute(TCodeActivity codeActivity, CodeActivityContext executionContext,
			PluginUser user, bool isLogEnabled = true)
		{
			Execute(codeActivity, executionContext, user, null, isLogEnabled);
		}

		public virtual void Execute(TCodeActivity codeActivity, CodeActivityContext executionContext,
			PluginUser user, Guid? userId, bool isLogEnabled = true)
		{
			this.codeActivity = codeActivity;
			this.executionContext = executionContext;
			this.userId = userId;

			InitialiseCodeActivity(user);

			try
			{
				TracingService.Trace("Initialising Log ...");
				log = new CrmLog(ExecutionContext);
				TracingService.Trace("Finished initialising Log.");

				if (isLogEnabled)
				{
					TracingService.Trace("Log enabled.");

					TracingService.Trace("Setting entry class in Log ...");
					Log.SetEntryClass(typeof(TCodeActivity).FullName);

					TracingService.Trace("Checking regarding to be set in Log ...");
					if (Context.PrimaryEntityName != null && Context.PrimaryEntityName != "none"
						&& Context.PrimaryEntityId != Guid.Empty)
					{
						TracingService.Trace("Setting regarding in Log ...");
						Log.SetRegarding(Context.PrimaryEntityName, Context.PrimaryEntityId);
					}
				}
			}
			catch (Exception ex)
			{
				throw new InvalidPluginExecutionException("Failed to init Log => " + ex.Message, ex);
			}

			try
			{
				if (isLogEnabled)
				{
					TracingService.Trace("Logging execution start ...");
					Log.LogExecutionStart();
				}

				TracingService.Trace("Executing step logic ...");
				ExecuteLogic();
				TracingService.Trace("Finished executing step.");
			}
			catch (Exception ex)
			{
				TracingService.Trace($"Exception occurred: {ex.Message}.");
				TracingService.Trace("Logging exception ...");

				if (isLogEnabled)
				{
					Log.ExecutionFailed();
					Log.Log(ex, Context);
				}
				else
				{
					TracingService.Trace(ex.ToString());
					TracingService.Trace(CrmHelpers.BuildExceptionMessage(ex));
				}

				throw new InvalidPluginExecutionException(ex.Message, ex);
			}
			finally
			{
				if (isLogEnabled)
				{
					TracingService.Trace("Logging execution end ...");

					try
					{
						Log.LogExecutionEnd();
					}
					catch (Exception e)
					{
						TracingService.Trace(e.ToString());
						TracingService.Trace(CrmHelpers.BuildExceptionMessage(e));
						throw;
					}
				}

				TracingService.Trace("Finished executing step.");
			}
		}

		protected abstract void ExecuteLogic();

		protected TEntity GetPreImage<TEntity>() where TEntity : Entity
		{
			if (Context.PreEntityImages.TryGetValue("PreBusinessEntity", out var image))
			{
				return image.ToEntity<TEntity>();
			}

			throw new InvalidPluginExecutionException("Missing a pre-image for this step.");
		}

		protected TEntity GetTarget<TEntity>() where TEntity : Entity
		{
			throw new InvalidPluginExecutionException("The Target parameter should not be accessed in a step.");
		}

		protected TEntity GetPostImage<TEntity>(bool retrieveIfMissing = false, ColumnSet columns = null) where TEntity : Entity
		{
			if (Context.PostEntityImages.TryGetValue("PostBusinessEntity", out var image))
			{
				return image.ToEntity<TEntity>();
			}

			if (retrieveIfMissing)
			{
				return service.Retrieve(Context.PrimaryEntityName, Context.PrimaryEntityId, columns == null ? new ColumnSet(true) : columns)
					.ToEntity<TEntity>();
			}

			throw new InvalidPluginExecutionException("Missing a post-image for this step.");
		}

		protected TEntity GetPostPreImage<TEntity>(bool retrieveIfMissing = false, ColumnSet columns = null) where TEntity : Entity
		{
			if (Context.PostEntityImages.TryGetValue("PostBusinessEntity", out var image))
			{
				return image.ToEntity<TEntity>();
			}

			if (Context.PreEntityImages.TryGetValue("PreBusinessEntity", out image))
			{
				return image.ToEntity<TEntity>();
			}

			if (retrieveIfMissing)
			{
				return service.Retrieve(Context.PrimaryEntityName, Context.PrimaryEntityId, columns == null ? new ColumnSet(true) : columns)
					.ToEntity<TEntity>();
			}

			throw new InvalidPluginExecutionException("Missing a post or pre-image for this step.");
		}

		protected virtual bool IsContextValid()
		{
			return true;
		}

		protected void InitialiseCodeActivity(PluginUser user = PluginUser.System)
		{
			tracingService = ExecutionContext.GetExtension<ITracingService>();
			context = ExecutionContext.GetExtension<IWorkflowContext>();
			TracingService.Trace("Got context.");
			serviceFactory = ExecutionContext.GetExtension<IOrganizationServiceFactory>();
			TracingService.Trace("Got factory.");

			switch (user)
			{
				case PluginUser.ContextUser:
					userId = context.UserId;
					TracingService.Trace("Running as ContextUser.");
					break;

				case PluginUser.InitiatingUser:
					userId = context.InitiatingUserId;
					TracingService.Trace("Running as InitiatingUserId.");
					break;

				case PluginUser.System:
					userId = null;
					TracingService.Trace("Running as System.");
					break;

				case PluginUser.Custom:
					TracingService.Trace($"Running as {userId}.");
					break;

				default:
					throw new ArgumentOutOfRangeException("user", user, "Step user type is out of range.");
			}

			service = ServiceFactory.CreateOrganizationService(userId);
			TracingService.Trace("Got service.");

			if (!IsContextValid())
			{
				throw new InvalidPluginExecutionException("Failed to initialise workflow step due to invalid context.");
			}

			TracingService.Trace($"Initialised step.");
		}
	}

	#endregion
}
